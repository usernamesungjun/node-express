import * as jspb from 'google-protobuf';
import { default as Long_2 } from 'long';

/**
 * `ActorID` is used to identify who is making changes to the document.
 * It is a hexadecimal string and should be generated by a unique value.
 *
 * @public
 */
export declare type ActorID = string;

/**
 * `AddOpInfo` represents the information of the add operation.
 */
export declare type AddOpInfo = {
    type: 'add';
    path: string;
    index: number;
};

/**
 * `ArrayOperationInfo` represents the OperationInfo for the JSONArray.
 */
export declare type ArrayOperationInfo = AddOpInfo | RemoveOpInfo | MoveOpInfo;

/**
 * `BaseArray` is a base type of JSONArray.
 */
declare type BaseArray<T> = JSONArray<T> | Array<T>;

/**
 * @internal
 */
declare interface BaseClientEvent {
    type: ClientEventType;
}

/**
 * @internal
 */
declare interface BaseDocEvent {
    type: DocEventType;
}

declare type BaseObject<T> = JSONObject<T> | Record<string, T>;

/**
 * `bytesToObject` creates an JSONObject from the given byte array.
 */
declare function bytesToObject(bytes?: Uint8Array): CRDTObject;

/**
 * `bytesToSnapshot` creates a Snapshot from the given byte array.
 */
declare function bytesToSnapshot<P extends Indexable>(bytes?: Uint8Array): {
    root: CRDTObject;
    presences: Map<ActorID, P>;
};

/**
 * `Change` represents a unit of modification in the document.
 */
export declare class Change<P extends Indexable> {
    private id;
    private operations;
    private presenceChange?;
    private message?;
    constructor({ id, operations, presenceChange, message, }: {
        id: ChangeID;
        operations?: Array<Operation>;
        presenceChange?: PresenceChange<P>;
        message?: string;
    });
    /**
     * `create` creates a new instance of Change.
     */
    static create<P extends Indexable>({ id, operations, presenceChange, message, }: {
        id: ChangeID;
        operations?: Array<Operation>;
        presenceChange?: PresenceChange<P>;
        message?: string;
    }): Change<P>;
    /**
     * `getID` returns the ID of this change.
     */
    getID(): ChangeID;
    /**
     * `getMessage` returns the message of this change.
     */
    getMessage(): string | undefined;
    /**
     * `hasOperations` returns whether this change has operations or not.
     */
    hasOperations(): boolean;
    /**
     * `getOperations` returns the operations of this change.
     */
    getOperations(): Array<Operation>;
    /**
     * `setActor` sets the given actor.
     */
    setActor(actorID: ActorID): void;
    /**
     * `hasPresenceChange` returns whether this change has presence change or not.
     */
    hasPresenceChange(): boolean;
    /**
     * `getPresenceChange` returns the presence change of this change.
     */
    getPresenceChange(): PresenceChange<P> | undefined;
    /**
     * `execute` executes the operations of this change to the given root.
     */
    execute(root: CRDTRoot, presences: Map<ActorID, P>, source: OpSource): {
        opInfos: Array<OperationInfo>;
        reverseOps: Array<HistoryOperation<P>>;
    };
    /**
     * `toTestString` returns a string containing the meta data of this change.
     */
    toTestString(): string;
}

declare class Change_2 extends jspb.Message {
    getId(): ChangeID_2 | undefined;
    setId(value?: ChangeID_2): Change_2;
    hasId(): boolean;
    clearId(): Change_2;

    getMessage(): string;
    setMessage(value: string): Change_2;

    getOperationsList(): Array<Operation_2>;
    setOperationsList(value: Array<Operation_2>): Change_2;
    clearOperationsList(): Change_2;
    addOperations(value?: Operation_2, index?: number): Operation_2;

    getPresenceChange(): PresenceChange_2 | undefined;
    setPresenceChange(value?: PresenceChange_2): Change_2;
    hasPresenceChange(): boolean;
    clearPresenceChange(): Change_2;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Change_2.AsObject;
    static toObject(includeInstance: boolean, msg: Change_2): Change_2.AsObject;
    static serializeBinaryToWriter(message: Change_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Change_2;
    static deserializeBinaryFromReader(message: Change_2, reader: jspb.BinaryReader): Change_2;
}

declare namespace Change_2 {
    type AsObject = {
        id?: ChangeID_2.AsObject,
        message: string,
        operationsList: Array<Operation_2.AsObject>,
        presenceChange?: PresenceChange_2.AsObject,
    }
}

/**
 * `ChangeContext` is used to record the context of modification when editing
 * a document. Each time we add an operation, a new time ticket is issued.
 * Finally returns a Change after the modification has been completed.
 */
declare class ChangeContext<P extends Indexable = Indexable> {
    private id;
    private delimiter;
    private message?;
    private root;
    private operations;
    private presenceChange?;
    /**
     * `previousPresence` stores the previous presence to be used for undoing
     * presence changes.
     */
    private previousPresence;
    /**
     * `reversePresenceKeys` stores the keys of the presence to be used for undoing
     * presence changes.
     */
    private reversePresenceKeys;
    constructor(id: ChangeID, root: CRDTRoot, presence: P, message?: string);
    /**
     * `create` creates a new instance of ChangeContext.
     */
    static create<P extends Indexable>(id: ChangeID, root: CRDTRoot, presence: P, message?: string): ChangeContext<P>;
    /**
     * `push` pushes the given operation to this context.
     */
    push(operation: Operation): void;
    /**
     * `registerElement` registers the given element to the root.
     */
    registerElement(element: CRDTElement, parent: CRDTContainer): void;
    /**
     * `registerRemovedElement` register removed element for garbage collection.
     */
    registerRemovedElement(deleted: CRDTElement): void;
    /**
     * `registerElementHasRemovedNodes` register GC element has removed node for
     * garbage collection.
     */
    registerElementHasRemovedNodes(elem: CRDTGCElement): void;
    /**
     * `getChange` creates a new instance of Change in this context.
     */
    getChange(): Change<P>;
    /**
     * `hasChange` returns whether this context has change or not.
     */
    hasChange(): boolean;
    /**
     * `setPresenceChange` registers the presence change to this context.
     */
    setPresenceChange(presenceChange: PresenceChange<P>): void;
    /**
     * `setReversePresence` registers the previous presence to undo presence updates.
     */
    setReversePresence(presence: Partial<P>, option?: {
        addToHistory: boolean;
    }): void;
    /**
     * `toReversePresence` returns the reverse presence of this context.
     */
    getReversePresence(): Partial<P> | undefined;
    /**
     * `issueTimeTicket` creates a time ticket to be used to create a new operation.
     */
    issueTimeTicket(): TimeTicket;
    /**
     * `getLastTimeTicket` returns the last time ticket issued in this context.
     */
    getLastTimeTicket(): TimeTicket;
}

/**
 * `ChangeID` is for identifying the Change. This is immutable.
 */
declare class ChangeID {
    private clientSeq;
    private serverSeq?;
    private lamport;
    private actor?;
    constructor(clientSeq: number, lamport: Long_2, actor?: ActorID);
    /**
     * `of` creates a new instance of ChangeID.
     */
    static of(clientSeq: number, lamport: Long_2, actor?: ActorID): ChangeID;
    /**
     * `next` creates a next ID of this ID.
     */
    next(): ChangeID;
    /**
     * `syncLamport` syncs lamport timestamp with the given ID.
     *
     * {@link https://en.wikipedia.org/wiki/Lamport_timestamps#Algorithm}
     */
    syncLamport(otherLamport: Long_2): ChangeID;
    /**
     * `createTimeTicket` creates a ticket of the given delimiter.
     */
    createTimeTicket(delimiter: number): TimeTicket;
    /**
     * `setActor` sets the given actor.
     */
    setActor(actorID: ActorID): ChangeID;
    /**
     * `getClientSeq` returns the client sequence of this ID.
     */
    getClientSeq(): number;
    /**
     * `getLamport` returns the lamport clock of this ID.
     */
    getLamport(): Long_2;
    /**
     * `getLamportAsString` returns the lamport clock of this ID as a string.
     */
    getLamportAsString(): string;
    /**
     * `getActorID` returns the actor of this ID.
     */
    getActorID(): string | undefined;
    /**
     * `toTestString` returns a string containing the meta data of this ID.
     */
    toTestString(): string;
}

declare class ChangeID_2 extends jspb.Message {
    getClientSeq(): number;
    setClientSeq(value: number): ChangeID_2;

    getServerSeq(): string;
    setServerSeq(value: string): ChangeID_2;

    getLamport(): string;
    setLamport(value: string): ChangeID_2;

    getActorId(): Uint8Array | string;
    getActorId_asU8(): Uint8Array;
    getActorId_asB64(): string;
    setActorId(value: Uint8Array | string): ChangeID_2;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ChangeID_2.AsObject;
    static toObject(includeInstance: boolean, msg: ChangeID_2): ChangeID_2.AsObject;
    static serializeBinaryToWriter(message: ChangeID_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ChangeID_2;
    static deserializeBinaryFromReader(message: ChangeID_2, reader: jspb.BinaryReader): ChangeID_2;
}

declare namespace ChangeID_2 {
    type AsObject = {
        clientSeq: number,
        serverSeq: string,
        lamport: string,
        actorId: Uint8Array | string,
    }
}

/**
 * `ChangeInfo` represents the modifications made during a document update
 * and the message passed.
 */
export declare interface ChangeInfo<T = OperationInfo> {
    message: string;
    operations: Array<T>;
    actor: ActorID | undefined;
}

/**
 * `ChangePack` is a unit for delivering changes in a document to the remote.
 *
 */
declare class ChangePack<P extends Indexable> {
    /**
     * `documentKey` is the key of the document.
     */
    private documentKey;
    /**
     * `Checkpoint` is used to determine the client received changes.
     */
    private checkpoint;
    /**
     * `isRemoved` is a flag that indicates whether the document is removed.
     */
    private isRemoved;
    private changes;
    /**
     * `snapshot` is a byte array that encodes the document.
     */
    private snapshot?;
    /**
     * `minSyncedTicket` is the minimum logical time taken by clients who attach
     * to the document. It is used to collect garbage on the replica on the
     * client.
     */
    private minSyncedTicket?;
    constructor(key: string, checkpoint: Checkpoint, isRemoved: boolean, changes: Array<Change<P>>, snapshot?: Uint8Array, minSyncedTicket?: TimeTicket);
    /**
     * `create` creates a new instance of ChangePack.
     */
    static create<P extends Indexable>(key: string, checkpoint: Checkpoint, isRemoved: boolean, changes: Array<Change<P>>, snapshot?: Uint8Array, minSyncedTicket?: TimeTicket): ChangePack<P>;
    /**
     * `getKey` returns the document key of this pack.
     */
    getDocumentKey(): string;
    /**
     * `getCheckpoint` returns the checkpoint of this pack.
     */
    getCheckpoint(): Checkpoint;
    /**
     * `getIsRemoved` returns the whether this document is removed.
     */
    getIsRemoved(): boolean;
    /**
     * `getChanges` returns the changes of this pack.
     */
    getChanges(): Array<Change<P>>;
    /**
     * `hasChanges` returns the whether this pack has changes or not.
     */
    hasChanges(): boolean;
    /**
     * `getChangeSize` returns the size of changes this pack has.
     */
    getChangeSize(): number;
    /**
     * `hasSnapshot` returns the whether this pack has a snapshot or not.
     */
    hasSnapshot(): boolean;
    /**
     * `getSnapshot` returns the snapshot of this pack.
     */
    getSnapshot(): Uint8Array | undefined;
    /**
     * `getMinSyncedTicket` returns the minimum synced ticket of this pack.
     */
    getMinSyncedTicket(): TimeTicket | undefined;
}

declare class ChangePack_2 extends jspb.Message {
    getDocumentKey(): string;
    setDocumentKey(value: string): ChangePack_2;

    getCheckpoint(): Checkpoint_2 | undefined;
    setCheckpoint(value?: Checkpoint_2): ChangePack_2;
    hasCheckpoint(): boolean;
    clearCheckpoint(): ChangePack_2;

    getSnapshot(): Uint8Array | string;
    getSnapshot_asU8(): Uint8Array;
    getSnapshot_asB64(): string;
    setSnapshot(value: Uint8Array | string): ChangePack_2;

    getChangesList(): Array<Change_2>;
    setChangesList(value: Array<Change_2>): ChangePack_2;
    clearChangesList(): ChangePack_2;
    addChanges(value?: Change_2, index?: number): Change_2;

    getMinSyncedTicket(): TimeTicket_2 | undefined;
    setMinSyncedTicket(value?: TimeTicket_2): ChangePack_2;
    hasMinSyncedTicket(): boolean;
    clearMinSyncedTicket(): ChangePack_2;

    getIsRemoved(): boolean;
    setIsRemoved(value: boolean): ChangePack_2;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ChangePack_2.AsObject;
    static toObject(includeInstance: boolean, msg: ChangePack_2): ChangePack_2.AsObject;
    static serializeBinaryToWriter(message: ChangePack_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ChangePack_2;
    static deserializeBinaryFromReader(message: ChangePack_2, reader: jspb.BinaryReader): ChangePack_2;
}

declare namespace ChangePack_2 {
    type AsObject = {
        documentKey: string,
        checkpoint?: Checkpoint_2.AsObject,
        snapshot: Uint8Array | string,
        changesList: Array<Change_2.AsObject>,
        minSyncedTicket?: TimeTicket_2.AsObject,
        isRemoved: boolean,
    }
}

/**
 * `Checkpoint` is used to determine the changes sent and received by the
 * client. This is immutable.
 *
 **/
declare class Checkpoint {
    private serverSeq;
    private clientSeq;
    constructor(serverSeq: Long_2, clientSeq: number);
    /**
     * `of` creates a new instance of Checkpoint.
     */
    static of(serverSeq: Long_2, clientSeq: number): Checkpoint;
    /**
     * `increaseClientSeq` creates a new instance with increased client sequence.
     */
    increaseClientSeq(inc: number): Checkpoint;
    /**
     * `forward` creates a new instance with the given checkpoint if it is
     * greater than the values of internal properties.
     */
    forward(other: Checkpoint): Checkpoint;
    /**
     * `getServerSeqAsString` returns the server seq of this checkpoint as a
     * string.
     */
    getServerSeqAsString(): string;
    /**
     * `getClientSeq` returns the client seq of this checkpoint.
     */
    getClientSeq(): number;
    /**
     * `getServerSeq` returns the server seq of this checkpoint.
     */
    getServerSeq(): Long_2;
    /**
     * `equals` returns whether the given checkpoint is equal to this checkpoint
     * or not.
     */
    equals(other: Checkpoint): boolean;
    /**
     * `toTestString` returns a string containing the meta data of this
     * checkpoint.
     */
    toTestString(): string;
}

declare class Checkpoint_2 extends jspb.Message {
    getServerSeq(): string;
    setServerSeq(value: string): Checkpoint_2;

    getClientSeq(): number;
    setClientSeq(value: number): Checkpoint_2;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Checkpoint_2.AsObject;
    static toObject(includeInstance: boolean, msg: Checkpoint_2): Checkpoint_2.AsObject;
    static serializeBinaryToWriter(message: Checkpoint_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Checkpoint_2;
    static deserializeBinaryFromReader(message: Checkpoint_2, reader: jspb.BinaryReader): Checkpoint_2;
}

declare namespace Checkpoint_2 {
    type AsObject = {
        serverSeq: string,
        clientSeq: number,
    }
}

/**
 * `Client` is a normal client that can communicate with the server.
 * It has documents and sends changes of the documents in local
 * to the server to synchronize with other replicas in remote.
 *
 * @public
 */
export declare class Client implements Observable<ClientEvent> {
    private id?;
    private key;
    private status;
    private attachmentMap;
    private apiKey;
    private syncLoopDuration;
    private reconnectStreamDelay;
    private retrySyncLoopDelay;
    private rpcClient;
    private eventStream;
    private eventStreamObserver;
    /**
     * @param rpcAddr - the address of the RPC server.
     * @param opts - the options of the client.
     */
    constructor(rpcAddr: string, opts?: ClientOptions);
    /**
     * `activate` activates this client. That is, it registers itself to the server
     * and receives a unique ID from the server. The given ID is used to
     * distinguish different clients.
     */
    activate(): Promise<void>;
    /**
     * `deactivate` deactivates this client.
     */
    deactivate(): Promise<void>;
    /**
     * `attach` attaches the given document to this client. It tells the server that
     * this client will synchronize the given document.
     */
    attach<T, P extends Indexable>(doc: Document_2<T, P>, options?: {
        initialPresence?: P;
        isRealtimeSync?: boolean;
    }): Promise<Document_2<T, P>>;
    /**
     * `detach` detaches the given document from this client. It tells the
     * server that this client will no longer synchronize the given document.
     *
     * To collect garbage things like CRDT tombstones left on the document, all
     * the changes should be applied to other replicas before GC time. For this,
     * if the document is no longer used by this client, it should be detached.
     */
    detach<T, P extends Indexable>(doc: Document_2<T, P>): Promise<Document_2<T, P>>;
    /**
     * `pause` changes the synchronization mode of the given document to manual.
     */
    pause<T, P extends Indexable>(doc: Document_2<T, P>): Promise<Document_2<T, P>>;
    /**
     * `resume` changes the synchronization mode of the given document to realtime.
     */
    resume<T, P extends Indexable>(doc: Document_2<T, P>): Promise<Document_2<T, P>>;
    /**
     * `pauseRemoteChanges` pauses the synchronization of remote changes,
     * allowing only local changes to be applied.
     */
    pauseRemoteChanges<T, P extends Indexable>(doc: Document_2<T, P>): void;
    /**
     * `resumeRemoteChanges` resumes the synchronization of remote changes,
     * allowing both local and remote changes to be applied.
     */
    resumeRemoteChanges<T, P extends Indexable>(doc: Document_2<T, P>): void;
    /**
     * `changeRealtimeSync` changes the synchronization mode of the given document.
     */
    private changeRealtimeSync;
    /**
     * `sync` pushes local changes of the attached documents to the server and
     * receives changes of the remote replica from the server then apply them to
     * local documents.
     */
    sync<T, P extends Indexable>(doc?: Document_2<T, P>, syncMode?: SyncMode): Promise<Array<Document_2<T, P>>>;
    /**
     * `remove` removes the given document.
     */
    remove<T, P extends Indexable>(doc: Document_2<T, P>): Promise<void>;
    /**
     * `subscribe` subscribes to the given topics.
     */
    subscribe(nextOrObserver: Observer<ClientEvent> | NextFn<ClientEvent>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `getID` returns a ActorID of client.
     */
    getID(): string | undefined;
    /**
     * `getKey` returns a key of client.
     */
    getKey(): string;
    /**
     * `isActive` checks if the client is active.
     */
    isActive(): boolean;
    /**
     * `getStatus` returns the status of this client.
     */
    getStatus(): ClientStatus;
    private runSyncLoop;
    private runWatchLoop;
    private handleWatchDocumentsResponse;
    private detachInternal;
    private syncInternal;
}

/**
 * `ClientEvent` is an event that occurs in `Client`. It can be delivered using
 * `Client.subscribe()`.
 *
 * @public
 */
export declare type ClientEvent = StatusChangedEvent | DocumentChangedEvent | StreamConnectionStatusChangedEvent | DocumentSyncedEvent;

/**
 * `ClientEventType` represents the type of the event that the client can emit.
 * @public
 */
export declare enum ClientEventType {
    /**
     * `StatusChanged` means that the status of the client has changed.
     */
    StatusChanged = "status-changed",
    /**
     * `DocumentChanged` means that the document has changed.
     */
    DocumentChanged = "document-changed",
    /**
     * `StreamConnectionStatusChanged` means that the stream connection status of
     * the client has changed.
     */
    StreamConnectionStatusChanged = "stream-connection-status-changed",
    /**
     * `DocumentSynced` means that the document has been synced with the server.
     */
    DocumentSynced = "document-synced"
}

/**
 * `ClientOptions` are user-settable options used when defining clients.
 *
 * @public
 */
export declare interface ClientOptions {
    /**
     * `key` is the client key. It is used to identify the client.
     * If not set, a random key is generated.
     */
    key?: string;
    /**
     * `apiKey` is the API key of the project. It is used to identify the project.
     * If not set, API key of the default project is used.
     */
    apiKey?: string;
    /**
     * `token` is the authentication token of this client. It is used to identify
     * the user of the client.
     */
    token?: string;
    /**
     * `syncLoopDuration` is the duration of the sync loop. After each sync loop,
     * the client waits for the duration to next sync. The default value is
     * `50`(ms).
     */
    syncLoopDuration?: number;
    /**
     * `retrySyncLoopDelay` is the delay of the retry sync loop. If the sync loop
     * fails, the client waits for the delay to retry the sync loop. The default
     * value is `1000`(ms).
     */
    retrySyncLoopDelay?: number;
    /**
     * `reconnectStreamDelay` is the delay of the reconnect stream. If the stream
     * is disconnected, the client waits for the delay to reconnect the stream. The
     * default value is `1000`(ms).
     */
    reconnectStreamDelay?: number;
}

/**
 * `ClientStatus` represents the status of the client.
 * @public
 */
export declare enum ClientStatus {
    /**
     * `Deactivated` means that the client is not activated. It is the initial
     * status of the client. If the client is deactivated, all `Document`s of the
     * client are also not used.
     */
    Deactivated = "deactivated",
    /**
     * `Activated` means that the client is activated. If the client is activated,
     * all `Document`s of the client are also ready to be used.
     */
    Activated = "activated"
}

declare type Comparator<K> = (keyA: K, keyB: K) => number;

export declare type CompleteFn = () => void;

declare type ContainerValue = {
    [key: string]: JSONElement_2;
};

/**
 * `converter` is a converter that converts the given model to protobuf format.
 * is also used to convert models to bytes and vice versa.
 */
export declare const converter: {
    fromPresence: typeof fromPresence;
    toChangePack: typeof toChangePack;
    fromChangePack: typeof fromChangePack;
    fromChanges: typeof fromChanges;
    objectToBytes: typeof objectToBytes;
    bytesToObject: typeof bytesToObject;
    bytesToSnapshot: typeof bytesToSnapshot;
    toHexString: typeof toHexString;
    toUint8Array: typeof toUint8Array;
};

/**
 * `Counter` is a custom data type that is used to counter.
 */
export declare class Counter {
    private valueType;
    private value;
    private context?;
    private counter?;
    constructor(valueType: CounterType, value: number | Long_2);
    /**
     * `initialize` initialize this text with context and internal text.
     * @internal
     */
    initialize(context: ChangeContext, counter: CRDTCounter): void;
    /**
     * `getID` returns the ID of this text.
     */
    getID(): TimeTicket;
    /**
     * `getValue` returns the value of this counter;
     * @internal
     */
    getValue(): number | Long_2;
    /**
     * `getValueType` returns the value type of this counter.
     */
    getValueType(): CounterType;
    /**
     * `increase` increases numeric data.
     */
    increase(v: number | Long_2): Counter;
}

/**
 * `CounterOperationInfo` represents the OperationInfo for the yorkie.Counter.
 */
export declare type CounterOperationInfo = IncreaseOpInfo;

declare enum CounterType {
    IntegerCnt = 0,
    LongCnt = 1
}

declare type CounterValue = number | Long_2;

/**
 *
 * `CRDTContainer` represents CRDTArray or CRDtObject.
 */
declare abstract class CRDTContainer extends CRDTElement {
    constructor(createdAt: TimeTicket);
    /**
     * `subPathOf` returns the sub path of the given element.
     */
    abstract subPathOf(createdAt: TimeTicket): string | undefined;
    abstract purge(element: CRDTElement): void;
    abstract delete(createdAt: TimeTicket, executedAt: TimeTicket): CRDTElement;
    abstract getDescendants(callback: (elem: CRDTElement, parent: CRDTContainer) => boolean): void;
    /**
     * `get` returns the element of the given key or index. This method is called
     * by users. So it should return undefined if the element is removed.
     */
    abstract get(keyOrIndex: string | number): CRDTElement | undefined;
    /**
     * `getByID` returns the element of the given creation time. This method is
     * called by internal. So it should return the element even if the element is
     * removed.
     */
    abstract getByID(createdAt: TimeTicket): CRDTElement | undefined;
}

/**
 * `CRDTCounter` is a CRDT implementation of a counter. It is used to represent
 * a number that can be incremented or decremented.
 *
 * @internal
 */
declare class CRDTCounter extends CRDTElement {
    private valueType;
    private value;
    constructor(valueType: CounterType, value: CounterValue, createdAt: TimeTicket);
    /**
     * `of` creates a new instance of Counter.
     */
    static create(valueType: CounterType, value: CounterValue, createdAt: TimeTicket): CRDTCounter;
    /**
     * `valueFromBytes` parses the given bytes into value.
     */
    static valueFromBytes(counterType: CounterType, bytes: Uint8Array): CounterValue;
    /**
     * `toJSON` returns the JSON encoding of the value.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of the value.
     */
    toSortedJSON(): string;
    /**
     * `toJSForTest` returns value with meta data for testing.
     */
    toJSForTest(): Devtools.JSONElement;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTCounter;
    /**
     * `getType` returns the type of the value.
     */
    getType(): CounterType;
    /**
     * `getCounterType` returns counter type of given value.
     */
    static getCounterType(value: CounterValue): CounterType | undefined;
    /**
     * `isSupport` check if there is a counter type of given value.
     */
    static isSupport(value: CounterValue): boolean;
    /**
     * `isInteger` checks if the num is integer.
     */
    static isInteger(num: number): boolean;
    /**
     * `isNumericType` check numeric type by JSONCounter.
     */
    isNumericType(): boolean;
    /**
     * `getValueType` get counter value type.
     */
    getValueType(): CounterType;
    /**
     * `getValue` get counter value.
     */
    getValue(): CounterValue;
    /**
     * `toBytes` creates an array representing the value.
     */
    toBytes(): Uint8Array;
    /**
     * `increase` increases numeric data.
     */
    increase(v: Primitive): CRDTCounter;
}

/**
 * `CRDTElement` represents an element that has `TimeTicket`s.
 *
 * @internal
 */
declare abstract class CRDTElement {
    private createdAt;
    private movedAt?;
    private removedAt?;
    constructor(createdAt: TimeTicket);
    /**
     * `getCreatedAt` returns the creation time of this element.
     */
    getCreatedAt(): TimeTicket;
    /**
     * `getID` returns the creation time of this element.
     */
    getID(): TimeTicket;
    /**
     * `getMovedAt` returns the move time of this element.
     */
    getMovedAt(): TimeTicket | undefined;
    /**
     * `getRemovedAt` returns the removal time of this element.
     */
    getRemovedAt(): TimeTicket | undefined;
    /**
     * `getPositionedAt` returns the time of this element when it was positioned
     * in the document by undo/redo or move operation.
     */
    getPositionedAt(): TimeTicket;
    /**
     * `setMovedAt` sets the move time of this element.
     */
    setMovedAt(movedAt?: TimeTicket): boolean;
    /**
     * `setRemovedAt` sets the remove time of this element.
     */
    setRemovedAt(removedAt?: TimeTicket): void;
    /**
     * `remove` removes this element.
     */
    remove(removedAt?: TimeTicket): boolean;
    /**
     * `isRemoved` check if this element was removed.
     */
    isRemoved(): boolean;
    abstract toJSON(): string;
    abstract toSortedJSON(): string;
    abstract toJSForTest(): Devtools.JSONElement;
    abstract deepcopy(): CRDTElement;
}

/**
 * `CRDTElementPair` is a structure that represents a pair of element and its
 * parent. It is used to find the parent of a specific element to perform
 * garbage collection and to find the path of a specific element.
 */
declare interface CRDTElementPair {
    element: CRDTElement;
    parent?: CRDTContainer;
}

/**
 * `CRDTGCElement` represents element which has garbage collecting method.
 */
declare abstract class CRDTGCElement extends CRDTElement {
    abstract getRemovedNodesLen(): number;
    abstract purgeRemovedNodesBefore(ticket: TimeTicket): number;
}

/**
 * `CRDTObject` represents an object data type, but unlike regular JSON,
 * it has `TimeTicket`s which are created by logical clock.
 *
 */
declare class CRDTObject extends CRDTContainer {
    private memberNodes;
    /** @hideconstructor */
    constructor(createdAt: TimeTicket, memberNodes: ElementRHT);
    /**
     * `create` creates a new instance of CRDTObject.
     */
    static create(createdAt: TimeTicket, value?: {
        [key: string]: CRDTElement;
    }): CRDTObject;
    /**
     * `subPathOf` returns the sub path of the given element.
     */
    subPathOf(createdAt: TimeTicket): string | undefined;
    /**
     * `purge` physically purges the given element.
     */
    purge(value: CRDTElement): void;
    /**
     * `set` sets the given element of the given key.
     */
    set(key: string, value: CRDTElement, executedAt: TimeTicket): CRDTElement | undefined;
    /**
     * `delete` deletes the element of the given key.
     */
    delete(createdAt: TimeTicket, executedAt: TimeTicket): CRDTElement;
    /**
     * `deleteByKey` deletes the element of the given key and execution time.
     */
    deleteByKey(key: string, executedAt: TimeTicket): CRDTElement | undefined;
    /**
     * `get` returns the value of the given key.
     */
    get(key: string): CRDTElement | undefined;
    /**
     * `getByID` returns the element of the given createAt.
     */
    getByID(createdAt: TimeTicket): CRDTElement | undefined;
    /**
     * `has` returns whether the element exists of the given key or not.
     */
    has(key: string): boolean;
    /**
     * `toJSON` returns the JSON encoding of this object.
     */
    toJSON(): string;
    /**
     * `toJS` returns the JavaScript object of this object.
     */
    toJS(): any;
    /**
     * `toJSForTest` returns value with meta data for testing.
     */
    toJSForTest(): Devtools.JSONElement;
    /**
     * `getKeys` returns array of keys in this object.
     */
    getKeys(): Array<string>;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this object.
     */
    toSortedJSON(): string;
    /**
     * `getRHT` RHTNodes returns the RHTPQMap nodes.
     */
    getRHT(): ElementRHT;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTObject;
    /**
     * `getDescendants` returns the descendants of this object by traversing.
     */
    getDescendants(callback: (elem: CRDTElement, parent: CRDTContainer) => boolean): void;
    /**
     * eslint-disable-next-line jsdoc/require-jsdoc
     * @internal
     */
    [Symbol.iterator](): IterableIterator<[string, CRDTElement]>;
}

/**
 * `CRDTRoot` is a structure that represents the root. It has a hash table of
 * all elements to find a specific element when applying remote changes
 * received from server.
 *
 * Every element has a unique `TimeTicket` at creation, which allows us to find
 * a particular element.
 */
declare class CRDTRoot {
    /**
     * `rootObject` is the root object of the document.
     */
    private rootObject;
    /**
     * `elementPairMapByCreatedAt` is a hash table that maps the creation time of
     * an element to the element itself and its parent.
     */
    private elementPairMapByCreatedAt;
    /**
     * `removedElementSetByCreatedAt` is a hash set that contains the creation
     * time of the removed element. It is used to find the removed element when
     * executing garbage collection.
     */
    private removedElementSetByCreatedAt;
    /**
     * `elementHasRemovedNodesSetByCreatedAt` is a hash set that contains the
     * creation time of the element that has removed nodes. It is used to find
     * the element that has removed nodes when executing garbage collection.
     */
    private elementHasRemovedNodesSetByCreatedAt;
    /**
     * `opsForTest` is used for debugging the entire operation.
     * operations accumulate only in dev mode.
     */
    opsForTest: Array<Array<Operation>>;
    constructor(rootObject: CRDTObject);
    /**
     * `create` creates a new instance of Root.
     */
    static create(): CRDTRoot;
    /**
     * `findByCreatedAt` returns the element of given creation time.
     */
    findByCreatedAt(createdAt: TimeTicket): CRDTElement | undefined;
    /**
     * `findElementPairByCreatedAt` returns the element and parent pair
     * of given creation time.
     */
    findElementPairByCreatedAt(createdAt: TimeTicket): CRDTElementPair | undefined;
    /**
     * `createSubPaths` creates an array of the sub paths for the given element.
     */
    createSubPaths(createdAt: TimeTicket): Array<string>;
    /**
     * `createPath` creates path of the given element.
     */
    createPath(createdAt: TimeTicket): string;
    /**
     * `registerElement` registers the given element and its descendants to hash table.
     */
    registerElement(element: CRDTElement, parent?: CRDTContainer): void;
    /**
     * `deregisterElement` deregister the given element and its descendants from hash table.
     */
    deregisterElement(element: CRDTElement): number;
    /**
     * `registerRemovedElement` registers the given element to the hash set.
     */
    registerRemovedElement(element: CRDTElement): void;
    /**
     * `registerElementHasRemovedNodes` registers the given GC element to the
     * hash set.
     */
    registerElementHasRemovedNodes(elem: CRDTGCElement): void;
    /**
     * `getElementMapSize` returns the size of element map.
     */
    getElementMapSize(): number;
    /**
     * `getRemovedElementSetSize()` returns the size of removed element set.
     */
    getRemovedElementSetSize(): number;
    /**
     * `getObject` returns root object.
     */
    getObject(): CRDTObject;
    /**
     * `getGarbageLen` returns length of nodes which can be garbage collected.
     */
    getGarbageLen(): number;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTRoot;
    /**
     * `garbageCollect` purges elements that were removed before the given time.
     */
    garbageCollect(ticket: TimeTicket): number;
    /**
     * `toJSON` returns the JSON encoding of this root object.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this root object.
     */
    toSortedJSON(): string;
}

/**
 *  `CRDTText` is a custom CRDT data type to represent the contents of text editors.
 *
 */
declare class CRDTText<A extends Indexable = Indexable> extends CRDTGCElement {
    private rgaTreeSplit;
    constructor(rgaTreeSplit: RGATreeSplit<CRDTTextValue>, createdAt: TimeTicket);
    /**
     * `create` a instance of Text.
     */
    static create<A extends Indexable>(rgaTreeSplit: RGATreeSplit<CRDTTextValue>, createdAt: TimeTicket): CRDTText<A>;
    /**
     * `edit` edits the given range with the given value and attributes.
     *
     * @internal
     */
    edit(range: RGATreeSplitPosRange, content: string, editedAt: TimeTicket, attributes?: Record<string, string>, latestCreatedAtMapByActor?: Map<string, TimeTicket>): [Map<string, TimeTicket>, Array<TextChange<A>>, RGATreeSplitPosRange];
    /**
     * `setStyle` applies the style of the given range.
     * 01. split nodes with from and to
     * 02. style nodes between from and to
     *
     * @param range - range of RGATreeSplitNode
     * @param attributes - style attributes
     * @param editedAt - edited time
     * @internal
     */
    setStyle(range: RGATreeSplitPosRange, attributes: Record<string, string>, editedAt: TimeTicket, latestCreatedAtMapByActor?: Map<string, TimeTicket>): [Map<string, TimeTicket>, Array<TextChange<A>>];
    /**
     * `indexRangeToPosRange` returns the position range of the given index range.
     */
    indexRangeToPosRange(fromIdx: number, toIdx: number): RGATreeSplitPosRange;
    /**
     * `length` returns size of RGATreeList.
     */
    get length(): number;
    /**
     * `checkWeight` returns false when there is an incorrect weight node.
     * for debugging purpose.
     */
    checkWeight(): boolean;
    /**
     * `toJSON` returns the JSON encoding of this text.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this text.
     */
    toSortedJSON(): string;
    /**
     * `toJSForTest` returns value with meta data for testing.
     */
    toJSForTest(): Devtools.JSONElement;
    /**
     * `toString` returns the string representation of this text.
     */
    toString(): string;
    /**
     * `values` returns the content-attributes pair array of this text.
     */
    values(): Array<TextValueType<A>>;
    /**
     * `getRGATreeSplit` returns rgaTreeSplit.
     *
     * @internal
     */
    getRGATreeSplit(): RGATreeSplit<CRDTTextValue>;
    /**
     * `toTestString` returns a String containing the meta data of this value
     * for debugging purpose.
     */
    toTestString(): string;
    /**
     * `getRemovedNodesLen` returns length of removed nodes
     */
    getRemovedNodesLen(): number;
    /**
     * `purgeRemovedNodesBefore` purges removed nodes before the given time.
     *
     * @internal
     */
    purgeRemovedNodesBefore(ticket: TimeTicket): number;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTText<A>;
    /**
     * `findIndexesFromRange` returns pair of integer offsets of the given range.
     */
    findIndexesFromRange(range: RGATreeSplitPosRange): [number, number];
}

/**
 * `CRDTTextValue` is a value of Text
 * which has a attributes that expresses the text style.
 * Attributes are represented by RHT.
 *
 */
declare class CRDTTextValue {
    private attributes;
    private content;
    /** @hideconstructor */
    constructor(content: string);
    /**
     * `create` creates a instance of CRDTTextValue.
     */
    static create(content: string): CRDTTextValue;
    /**
     * `length` returns the length of value.
     */
    get length(): number;
    /**
     * `substring` returns a sub-string value of the given range.
     */
    substring(indexStart: number, indexEnd: number): CRDTTextValue;
    /**
     * `setAttr` sets attribute of the given key, updated time and value.
     */
    setAttr(key: string, content: string, updatedAt: TimeTicket): void;
    /**
     * `getAttr` returns the attributes of this value.
     */
    getAttrs(): RHT;
    /**
     * `toString` returns the string representation of this value.
     */
    toString(): string;
    /**
     * `toJSON` returns the JSON encoding of this value.
     */
    toJSON(): string;
    /**
     * `getAttributes` returns the attributes of this value.
     */
    getAttributes(): Record<string, string>;
    /**
     * `getContent` returns the internal content.
     */
    getContent(): string;
}

/**
 * `CRDTTree` is a CRDT implementation of a tree.
 */
declare class CRDTTree extends CRDTGCElement {
    private indexTree;
    private nodeMapByID;
    private removedNodeMap;
    constructor(root: CRDTTreeNode, createdAt: TimeTicket);
    /**
     * `create` creates a new instance of `CRDTTree`.
     */
    static create(root: CRDTTreeNode, ticket: TimeTicket): CRDTTree;
    /**
     * `findFloorNode` finds node of given id.
     */
    findFloorNode(id: CRDTTreeNodeID): CRDTTreeNode | undefined;
    /**
     * `findNodesAndSplit` finds `TreePos` of the given `CRDTTreeNodeID` and
     * splits nodes for the given split level.
     *
     * The ids of the given `pos` are the ids of the node in the CRDT perspective.
     * This is different from `TreePos` which is a position of the tree in the
     * physical perspective.
     */
    findNodesAndSplit(pos: CRDTTreePos, editedAt: TimeTicket): [CRDTTreeNode, CRDTTreeNode];
    /**
     * `style` applies the given attributes of the given range.
     */
    style(range: [CRDTTreePos, CRDTTreePos], attributes: {
        [key: string]: string;
    } | undefined, editedAt: TimeTicket): TreeChange[];
    /**
     * `edit` edits the tree with the given range and content.
     * If the content is undefined, the range will be removed.
     */
    edit(range: [CRDTTreePos, CRDTTreePos], contents: Array<CRDTTreeNode> | undefined, editedAt: TimeTicket, latestCreatedAtMapByActor?: Map<string, TimeTicket>): [Array<TreeChange>, Map<string, TimeTicket>];
    /**
     * `editT` edits the given range with the given value.
     * This method uses indexes instead of a pair of TreePos for testing.
     */
    editT(range: [number, number], contents: Array<CRDTTreeNode> | undefined, editedAt: TimeTicket): void;
    /**
     * `move` move the given source range to the given target range.
     */
    move(target: [number, number], source: [number, number], ticket: TimeTicket): void;
    /**
     * `purgeRemovedNodesBefore` physically purges nodes that have been removed.
     */
    purgeRemovedNodesBefore(ticket: TimeTicket): number;
    /**
     * `purge` physically purges the given node from RGATreeSplit.
     */
    purge(node: CRDTTreeNode): void;
    /**
     * `findPos` finds the position of the given index in the tree.
     */
    findPos(index: number, preferText?: boolean): CRDTTreePos;
    /**
     * `getRemovedNodesLen` returns size of removed nodes.
     */
    getRemovedNodesLen(): number;
    /**
     * `pathToPosRange` converts the given path of the node to the range of the position.
     */
    pathToPosRange(path: Array<number>): [CRDTTreePos, CRDTTreePos];
    /**
     * `pathToPos` finds the position of the given index in the tree by path.
     */
    pathToPos(path: Array<number>): CRDTTreePos;
    /**
     * `getRoot` returns the root node of the tree.
     */
    getRoot(): CRDTTreeNode;
    /**
     * `getSize` returns the size of the tree.
     */
    getSize(): number;
    /**
     * `getIndexTree` returns the index tree.
     */
    getIndexTree(): IndexTree<CRDTTreeNode>;
    /**
     * toXML returns the XML encoding of this tree.
     */
    toXML(): string;
    /**
     * `toJSON` returns the JSON encoding of this tree.
     */
    toJSON(): string;
    /**
     * `toJSForTest` returns value with meta data for testing.
     */
    toJSForTest(): Devtools.JSONElement;
    /**
     * `getRootTreeNode` returns the converted value of this tree to TreeNode.
     */
    getRootTreeNode(): TreeNode;
    /**
     * `toTestTreeNode` returns the JSON of this tree for debugging.
     */
    toTestTreeNode(): TreeNodeForTest;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this tree.
     */
    toSortedJSON(): string;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTTree;
    /**
     * `toPath` converts the given CRDTTreeNodeID to the path of the tree.
     */
    toPath(parentNode: CRDTTreeNode, leftSiblingNode: CRDTTreeNode): Array<number>;
    /**
     * `toIndex` converts the given CRDTTreeNodeID to the index of the tree.
     */
    toIndex(parentNode: CRDTTreeNode, leftSiblingNode: CRDTTreeNode): number;
    /**
     * `indexToPath` converts the given tree index to path.
     */
    indexToPath(index: number): Array<number>;
    /**
     * `pathToIndex` converts the given path to index.
     */
    pathToIndex(path: Array<number>): number;
    /**
     * `indexRangeToPosRange` returns the position range from the given index range.
     */
    indexRangeToPosRange(range: [number, number]): TreePosRange;
    /**
     * `indexRangeToPosStructRange` converts the integer index range into the Tree position range structure.
     */
    indexRangeToPosStructRange(range: [number, number]): TreePosStructRange;
    /**
     * `posRangeToPathRange` converts the given position range to the path range.
     */
    posRangeToPathRange(range: TreePosRange, timeTicket: TimeTicket): [Array<number>, Array<number>];
    /**
     * `posRangeToIndexRange` converts the given position range to the path range.
     */
    posRangeToIndexRange(range: TreePosRange, timeTicket: TimeTicket): [number, number];
    /**
     * `traverseInPosRange` traverses the tree in the given position range.
     */
    private traverseInPosRange;
    /**
     * `toTreePos` converts the given nodes to the position of the IndexTree.
     */
    private toTreePos;
}

/**
 * `CRDTTreeNode` is a node of CRDTTree. It is includes the logical clock and
 * links to other nodes to resolve conflicts.
 */
declare class CRDTTreeNode extends IndexTreeNode<CRDTTreeNode> {
    id: CRDTTreeNodeID;
    removedAt?: TimeTicket;
    attrs?: RHT;
    /**
     * `insPrevID` is the previous node id of this node after the node is split.
     */
    insPrevID?: CRDTTreeNodeID;
    /**
     * `insNextID` is the previous node id of this node after the node is split.
     */
    insNextID?: CRDTTreeNodeID;
    _value: string;
    constructor(id: CRDTTreeNodeID, type: string, opts?: string | Array<CRDTTreeNode>, attributes?: RHT, removedAt?: TimeTicket);
    /**
     * `create` creates a new instance of CRDTTreeNode.
     */
    static create(id: CRDTTreeNodeID, type: string, opts?: string | Array<CRDTTreeNode>, attributes?: RHT): CRDTTreeNode;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTTreeNode;
    /**
     * `value` returns the value of the node.
     */
    get value(): string;
    /**
     * `value` sets the value of the node.
     */
    set value(v: string);
    /**
     * `isRemoved` returns whether the node is removed or not.
     */
    get isRemoved(): boolean;
    /**
     * `remove` marks the node as removed.
     */
    remove(removedAt: TimeTicket): void;
    /**
     * `clone` clones this node with the given offset.
     */
    clone(offset: number): CRDTTreeNode;
    /**
     * `getCreatedAt` returns the creation time of this element.
     */
    getCreatedAt(): TimeTicket;
    /**
     * `getOffset` returns the offset of a pos.
     */
    getOffset(): number;
    /**
     * `canDelete` checks if node is able to delete.
     */
    canDelete(editedAt: TimeTicket, latestCreatedAt: TimeTicket): boolean;
}

/**
 * `CRDTTreeNodeID` represent an ID of a node in the tree. It is used to
 * identify a node in the tree. It is composed of the creation time of the node
 * and the offset from the beginning of the node if the node is split.
 *
 * Some of replicas may have nodes that are not split yet. In this case, we can
 * use `map.floorEntry()` to find the adjacent node.
 */
declare class CRDTTreeNodeID {
    /**
     * `createdAt` is the creation time of the node.
     */
    private createdAt;
    /**
     * `offset` is the distance from the beginning of the node if the node is
     * split.
     */
    private offset;
    constructor(createdAt: TimeTicket, offset: number);
    /**
     * `of` creates a new instance of CRDTTreeNodeID.
     */
    static of(createdAt: TimeTicket, offset: number): CRDTTreeNodeID;
    /**
     * `fromStruct` creates a new instance of CRDTTreeNodeID from the given struct.
     */
    static fromStruct(struct: CRDTTreeNodeIDStruct): CRDTTreeNodeID;
    /**
     * `createComparator` creates a comparator for CRDTTreeNodeID.
     */
    static createComparator(): Comparator<CRDTTreeNodeID>;
    /**
     * `getCreatedAt` returns the creation time of the node.
     */
    getCreatedAt(): TimeTicket;
    /**
     * `equals` returns whether given ID equals to this ID or not.
     */
    equals(other: CRDTTreeNodeID): boolean;
    /**
     * `getOffset` returns returns the offset of the node.
     */
    getOffset(): number;
    /**
     * `setOffset` sets the offset of the node.
     */
    setOffset(offset: number): void;
    /**
     * `toStruct` returns the structure of this position.
     */
    toStruct(): CRDTTreeNodeIDStruct;
    /**
     * `toIDString` returns a string that can be used as an ID for this position.
     */
    toIDString(): string;
}

/**
 * `CRDTTreeNodeIDStruct` represents the structure of CRDTTreeNodeID.
 * It is used to serialize and deserialize the CRDTTreeNodeID.
 */
export declare type CRDTTreeNodeIDStruct = {
    createdAt: TimeTicketStruct;
    offset: number;
};

/**
 * `CRDTTreePos` represent a position in the tree. It is used to identify a
 * position in the tree. It is composed of the parent ID and the left sibling
 * ID. If there's no left sibling in parent's children, then left sibling is
 * parent.
 */
declare class CRDTTreePos {
    private parentID;
    private leftSiblingID;
    constructor(parentID: CRDTTreeNodeID, leftSiblingID: CRDTTreeNodeID);
    /**
     * `of` creates a new instance of CRDTTreePos.
     */
    static of(parentID: CRDTTreeNodeID, leftSiblingID: CRDTTreeNodeID): CRDTTreePos;
    /**
     * `fromTreePos` creates a new instance of CRDTTreePos from the given TreePos.
     */
    static fromTreePos(pos: TreePos<CRDTTreeNode>): CRDTTreePos;
    /**
     * `getParentID` returns the parent ID.
     */
    getParentID(): CRDTTreeNodeID;
    /**
     * `fromStruct` creates a new instance of CRDTTreeNodeID from the given struct.
     */
    static fromStruct(struct: CRDTTreePosStruct): CRDTTreePos;
    /**
     * `toStruct` returns the structure of this position.
     */
    toStruct(): CRDTTreePosStruct;
    /**
     * `toTreeNodes` converts the pos to parent and left sibling nodes.
     */
    toTreeNodes(tree: CRDTTree): [CRDTTreeNode, CRDTTreeNode];
    /**
     * `getLeftSiblingID` returns the left sibling ID.
     */
    getLeftSiblingID(): CRDTTreeNodeID;
    /**
     * `equals` returns whether the given pos equals to this or not.
     */
    equals(other: CRDTTreePos): boolean;
}

/**
 * `CRDTTreePosStruct` represents the structure of CRDTTreePos.
 */
declare type CRDTTreePosStruct = {
    parentID: CRDTTreeNodeIDStruct;
    leftSiblingID: CRDTTreeNodeIDStruct;
};

/**
 * `DecreasedDepthOf` represents the type of the decreased depth of the given depth.
 */
declare type DecreasedDepthOf<Depth extends number = 0> = Depth extends 10 ? 9 : Depth extends 9 ? 8 : Depth extends 8 ? 7 : Depth extends 7 ? 6 : Depth extends 6 ? 5 : Depth extends 5 ? 4 : Depth extends 4 ? 3 : Depth extends 3 ? 2 : Depth extends 2 ? 1 : Depth extends 1 ? 0 : -1;

/**
 * `DefaultTextType` is the default type of the text node.
 * It is used when the type of the text node is not specified.
 */
declare const DefaultTextType = "text";

declare namespace Devtools {
    export {
        Json,
        ContainerValue,
        ElementType,
        JSONElement_2 as JSONElement
    }
}

/**
 * `DocEvent` is an event that occurs in `Document`. It can be delivered
 * using `Document.subscribe()`.
 *
 * @public
 */
export declare type DocEvent<P extends Indexable = Indexable, T = OperationInfo> = SnapshotEvent | LocalChangeEvent<T> | RemoteChangeEvent<T> | InitializedEvent<P> | WatchedEvent<P> | UnwatchedEvent<P> | PresenceChangedEvent<P>;

/**
 * `DocEventType` represents the type of the event that occurs in `Document`.
 * @public
 */
export declare enum DocEventType {
    /**
     * snapshot event type
     */
    Snapshot = "snapshot",
    /**
     * local document change event type
     */
    LocalChange = "local-change",
    /**
     * remote document change event type
     */
    RemoteChange = "remote-change",
    /**
     * `Initialized` means that online clients have been loaded from the server.
     */
    Initialized = "initialized",
    /**
     * `Watched` means that the client has established a connection with the server,
     * enabling real-time synchronization.
     */
    Watched = "watched",
    /**
     * `Unwatched` means that the connection has been disconnected.
     */
    Unwatched = "unwatched",
    /**
     * `PresenceChanged` means that the presences of the client has updated.
     */
    PresenceChanged = "presence-changed"
}

/**
 * `Document` is a CRDT-based data type. We can represent the model
 * of the application and edit it even while offline.
 *
 * @public
 */
declare class Document_2<T, P extends Indexable = Indexable> {
    private key;
    private status;
    private opts;
    private changeID;
    private checkpoint;
    private localChanges;
    private root;
    private clone?;
    private eventStream;
    private eventStreamObserver;
    /**
     * `onlineClients` is a set of client IDs that are currently online.
     */
    private onlineClients;
    /**
     * `presences` is a map of client IDs to their presence information.
     */
    private presences;
    /**
     * `history` is exposed to the user to manage undo/redo operations.
     */
    history: {
        canUndo: () => boolean;
        canRedo: () => boolean;
        undo: () => void;
        redo: () => void;
    };
    /**
     * `internalHistory` is used to manage undo/redo operations internally.
     */
    internalHistory: History_2<P>;
    /**
     * `isUpdating` is whether the document is updating by updater or not. It is
     * used to prevent the updater from calling undo/redo.
     */
    private isUpdating;
    constructor(key: string, opts?: DocumentOptions);
    /**
     * `update` executes the given updater to update this document.
     */
    update(updater: (root: JSONObject<T>, presence: Presence<P>) => void, message?: string): void;
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     * The callback will be called when the document is changed.
     */
    subscribe(nextOrObserver: Observer<DocEvent> | NextFn<DocEvent>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     * The callback will be called when the clients watching the document
     * establishe or update its presence.
     */
    subscribe(type: 'presence', next: NextFn<DocEvent<P>>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     * The callback will be called when the current client establishes or updates its presence.
     */
    subscribe(type: 'my-presence', next: NextFn<DocEvent<P>>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     * The callback will be called when the client establishes or terminates a connection,
     * or updates its presence.
     */
    subscribe(type: 'others', next: NextFn<DocEvent<P>>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     * The callback will be called when the targetPath or any of its nested values change.
     */
    subscribe<TPath extends PathOf<T>, TOperationInfo extends OperationInfoOf<T, TPath>>(targetPath: TPath, next: NextFn<DocEvent<P, TOperationInfo>>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `publish` triggers an event in this document, which can be received by
     * callback functions from document.subscribe().
     */
    publish(event: DocEvent<P>): void;
    private isSameElementOrChildOf;
    /**
     * `applyChangePack` applies the given change pack into this document.
     * 1. Remove local changes applied to server.
     * 2. Update the checkpoint.
     * 3. Do Garbage collection.
     *
     * @param pack - change pack
     * @internal
     */
    applyChangePack(pack: ChangePack<P>): void;
    /**
     * `getCheckpoint` returns the checkpoint of this document.
     *
     * @internal
     */
    getCheckpoint(): Checkpoint;
    /**
     * `getChangeID` returns the change id of this document.
     *
     * @internal
     */
    getChangeID(): ChangeID;
    /**
     * `hasLocalChanges` returns whether this document has local changes or not.
     *
     * @internal
     */
    hasLocalChanges(): boolean;
    /**
     * `ensureClone` make a clone of root.
     *
     * @internal
     */
    ensureClone(): void;
    /**
     * `createChangePack` create change pack of the local changes to send to the
     * remote server.
     *
     * @internal
     */
    createChangePack(): ChangePack<P>;
    /**
     * `setActor` sets actor into this document. This is also applied in the local
     * changes the document has.
     *
     * @internal
     */
    setActor(actorID: ActorID): void;
    /**
     * `getKey` returns the key of this document.
     *
     * @internal
     */
    getKey(): string;
    /**
     * `setStatus` updates the status of this document.
     *
     * @internal
     */
    setStatus(status: DocumentStatus): void;
    /**
     * `getStatus` returns the status of this document.
     *
     * @internal
     */
    getStatus(): DocumentStatus;
    /**
     * `getClone` return clone object.
     *
     * @internal
     */
    getCloneRoot(): CRDTObject | undefined;
    /**
     * `getRoot` returns a new proxy of cloned root.
     */
    getRoot(): JSONObject<T>;
    /**
     * `getOpsForTest` returns the operations of this document for testing.
     */
    getOpsForTest(): Operation[][];
    /**
     * `garbageCollect` purges elements that were removed before the given time.
     *
     * @internal
     */
    garbageCollect(ticket: TimeTicket): number;
    /**
     * `getRootObject` returns root object.
     *
     * @internal
     */
    getRootObject(): CRDTObject;
    /**
     * `getGarbageLen` returns the length of elements should be purged.
     *
     * @internal
     */
    getGarbageLen(): number;
    /**
     * `getGarbageLenFromClone` returns the length of elements should be purged from clone.
     */
    getGarbageLenFromClone(): number;
    /**
     * `toJSON` returns the JSON encoding of this document.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this document.
     */
    toSortedJSON(): string;
    /**
     * `applySnapshot` applies the given snapshot into this document.
     */
    applySnapshot(serverSeq: Long_2, snapshot?: Uint8Array): void;
    /**
     * `applyChanges` applies the given changes into this document.
     */
    applyChanges(changes: Array<Change<P>>): void;
    /**
     * `getValueByPath` returns the JSONElement corresponding to the given path.
     */
    getValueByPath(path: string): JSONElement | undefined;
    /**
     * `setOnlineClients` sets the given online client set.
     *
     * @internal
     */
    setOnlineClients(onlineClients: Set<ActorID>): void;
    /**
     * `addOnlineClient` adds the given clientID into the online client set.
     *
     * @internal
     */
    addOnlineClient(clientID: ActorID): void;
    /**
     * `removeOnlineClient` removes the clientID from the online client set.
     *
     * @internal
     */
    removeOnlineClient(clientID: ActorID): void;
    /**
     * `hasPresence` returns whether the given clientID has a presence or not.
     *
     * @internal
     */
    hasPresence(clientID: ActorID): boolean;
    /**
     * `getMyPresence` returns the presence of the current client.
     */
    getMyPresence(): P;
    /**
     * `getPresence` returns the presence of the given clientID.
     */
    getPresence(clientID: ActorID): P | undefined;
    /**
     * `getPresenceForTest` returns the presence of the given clientID
     * regardless of whether the client is online or not.
     *
     * @internal
     */
    getPresenceForTest(clientID: ActorID): P | undefined;
    /**
     * `getPresences` returns the presences of online clients.
     */
    getPresences(): Array<{
        clientID: ActorID;
        presence: P;
    }>;
    /**
     * `canUndo` returns whether there are any operations to undo.
     */
    private canUndo;
    /**
     * `canRedo` returns whether there are any operations to redo.
     */
    private canRedo;
    /**
     * `undo` undoes the last operation executed by the current client.
     * It does not impact operations made by other clients.
     */
    private undo;
    /**
     * `redo` redoes the last operation executed by the current client.
     * It does not impact operations made by other clients.
     */
    private redo;
    /**
     * `getUndoStackForTest` returns the undo stack for test.
     */
    getUndoStackForTest(): Array<Array<HistoryOperation<P>>>;
    /**
     * `getRedoStackForTest` returns the redo stack for test.
     */
    getRedoStackForTest(): Array<Array<HistoryOperation<P>>>;
}
export { Document_2 as Document }

/**
 * `DocumentChangedEvent` is an event that occurs when document attached to
 * the client changes.
 *
 * @public
 */
export declare interface DocumentChangedEvent extends BaseClientEvent {
    /**
     * enum {@link ClientEventType}.DocumentChangedEvent
     */
    type: ClientEventType.DocumentChanged;
    /**
     * `DocumentChangedEvent` value
     */
    value: Array<string>;
}

/**
 * `DocumentOptions` are the options to create a new document.
 *
 * @public
 */
declare interface DocumentOptions {
    /**
     * `disableGC` disables garbage collection if true.
     */
    disableGC?: boolean;
}

/**
 * `DocumentStatus` represents the status of the document.
 * @public
 */
declare enum DocumentStatus {
    /**
     * Detached means that the document is not attached to the client.
     * The actor of the ticket is created without being assigned.
     */
    Detached = "detached",
    /**
     * Attached means that this document is attached to the client.
     * The actor of the ticket is created with being assigned by the client.
     */
    Attached = "attached",
    /**
     * Removed means that this document is removed. If the document is removed,
     * it cannot be edited.
     */
    Removed = "removed"
}

/**
 * `DocumentSyncedEvent` is an event that occurs when document
 * attached to the client are synced.
 *
 * @public
 */
export declare interface DocumentSyncedEvent extends BaseClientEvent {
    /**
     * `DocumentSyncedEvent` type
     * enum {@link ClientEventType}.DocumentSyncedEvent
     */
    type: ClientEventType.DocumentSynced;
    /**
     * `DocumentSyncedEvent` value
     */
    value: DocumentSyncResultType;
}

/**
 * `DocumentSyncResultType` represents the result of synchronizing the document
 *  with the server.
 * @public
 */
export declare enum DocumentSyncResultType {
    /**
     * type when Document synced successfully.
     */
    Synced = "synced",
    /**
     * type when Document sync failed.
     */
    SyncFailed = "sync-failed"
}

/**
 * `EditOpInfo` represents the information of the edit operation.
 */
export declare type EditOpInfo = {
    type: 'edit';
    from: number;
    to: number;
    path: string;
    value: {
        attributes: Indexable;
        content: string;
    };
};

/**
 * `ElementNode` represents an element node. It has an attributes and children.
 */
export declare type ElementNode<A extends Indexable = Indexable> = {
    type: TreeNodeType;
    attributes?: A;
    children: Array<TreeNode>;
};

/**
 * ElementRHT is a hashtable with logical clock(Replicated hashtable)
 *
 */
declare class ElementRHT {
    private nodeMapByKey;
    private nodeMapByCreatedAt;
    constructor();
    /**
     * `create` creates an instance of ElementRHT.
     */
    static create(): ElementRHT;
    /**
     * `set` sets the value of the given key.
     */
    set(key: string, value: CRDTElement, executedAt: TimeTicket): CRDTElement | undefined;
    /**
     * `delete` deletes the Element of the given key.
     */
    delete(createdAt: TimeTicket, executedAt: TimeTicket): CRDTElement;
    /**
     * `subPathOf` returns the sub path of the given element.
     */
    subPathOf(createdAt: TimeTicket): string | undefined;
    /**
     * `purge` physically purge child element.
     */
    purge(element: CRDTElement): void;
    /**
     * `deleteByKey` deletes the Element of the given key and removed time.
     */
    deleteByKey(key: string, removedAt: TimeTicket): CRDTElement | undefined;
    /**
     * `has` returns whether the element exists of the given key or not.
     */
    has(key: string): boolean;
    /**
     * `getByID` returns the node of the given createdAt.
     */
    getByID(createdAt: TimeTicket): ElementRHTNode | undefined;
    /**
     * `get` returns the node of the given key.
     */
    get(key: string): ElementRHTNode | undefined;
    [Symbol.iterator](): IterableIterator<ElementRHTNode>;
}

/**
 * `ElementRHTNode` is a node of ElementRHT.
 */
declare class ElementRHTNode {
    private strKey;
    private value;
    constructor(strKey: string, value: CRDTElement);
    /**
     * `of` creates a instance of ElementRHTNode.
     */
    static of(strKey: string, value: CRDTElement): ElementRHTNode;
    /**
     * `isRemoved` checks whether this value was removed.
     */
    isRemoved(): boolean;
    /**
     * `getStrKey` returns the key of this node.
     */
    getStrKey(): string;
    /**
     * `getValue` return the value(element) of this node
     */
    getValue(): CRDTElement;
    /**
     * `remove` removes a value base on removing time.
     */
    remove(removedAt: TimeTicket): boolean;
}

declare type ElementType = 'YORKIE_PRIMITIVE' | 'YORKIE_COUNTER' | 'YORKIE_OBJECT' | 'YORKIE_ARRAY' | 'YORKIE_TEXT' | 'YORKIE_TREE';

declare type ElementValue = PrimitiveValue | CounterValue | ContainerValue | Json;

export declare type ErrorFn = (error: Error) => void;

/**
 * `ExecutionResult` represents the result of operation execution.
 */
declare type ExecutionResult = {
    opInfos: Array<OperationInfo>;
    reverseOp?: Operation;
};

declare type Executor<T> = (observer: Observer<T>) => void;

/**
 * `fromChangePack` converts the given Protobuf format to model format.
 */
declare function fromChangePack<P extends Indexable>(pbPack: ChangePack_2): ChangePack<P>;

/**
 * `fromChanges` converts the given Protobuf format to model format.
 */
declare function fromChanges<P extends Indexable>(pbChanges: Array<Change_2>): Array<Change<P>>;

/**
 * `fromPresence` converts the given Protobuf format to model format.
 */
declare function fromPresence<P extends Indexable>(pbPresence: Presence_2): P;

/**
 * `History` is a class that stores the history of the document.
 */
declare class History_2<P extends Indexable> {
    private undoStack;
    private redoStack;
    /**
     * `hasUndo` returns true if there are undo operations.
     */
    hasUndo(): boolean;
    /**
     * `hasRedo` returns true if there are redo operations.
     */
    hasRedo(): boolean;
    /**
     * `pushUndo` pushes new undo operations of a change to undo stack.
     */
    pushUndo(undoOps: Array<HistoryOperation<P>>): void;
    /**
     * `popUndo` pops the last undo operations of a change from undo stack.
     */
    popUndo(): Array<HistoryOperation<P>> | undefined;
    /**
     * `pushRedo` pushes new redo operations of a change to redo stack.
     */
    pushRedo(redoOps: Array<HistoryOperation<P>>): void;
    /**
     * `popRedo` pops the last redo operations of a change from redo stack.
     */
    popRedo(): Array<HistoryOperation<P>> | undefined;
    /**
     * `clearRedo` flushes remaining redo operations.
     */
    clearRedo(): void;
    /**
     * `getUndoStackForTest` returns the undo stack for test.
     */
    getUndoStackForTest(): Array<Array<HistoryOperation<P>>>;
    /**
     * `getRedoStackForTest` returns the redo stack for test.
     */
    getRedoStackForTest(): Array<Array<HistoryOperation<P>>>;
}

/**
 * `HistoryOperation` is a type of history operation.
 */
declare type HistoryOperation<P extends Indexable> = Operation | {
    type: 'presence';
    value: Partial<P>;
};

/**
 * `IncreaseOpInfo` represents the information of the increase operation.
 */
export declare type IncreaseOpInfo = {
    type: 'increase';
    path: string;
    value: number;
};

/**
 * Indexable key, value
 * @public
 */
export declare type Indexable = Record<string, any>;

/**
 * `IndexTree` is a tree structure for linear indexing.
 */
declare class IndexTree<T extends IndexTreeNode<T>> {
    private root;
    constructor(root: T);
    /**
     * `nodeBetween` returns the nodes between the given range.
     */
    nodesBetween(from: number, to: number, callback: (node: T, contain: TagContained) => void): void;
    /**
     * `traverse` traverses the tree with postorder traversal.
     */
    traverse(callback: (node: T) => void): void;
    /**
     * `traverseAll` traverses the whole tree (include tombstones) with postorder traversal.
     */
    traverseAll(callback: (node: T) => void): void;
    /**
     * `split` splits the node at the given index.
     */
    split(index: number, depth?: number): TreePos<T>;
    /**
     * findTreePos finds the position of the given index in the tree.
     */
    findTreePos(index: number, preferText?: boolean): TreePos<T>;
    /**
     * `treePosToPath` returns path from given treePos
     */
    treePosToPath(treePos: TreePos<T>): number[];
    /**
     * `pathToIndex` returns index from given path
     */
    pathToIndex(path: Array<number>): number;
    /**
     * `pathToTreePos` returns treePos from given path
     */
    pathToTreePos(path: Array<number>): TreePos<T>;
    /**
     * `getRoot` returns the root node of the tree.
     */
    getRoot(): T;
    /**
     * `getSize` returns the size of the tree.
     */
    get size(): number;
    /**
     * `findPostorderRight` finds right node of the given tree position with
     *  postorder traversal.
     */
    findPostorderRight(treePos: TreePos<T>): T | undefined;
    /**
     * `indexOf` returns the index of the given tree position.
     */
    indexOf(pos: TreePos<T>): number;
    /**
     * `indexToPath` returns the path of the given index.
     */
    indexToPath(index: number): Array<number>;
}

/**
 * `IndexTreeNode` is the node of IndexTree. It is used to represent the
 * document of text-based editors.
 */
declare abstract class IndexTreeNode<T extends IndexTreeNode<T>> {
    type: TreeNodeType;
    parent?: T;
    _children: Array<T>;
    size: number;
    constructor(type: TreeNodeType, children?: Array<T>);
    /**
     * `updateAncestorsSize` updates the size of the ancestors.
     */
    updateAncestorsSize(): void;
    /**
     * `isText` returns true if the node is a text node.
     */
    get isText(): boolean;
    /**
     * `paddedSize` returns the size of the node including padding size.
     */
    get paddedSize(): number;
    /**
     * `isAncenstorOf` returns true if the node is an ancestor of the given node.
     */
    isAncestorOf(node: T): boolean;
    /**
     * `nextSibling` returns the next sibling of the node.
     */
    get nextSibling(): T | undefined;
    /**
     * `split` splits the node at the given offset.
     */
    split(offset: number, absOffset: number): T | undefined;
    /**
     * `isRemoved` returns true if the node is removed.
     */
    abstract get isRemoved(): boolean;
    /**
     * `clone` clones the node with the given id and value.
     */
    abstract clone(offset: number): T;
    /**
     * `value` returns the value of the node.
     */
    abstract get value(): string;
    /**
     * `value` sets the value of the node.
     */
    abstract set value(v: string);
    /**
     * `splitText` splits the given node at the given offset.
     */
    splitText(offset: number, absOffset: number): T | undefined;
    /**
     * `children` returns the children of the node.
     */
    get children(): Array<T>;
    /**
     * `allChildren` returns all the children of the node including tombstone nodes.
     * It returns the shallow copy of the children.
     */
    get allChildren(): Array<T>;
    /**
     * `hasTextChild` returns true if the node has an text child.
     */
    hasTextChild(): boolean;
    /**
     * `append` appends the given nodes to the children.
     */
    append(...newNode: Array<T>): void;
    /**
     * `prepend` prepends the given nodes to the children.
     */
    prepend(...newNode: Array<T>): void;
    /**
     * `insertBefore` inserts the given node before the given child.
     */
    insertBefore(newNode: T, referenceNode: T): void;
    /**
     * `insertAfter` inserts the given node after the given child.
     */
    insertAfter(newNode: T, referenceNode: T): void;
    /**
     * `insertAt` inserts the given node at the given offset.
     */
    insertAt(newNode: T, offset: number): void;
    /**
     * `removeChild` removes the given child.
     */
    removeChild(child: T): void;
    /**
     * `splitElement` splits the given element at the given offset.
     */
    splitElement(offset: number): T | undefined;
    /**
     * `insertAfterInternal` inserts the given node after the given child.
     * This method does not update the size of the ancestors.
     */
    insertAfterInternal(newNode: T, referenceNode: T): void;
    /**
     * `insertAtInternal` inserts the given node at the given index.
     * This method does not update the size of the ancestors.
     */
    insertAtInternal(newNode: T, offset: number): void;
    /**
     * findOffset returns the offset of the given node in the children.
     * It excludes the removed nodes.
     */
    findOffset(node: T): number;
    /**
     * `findBranchOffset` returns offset of the given descendant node in this node.
     * If the given node is not a descendant of this node, it returns -1.
     */
    findBranchOffset(node: T): number;
}

declare interface InitializedEvent<P extends Indexable> extends BaseDocEvent {
    type: DocEventType.Initialized;
    value: Array<{
        clientID: ActorID;
        presence: P;
    }>;
}

declare type Json = string | number | boolean | null | {
    [key: string]: Json;
} | Array<Json>;

/**
 * `JSONArray` represents JSON array, but unlike regular JSON, it has time
 * tickets created by a logical clock to resolve conflicts.
 */
export declare type JSONArray<T> = {
    /**
     * `getID` returns the ID, `TimeTicket` of this Object.
     */
    getID?(): TimeTicket;
    /**
     * `getElementByID` returns the element for the given ID.
     */
    getElementByID?(createdAt: TimeTicket): WrappedElement<T>;
    /**
     * `getElementByIndex` returns the element for the given index.
     */
    getElementByIndex?(index: number): WrappedElement<T>;
    /**
     * `getLast` returns the last element of this array.
     */
    getLast?(): WrappedElement<T>;
    /**
     * `deleteByID` deletes the element of the given ID.
     */
    deleteByID?(createdAt: TimeTicket): WrappedElement<T>;
    /**
     * `insertBefore` inserts a value before the given next element.
     */
    insertBefore?(nextID: TimeTicket, value: any): WrappedElement<T>;
    /**
     * `insertAfter` inserts a value after the given previous element.
     */
    insertAfter?(prevID: TimeTicket, value: any): WrappedElement<T>;
    /**
     * `moveBefore` moves the element before the given next element.
     */
    moveBefore?(nextID: TimeTicket, id: TimeTicket): void;
    /**
     * `moveAfter` moves the element after the given previous element.
     */
    moveAfter?(prevID: TimeTicket, id: TimeTicket): void;
    /**
     * `moveFront` moves the element before the first element.
     */
    moveFront?(id: TimeTicket): void;
    /**
     * `moveLast` moves the element after the last element.
     */
    moveLast?(id: TimeTicket): void;
    /**
     * `toTestString` returns a String containing the meta data of the node
     * for debugging purpose.
     */
    toTestString?(): string;
} & Array<T>;

/**
 * `JSONElement` is a wrapper for `CRDTElement` that provides users with an
 * easy-to-use interface for manipulating `Document`s.
 */
export declare type JSONElement<T = unknown, A extends Indexable = Indexable> = PrimitiveValue | JSONObject<T> | JSONArray<T> | Text_2<A> | Counter | Tree;

declare type JSONElement_2 = {
    id: string;
    key?: string;
    value: ElementValue;
    type: ElementType;
};

declare class JSONElementSimple extends jspb.Message {
    getCreatedAt(): TimeTicket_2 | undefined;
    setCreatedAt(value?: TimeTicket_2): JSONElementSimple;
    hasCreatedAt(): boolean;
    clearCreatedAt(): JSONElementSimple;

    getMovedAt(): TimeTicket_2 | undefined;
    setMovedAt(value?: TimeTicket_2): JSONElementSimple;
    hasMovedAt(): boolean;
    clearMovedAt(): JSONElementSimple;

    getRemovedAt(): TimeTicket_2 | undefined;
    setRemovedAt(value?: TimeTicket_2): JSONElementSimple;
    hasRemovedAt(): boolean;
    clearRemovedAt(): JSONElementSimple;

    getType(): ValueType;
    setType(value: ValueType): JSONElementSimple;

    getValue(): Uint8Array | string;
    getValue_asU8(): Uint8Array;
    getValue_asB64(): string;
    setValue(value: Uint8Array | string): JSONElementSimple;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): JSONElementSimple.AsObject;
    static toObject(includeInstance: boolean, msg: JSONElementSimple): JSONElementSimple.AsObject;
    static serializeBinaryToWriter(message: JSONElementSimple, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): JSONElementSimple;
    static deserializeBinaryFromReader(message: JSONElementSimple, reader: jspb.BinaryReader): JSONElementSimple;
}

declare namespace JSONElementSimple {
    type AsObject = {
        createdAt?: TimeTicket_2.AsObject,
        movedAt?: TimeTicket_2.AsObject,
        removedAt?: TimeTicket_2.AsObject,
        type: ValueType,
        value: Uint8Array | string,
    }
}

/**
 * `JSONObject` represents a JSON object, but unlike regular JSON, it has time
 * tickets created by a logical clock to resolve conflicts.
 */
export declare type JSONObject<T> = {
    /**
     * `getID` returns the ID(time ticket) of this Object.
     */
    getID?(): TimeTicket;
    /**
     * `toJSON` returns the JSON encoding of this object.
     */
    toJSON?(): string;
    /**
     * `toJS` returns the JSON object of this object.
     */
    toJS?(): T;
} & T;

/**
 * `LeafElement` is a leaf element of JSONElement.
 */
declare type LeafElement = PrimitiveValue | Primitive | Text_2 | Counter | Tree;

/**
 * `LocalChangeEvent` is an event that occurs when the document is changed
 * by local changes.
 *
 * @public
 */
export declare interface LocalChangeEvent<T = OperationInfo> extends BaseDocEvent {
    /**
     * enum {@link DocEventType}.LocalChange
     */
    type: DocEventType.LocalChange;
    /**
     * LocalChangeEvent type
     */
    value: ChangeInfo<T>;
}

/**
 * `MoveOpInfo` represents the information of the move operation.
 */
export declare type MoveOpInfo = {
    type: 'move';
    path: string;
    previousIndex: number;
    index: number;
};

export declare type NextFn<T> = (value: T) => void;

declare class NodeAttr extends jspb.Message {
    getValue(): string;
    setValue(value: string): NodeAttr;

    getUpdatedAt(): TimeTicket_2 | undefined;
    setUpdatedAt(value?: TimeTicket_2): NodeAttr;
    hasUpdatedAt(): boolean;
    clearUpdatedAt(): NodeAttr;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): NodeAttr.AsObject;
    static toObject(includeInstance: boolean, msg: NodeAttr): NodeAttr.AsObject;
    static serializeBinaryToWriter(message: NodeAttr, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): NodeAttr;
    static deserializeBinaryFromReader(message: NodeAttr, reader: jspb.BinaryReader): NodeAttr;
}

declare namespace NodeAttr {
    type AsObject = {
        value: string,
        updatedAt?: TimeTicket_2.AsObject,
    }
}

/**
 * `ObjectOperationInfo` represents the OperationInfo for the JSONObject.
 */
export declare type ObjectOperationInfo = SetOpInfo | RemoveOpInfo;

/**
 * `objectToBytes` converts the given JSONObject to byte array.
 */
declare function objectToBytes(obj: CRDTObject): Uint8Array;

export declare interface Observable<T> {
    subscribe: SubscribeFn<T>;
    getProxy?: () => ObserverProxy<T>;
}

export declare interface Observer<T> {
    next: NextFn<T>;
    error?: ErrorFn;
    complete?: CompleteFn;
}

/**
 * `ObserverProxy` is proxy of `Observer`.
 */
declare class ObserverProxy<T> implements Observer<T> {
    finalized: boolean;
    private observers;
    private finalError?;
    constructor(executor: Executor<T>);
    /**
     * `next` iterates next observer synchronously.
     */
    next(value: T): void;
    /**
     * `error` invoke error.
     */
    error(error: Error): void;
    /**
     * `complete` completes observer.
     */
    complete(): void;
    /**
     * `subscribe` is a function for subscribing observer.
     */
    subscribe(nextOrObserver: Observer<T> | NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    private unsubscribeOne;
    private forEachObserver;
    private sendOne;
    private close;
}

/**
 * `Operation` represents an operation to be executed on a document.
 */
declare abstract class Operation {
    private parentCreatedAt;
    private executedAt?;
    constructor(parentCreatedAt: TimeTicket, executedAt?: TimeTicket);
    /**
     * `getParentCreatedAt` returns the creation time of the target element to
     * execute the operation.
     */
    getParentCreatedAt(): TimeTicket;
    /**
     * `getExecutedAt` returns execution time of this operation.
     */
    getExecutedAt(): TimeTicket;
    /**
     * `setActor` sets the given actor to this operation.
     */
    setActor(actorID: ActorID): void;
    /**
     * `setExecutedAt` sets the executedAt.
     */
    setExecutedAt(executedAt: TimeTicket): void;
    /**
     * `getEffectedCreatedAt` returns the creation time of the effected element.
     */
    abstract getEffectedCreatedAt(): TimeTicket;
    /**
     * `toTestString` returns a string containing the meta data for debugging purpose.
     */
    abstract toTestString(): string;
    /**
     * `execute` executes this operation on the given `CRDTRoot`.
     */
    abstract execute(root: CRDTRoot, source: OpSource): ExecutionResult | undefined;
}

declare class Operation_2 extends jspb.Message {
    getSet(): Operation_2.Set | undefined;
    setSet(value?: Operation_2.Set): Operation_2;
    hasSet(): boolean;
    clearSet(): Operation_2;

    getAdd(): Operation_2.Add | undefined;
    setAdd(value?: Operation_2.Add): Operation_2;
    hasAdd(): boolean;
    clearAdd(): Operation_2;

    getMove(): Operation_2.Move | undefined;
    setMove(value?: Operation_2.Move): Operation_2;
    hasMove(): boolean;
    clearMove(): Operation_2;

    getRemove(): Operation_2.Remove | undefined;
    setRemove(value?: Operation_2.Remove): Operation_2;
    hasRemove(): boolean;
    clearRemove(): Operation_2;

    getEdit(): Operation_2.Edit | undefined;
    setEdit(value?: Operation_2.Edit): Operation_2;
    hasEdit(): boolean;
    clearEdit(): Operation_2;

    getSelect(): Operation_2.Select | undefined;
    setSelect(value?: Operation_2.Select): Operation_2;
    hasSelect(): boolean;
    clearSelect(): Operation_2;

    getStyle(): Operation_2.Style | undefined;
    setStyle(value?: Operation_2.Style): Operation_2;
    hasStyle(): boolean;
    clearStyle(): Operation_2;

    getIncrease(): Operation_2.Increase | undefined;
    setIncrease(value?: Operation_2.Increase): Operation_2;
    hasIncrease(): boolean;
    clearIncrease(): Operation_2;

    getTreeEdit(): Operation_2.TreeEdit | undefined;
    setTreeEdit(value?: Operation_2.TreeEdit): Operation_2;
    hasTreeEdit(): boolean;
    clearTreeEdit(): Operation_2;

    getTreeStyle(): Operation_2.TreeStyle | undefined;
    setTreeStyle(value?: Operation_2.TreeStyle): Operation_2;
    hasTreeStyle(): boolean;
    clearTreeStyle(): Operation_2;

    getBodyCase(): Operation_2.BodyCase;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Operation_2.AsObject;
    static toObject(includeInstance: boolean, msg: Operation_2): Operation_2.AsObject;
    static serializeBinaryToWriter(message: Operation_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Operation_2;
    static deserializeBinaryFromReader(message: Operation_2, reader: jspb.BinaryReader): Operation_2;
}

declare namespace Operation_2 {
    type AsObject = {
        set?: Operation_2.Set.AsObject,
        add?: Operation_2.Add.AsObject,
        move?: Operation_2.Move.AsObject,
        remove?: Operation_2.Remove.AsObject,
        edit?: Operation_2.Edit.AsObject,
        select?: Operation_2.Select.AsObject,
        style?: Operation_2.Style.AsObject,
        increase?: Operation_2.Increase.AsObject,
        treeEdit?: Operation_2.TreeEdit.AsObject,
        treeStyle?: Operation_2.TreeStyle.AsObject,
    }

    class Set extends jspb.Message {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): Set;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): Set;

        getKey(): string;
        setKey(value: string): Set;

        getValue(): JSONElementSimple | undefined;
        setValue(value?: JSONElementSimple): Set;
        hasValue(): boolean;
        clearValue(): Set;

        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): Set;
        hasExecutedAt(): boolean;
        clearExecutedAt(): Set;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Set.AsObject;
        static toObject(includeInstance: boolean, msg: Set): Set.AsObject;
        static serializeBinaryToWriter(message: Set, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Set;
        static deserializeBinaryFromReader(message: Set, reader: jspb.BinaryReader): Set;
    }

    namespace Set {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject,
            key: string,
            value?: JSONElementSimple.AsObject,
            executedAt?: TimeTicket_2.AsObject,
        }
    }


    class Add extends jspb.Message {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): Add;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): Add;

        getPrevCreatedAt(): TimeTicket_2 | undefined;
        setPrevCreatedAt(value?: TimeTicket_2): Add;
        hasPrevCreatedAt(): boolean;
        clearPrevCreatedAt(): Add;

        getValue(): JSONElementSimple | undefined;
        setValue(value?: JSONElementSimple): Add;
        hasValue(): boolean;
        clearValue(): Add;

        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): Add;
        hasExecutedAt(): boolean;
        clearExecutedAt(): Add;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Add.AsObject;
        static toObject(includeInstance: boolean, msg: Add): Add.AsObject;
        static serializeBinaryToWriter(message: Add, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Add;
        static deserializeBinaryFromReader(message: Add, reader: jspb.BinaryReader): Add;
    }

    namespace Add {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject,
            prevCreatedAt?: TimeTicket_2.AsObject,
            value?: JSONElementSimple.AsObject,
            executedAt?: TimeTicket_2.AsObject,
        }
    }


    class Move extends jspb.Message {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): Move;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): Move;

        getPrevCreatedAt(): TimeTicket_2 | undefined;
        setPrevCreatedAt(value?: TimeTicket_2): Move;
        hasPrevCreatedAt(): boolean;
        clearPrevCreatedAt(): Move;

        getCreatedAt(): TimeTicket_2 | undefined;
        setCreatedAt(value?: TimeTicket_2): Move;
        hasCreatedAt(): boolean;
        clearCreatedAt(): Move;

        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): Move;
        hasExecutedAt(): boolean;
        clearExecutedAt(): Move;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Move.AsObject;
        static toObject(includeInstance: boolean, msg: Move): Move.AsObject;
        static serializeBinaryToWriter(message: Move, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Move;
        static deserializeBinaryFromReader(message: Move, reader: jspb.BinaryReader): Move;
    }

    namespace Move {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject,
            prevCreatedAt?: TimeTicket_2.AsObject,
            createdAt?: TimeTicket_2.AsObject,
            executedAt?: TimeTicket_2.AsObject,
        }
    }


    class Remove extends jspb.Message {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): Remove;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): Remove;

        getCreatedAt(): TimeTicket_2 | undefined;
        setCreatedAt(value?: TimeTicket_2): Remove;
        hasCreatedAt(): boolean;
        clearCreatedAt(): Remove;

        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): Remove;
        hasExecutedAt(): boolean;
        clearExecutedAt(): Remove;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Remove.AsObject;
        static toObject(includeInstance: boolean, msg: Remove): Remove.AsObject;
        static serializeBinaryToWriter(message: Remove, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Remove;
        static deserializeBinaryFromReader(message: Remove, reader: jspb.BinaryReader): Remove;
    }

    namespace Remove {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject,
            createdAt?: TimeTicket_2.AsObject,
            executedAt?: TimeTicket_2.AsObject,
        }
    }


    class Edit extends jspb.Message {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): Edit;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): Edit;

        getFrom(): TextNodePos | undefined;
        setFrom(value?: TextNodePos): Edit;
        hasFrom(): boolean;
        clearFrom(): Edit;

        getTo(): TextNodePos | undefined;
        setTo(value?: TextNodePos): Edit;
        hasTo(): boolean;
        clearTo(): Edit;

        getCreatedAtMapByActorMap(): jspb.Map<string, TimeTicket_2>;
        clearCreatedAtMapByActorMap(): Edit;

        getContent(): string;
        setContent(value: string): Edit;

        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): Edit;
        hasExecutedAt(): boolean;
        clearExecutedAt(): Edit;

        getAttributesMap(): jspb.Map<string, string>;
        clearAttributesMap(): Edit;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Edit.AsObject;
        static toObject(includeInstance: boolean, msg: Edit): Edit.AsObject;
        static serializeBinaryToWriter(message: Edit, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Edit;
        static deserializeBinaryFromReader(message: Edit, reader: jspb.BinaryReader): Edit;
    }

    namespace Edit {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject,
            from?: TextNodePos.AsObject,
            to?: TextNodePos.AsObject,
            createdAtMapByActorMap: Array<[string, TimeTicket_2.AsObject]>,
            content: string,
            executedAt?: TimeTicket_2.AsObject,
            attributesMap: Array<[string, string]>,
        }
    }


    class Select extends jspb.Message {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): Select;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): Select;

        getFrom(): TextNodePos | undefined;
        setFrom(value?: TextNodePos): Select;
        hasFrom(): boolean;
        clearFrom(): Select;

        getTo(): TextNodePos | undefined;
        setTo(value?: TextNodePos): Select;
        hasTo(): boolean;
        clearTo(): Select;

        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): Select;
        hasExecutedAt(): boolean;
        clearExecutedAt(): Select;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Select.AsObject;
        static toObject(includeInstance: boolean, msg: Select): Select.AsObject;
        static serializeBinaryToWriter(message: Select, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Select;
        static deserializeBinaryFromReader(message: Select, reader: jspb.BinaryReader): Select;
    }

    namespace Select {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject,
            from?: TextNodePos.AsObject,
            to?: TextNodePos.AsObject,
            executedAt?: TimeTicket_2.AsObject,
        }
    }


    class Style extends jspb.Message {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): Style;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): Style;

        getFrom(): TextNodePos | undefined;
        setFrom(value?: TextNodePos): Style;
        hasFrom(): boolean;
        clearFrom(): Style;

        getTo(): TextNodePos | undefined;
        setTo(value?: TextNodePos): Style;
        hasTo(): boolean;
        clearTo(): Style;

        getAttributesMap(): jspb.Map<string, string>;
        clearAttributesMap(): Style;

        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): Style;
        hasExecutedAt(): boolean;
        clearExecutedAt(): Style;

        getCreatedAtMapByActorMap(): jspb.Map<string, TimeTicket_2>;
        clearCreatedAtMapByActorMap(): Style;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Style.AsObject;
        static toObject(includeInstance: boolean, msg: Style): Style.AsObject;
        static serializeBinaryToWriter(message: Style, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Style;
        static deserializeBinaryFromReader(message: Style, reader: jspb.BinaryReader): Style;
    }

    namespace Style {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject,
            from?: TextNodePos.AsObject,
            to?: TextNodePos.AsObject,
            attributesMap: Array<[string, string]>,
            executedAt?: TimeTicket_2.AsObject,
            createdAtMapByActorMap: Array<[string, TimeTicket_2.AsObject]>,
        }
    }


    class Increase extends jspb.Message {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): Increase;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): Increase;

        getValue(): JSONElementSimple | undefined;
        setValue(value?: JSONElementSimple): Increase;
        hasValue(): boolean;
        clearValue(): Increase;

        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): Increase;
        hasExecutedAt(): boolean;
        clearExecutedAt(): Increase;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Increase.AsObject;
        static toObject(includeInstance: boolean, msg: Increase): Increase.AsObject;
        static serializeBinaryToWriter(message: Increase, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Increase;
        static deserializeBinaryFromReader(message: Increase, reader: jspb.BinaryReader): Increase;
    }

    namespace Increase {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject,
            value?: JSONElementSimple.AsObject,
            executedAt?: TimeTicket_2.AsObject,
        }
    }


    class TreeEdit extends jspb.Message {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): TreeEdit;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): TreeEdit;

        getFrom(): TreePos_2 | undefined;
        setFrom(value?: TreePos_2): TreeEdit;
        hasFrom(): boolean;
        clearFrom(): TreeEdit;

        getTo(): TreePos_2 | undefined;
        setTo(value?: TreePos_2): TreeEdit;
        hasTo(): boolean;
        clearTo(): TreeEdit;

        getCreatedAtMapByActorMap(): jspb.Map<string, TimeTicket_2>;
        clearCreatedAtMapByActorMap(): TreeEdit;

        getContentsList(): Array<TreeNodes>;
        setContentsList(value: Array<TreeNodes>): TreeEdit;
        clearContentsList(): TreeEdit;
        addContents(value?: TreeNodes, index?: number): TreeNodes;

        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): TreeEdit;
        hasExecutedAt(): boolean;
        clearExecutedAt(): TreeEdit;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): TreeEdit.AsObject;
        static toObject(includeInstance: boolean, msg: TreeEdit): TreeEdit.AsObject;
        static serializeBinaryToWriter(message: TreeEdit, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): TreeEdit;
        static deserializeBinaryFromReader(message: TreeEdit, reader: jspb.BinaryReader): TreeEdit;
    }

    namespace TreeEdit {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject,
            from?: TreePos_2.AsObject,
            to?: TreePos_2.AsObject,
            createdAtMapByActorMap: Array<[string, TimeTicket_2.AsObject]>,
            contentsList: Array<TreeNodes.AsObject>,
            executedAt?: TimeTicket_2.AsObject,
        }
    }


    class TreeStyle extends jspb.Message {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): TreeStyle;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): TreeStyle;

        getFrom(): TreePos_2 | undefined;
        setFrom(value?: TreePos_2): TreeStyle;
        hasFrom(): boolean;
        clearFrom(): TreeStyle;

        getTo(): TreePos_2 | undefined;
        setTo(value?: TreePos_2): TreeStyle;
        hasTo(): boolean;
        clearTo(): TreeStyle;

        getAttributesMap(): jspb.Map<string, string>;
        clearAttributesMap(): TreeStyle;

        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): TreeStyle;
        hasExecutedAt(): boolean;
        clearExecutedAt(): TreeStyle;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): TreeStyle.AsObject;
        static toObject(includeInstance: boolean, msg: TreeStyle): TreeStyle.AsObject;
        static serializeBinaryToWriter(message: TreeStyle, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): TreeStyle;
        static deserializeBinaryFromReader(message: TreeStyle, reader: jspb.BinaryReader): TreeStyle;
    }

    namespace TreeStyle {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject,
            from?: TreePos_2.AsObject,
            to?: TreePos_2.AsObject,
            attributesMap: Array<[string, string]>,
            executedAt?: TimeTicket_2.AsObject,
        }
    }


    enum BodyCase { 
        BODY_NOT_SET = 0,
        SET = 1,
        ADD = 2,
        MOVE = 3,
        REMOVE = 4,
        EDIT = 5,
        SELECT = 6,
        STYLE = 7,
        INCREASE = 8,
        TREE_EDIT = 9,
        TREE_STYLE = 10,
    }
}

/**
 * `OperationInfo` represents the information of an operation.
 * It is used to inform to the user what kind of operation was executed.
 */
export declare type OperationInfo = TextOperationInfo | CounterOperationInfo | ArrayOperationInfo | ObjectOperationInfo | TreeOperationInfo;

/**
 * `OperationInfoOf` represents the type of the operation info of the given
 * path in the Document.subscribe. It is used to remove the `$.` prefix.
 */
declare type OperationInfoOf<TDocument, TKey extends string = '', TDepth extends number = 10> = TKey extends `$.${infer TPath}` ? OperationInfoOfInternal<TDocument, TPath, TDepth> : OperationInfoOfInternal<TDocument, TKey, TDepth>;

/**
 * `OperationInfoOfElement` represents the type of the operation info of the given element.
 */
declare type OperationInfoOfElement<TElement> = TElement extends Text_2 ? TextOperationInfo : TElement extends Counter ? CounterOperationInfo : TElement extends Tree ? TreeOperationInfo : TElement extends BaseArray<any> ? ArrayOperationInfo : TElement extends BaseObject<any> ? ObjectOperationInfo : OperationInfo;

/**
 * `OperationInfoOfInternal` represents the type of the operation info of the
 * given path in the Document.subscribe.
 *
 * TODO(easylogic): If the parent is optional, children cannot be inferred.
 * TODO(easylogic): Currently, the below cases of Document.subscribe are confused.
 * ```
 *  type DocType = { obj: { key: string }, text: Text }
 *  $.obj.text ->> obj's operations
 *  $.text ->> text's operations
 * ```
 */
declare type OperationInfoOfInternal<TElement, TKeyOrPath, TDepth extends number = 0> = TDepth extends 0 ? TElement : TKeyOrPath extends `${infer TFirst}.${infer TRest}` ? TFirst extends keyof TElement ? TElement[TFirst] extends BaseArray<unknown> ? OperationInfoOfInternal<TElement[TFirst], number, DecreasedDepthOf<TDepth>> : OperationInfoOfInternal<TElement[TFirst], TRest, DecreasedDepthOf<TDepth>> : OperationInfo : TKeyOrPath extends keyof TElement ? TElement[TKeyOrPath] extends BaseArray<unknown> ? ArrayOperationInfo : OperationInfoOfElement<TElement[TKeyOrPath]> : OperationInfo;

/**
 * `OpSource` represents the source of the operation. It is used to handle
 * corner cases in the operations created by undo/redo allow the removed
 * elements when executing them.
 */
declare enum OpSource {
    Local = "local",
    Remote = "remote",
    UndoRedo = "undoredo"
}

/**
 * `PathOf` represents the type of the all possible paths in the Document.subscribe.
 */
declare type PathOf<TDocument, Depth extends number = 10> = PathOfInternal<TDocument, '$.', Depth>;

/**
 * `PathOfInternal` represents the type of the path of the given element.
 */
declare type PathOfInternal<TElement, Prefix extends string = '', Depth extends number = 0> = Depth extends 0 ? Prefix : TElement extends Record<string, any> ? {
    [TKey in keyof TElement]: TElement[TKey] extends LeafElement ? `${Prefix}${TKey & string}` : TElement[TKey] extends BaseArray<infer TArrayElement> ? `${Prefix}${TKey & string}` | `${Prefix}${TKey & string}.${number}` | PathOfInternal<TArrayElement, `${Prefix}${TKey & string}.${number}.`, DecreasedDepthOf<Depth>> : `${Prefix}${TKey & string}` | PathOfInternal<TElement[TKey], `${Prefix}${TKey & string}.`, DecreasedDepthOf<Depth>>;
}[keyof TElement] : Prefix extends `${infer TRest}.` ? TRest : Prefix;

/**
 * `Presence` represents a proxy for the Presence to be manipulated from the outside.
 */
declare class Presence<P extends Indexable> {
    private context;
    private presence;
    constructor(changeContext: ChangeContext, presence: P);
    /**
     * `set` updates the presence based on the partial presence.
     */
    set(presence: Partial<P>, option?: {
        addToHistory: boolean;
    }): void;
    /**
     * `get` returns the presence value of the given key.
     */
    get<K extends keyof P>(key: K): P[K];
    /**
     * `clear` clears the presence.
     * @internal
     */
    clear(): void;
}

declare class Presence_2 extends jspb.Message {
    getDataMap(): jspb.Map<string, string>;
    clearDataMap(): Presence_2;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Presence_2.AsObject;
    static toObject(includeInstance: boolean, msg: Presence_2): Presence_2.AsObject;
    static serializeBinaryToWriter(message: Presence_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Presence_2;
    static deserializeBinaryFromReader(message: Presence_2, reader: jspb.BinaryReader): Presence_2;
}

declare namespace Presence_2 {
    type AsObject = {
        dataMap: Array<[string, string]>,
    }
}

/**
 * `PresenceChange` represents the change of presence.
 */
declare type PresenceChange<P extends Indexable> = {
    type: PresenceChangeType.Put;
    presence: P;
} | {
    type: PresenceChangeType.Clear;
};

declare class PresenceChange_2 extends jspb.Message {
    getType(): PresenceChange_2.ChangeType;
    setType(value: PresenceChange_2.ChangeType): PresenceChange_2;

    getPresence(): Presence_2 | undefined;
    setPresence(value?: Presence_2): PresenceChange_2;
    hasPresence(): boolean;
    clearPresence(): PresenceChange_2;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): PresenceChange_2.AsObject;
    static toObject(includeInstance: boolean, msg: PresenceChange_2): PresenceChange_2.AsObject;
    static serializeBinaryToWriter(message: PresenceChange_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): PresenceChange_2;
    static deserializeBinaryFromReader(message: PresenceChange_2, reader: jspb.BinaryReader): PresenceChange_2;
}

declare namespace PresenceChange_2 {
    type AsObject = {
        type: PresenceChange_2.ChangeType,
        presence?: Presence_2.AsObject,
    }

    enum ChangeType { 
        CHANGE_TYPE_UNSPECIFIED = 0,
        CHANGE_TYPE_PUT = 1,
        CHANGE_TYPE_DELETE = 2,
        CHANGE_TYPE_CLEAR = 3,
    }
}

declare interface PresenceChangedEvent<P extends Indexable> extends BaseDocEvent {
    type: DocEventType.PresenceChanged;
    value: {
        clientID: ActorID;
        presence: P;
    };
}

/**
 * `PresenceChangeType` represents the type of presence change.
 */
declare enum PresenceChangeType {
    Put = "put",
    Clear = "clear"
}

/**
 * `Primitive` represents primitive data type including logical clock.
 * It has a type and a value.
 */
export declare class Primitive extends CRDTElement {
    private valueType;
    private value;
    constructor(value: PrimitiveValue, createdAt: TimeTicket);
    /**
     * `of` creates a new instance of Primitive.
     */
    static of(value: PrimitiveValue, createdAt: TimeTicket): Primitive;
    /**
     * `valueFromBytes` parses the given bytes into value.
     */
    static valueFromBytes(primitiveType: PrimitiveType, bytes: Uint8Array): PrimitiveValue;
    /**
     * `toJSON` returns the JSON encoding of the value.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of the value.
     */
    toSortedJSON(): string;
    /**
     * `toJSForTest` returns value with meta data for testing.
     */
    toJSForTest(): Devtools.JSONElement;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): Primitive;
    /**
     * `getType` returns the type of the value.
     */
    getType(): PrimitiveType;
    /**
     * `getPrimitiveType` returns the primitive type of the value.
     */
    static getPrimitiveType(value: unknown): PrimitiveType | undefined;
    /**
     * `isSupport` check if the given value is supported type.
     */
    static isSupport(value: unknown): boolean;
    /**
     * `isInteger` checks if the given number is integer.
     */
    static isInteger(num: number): boolean;
    /**
     * `isNumericType` checks numeric type by JSONPrimitive
     */
    isNumericType(): boolean;
    /**
     * `getValue` returns the value of Primitive.
     */
    getValue(): PrimitiveValue;
    /**
     * `toBytes` creates an array representing the value.
     */
    toBytes(): Uint8Array;
}

declare enum PrimitiveType {
    Null = 0,
    Boolean = 1,
    Integer = 2,
    Long = 3,
    Double = 4,
    String = 5,
    Bytes = 6,
    Date = 7
}

/**
 * `PrimitiveValue` represents a value of primitive type. Only values of type
 * included in `PrimitiveValue` can be set to the document.
 */
export declare type PrimitiveValue = null | boolean | number | Long_2 | string | Uint8Array | Date;

/**
 * `RemoteChangeEvent` is an event that occurs when the document is changed
 * by remote changes.
 *
 * @public
 */
export declare interface RemoteChangeEvent<T = OperationInfo> extends BaseDocEvent {
    /**
     * enum {@link DocEventType}.RemoteChange
     */
    type: DocEventType.RemoteChange;
    /**
     * RemoteChangeEvent type
     */
    value: ChangeInfo<T>;
}

/**
 * `RemoveOpInfo` represents the information of the remove operation.
 */
export declare type RemoveOpInfo = {
    type: 'remove';
    path: string;
    key?: string;
    index?: number;
};

/**
 * `RGATreeSplit` is a block-based list with improved index-based lookup in RGA.
 * The difference from RGATreeList is that it has data on a block basis to
 * reduce the size of CRDT metadata. When an edit occurs on a block,
 * the block is split.
 *
 */
declare class RGATreeSplit<T extends RGATreeSplitValue> {
    private head;
    private treeByIndex;
    private treeByID;
    private removedNodeMap;
    constructor();
    /**
     * `create` creates a instance RGATreeSplit.
     */
    static create<T extends RGATreeSplitValue>(): RGATreeSplit<T>;
    /**
     * `edit` does following steps
     * 1. split nodes with from and to
     * 2. delete between from and to
     * 3. insert a new node
     * 4. add removed node
     * @param range - range of RGATreeSplitNode
     * @param editedAt - edited time
     * @param value - value
     * @param latestCreatedAtMapByActor - latestCreatedAtMapByActor
     * @returns `[RGATreeSplitPos, Map<string, TimeTicket>, Array<Change>]`
     */
    edit(range: RGATreeSplitPosRange, editedAt: TimeTicket, value?: T, latestCreatedAtMapByActor?: Map<string, TimeTicket>): [RGATreeSplitPos, Map<string, TimeTicket>, Array<ValueChange<T>>];
    /**
     * `indexToPos` finds RGATreeSplitPos of given offset.
     */
    indexToPos(idx: number): RGATreeSplitPos;
    /**
     * `findIndexesFromRange` finds indexes based on range.
     */
    findIndexesFromRange(range: RGATreeSplitPosRange): [number, number];
    /**
     * `posToIndex` converts the given position to index.
     */
    posToIndex(pos: RGATreeSplitPos, preferToLeft: boolean): number;
    /**
     * `findNode` finds node of given id.
     */
    findNode(id: RGATreeSplitNodeID): RGATreeSplitNode<T>;
    /**
     * `length` returns size of RGATreeSplit.
     */
    get length(): number;
    /**
     * `checkWeight` returns false when there is an incorrect weight node.
     * for debugging purpose.
     */
    checkWeight(): boolean;
    /**
     * `toString` returns the string encoding of this RGATreeSplit.
     */
    toString(): string;
    [Symbol.iterator](): IterableIterator<RGATreeSplitNode<T>>;
    /**
     * `getHead` returns head of RGATreeSplitNode.
     */
    getHead(): RGATreeSplitNode<T>;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): RGATreeSplit<T>;
    /**
     * `toTestString` returns a String containing the meta data of the node
     * for debugging purpose.
     */
    toTestString(): string;
    /**
     * `insertAfter` inserts the given node after the given previous node.
     */
    insertAfter(prevNode: RGATreeSplitNode<T>, newNode: RGATreeSplitNode<T>): RGATreeSplitNode<T>;
    /**
     * `findNodeWithSplit` splits and return nodes of the given position.
     */
    findNodeWithSplit(pos: RGATreeSplitPos, editedAt: TimeTicket): [RGATreeSplitNode<T>, RGATreeSplitNode<T>];
    private findFloorNodePreferToLeft;
    private findFloorNode;
    /**
     * `findBetween` returns nodes between fromNode and toNode.
     */
    findBetween(fromNode: RGATreeSplitNode<T>, toNode: RGATreeSplitNode<T>): Array<RGATreeSplitNode<T>>;
    private splitNode;
    private deleteNodes;
    private filterNodes;
    /**
     * `findEdgesOfCandidates` finds the edges outside `candidates`,
     * (which has not already been deleted, or be undefined but not yet implemented)
     * right edge is undefined means `candidates` contains the end of text.
     */
    private findEdgesOfCandidates;
    private makeChanges;
    /**
     * `deleteIndexNodes` clears the index nodes of the given deletion boundaries.
     * The boundaries mean the nodes that will not be deleted in the range.
     */
    private deleteIndexNodes;
    /**
     * `getRemovedNodesLen` returns size of removed nodes.
     */
    getRemovedNodesLen(): number;
    /**
     * `purgeRemovedNodesBefore` physically purges nodes that have been removed.
     */
    purgeRemovedNodesBefore(ticket: TimeTicket): number;
    /**
     * `purge` physically purges the given node from RGATreeSplit.
     */
    purge(node: RGATreeSplitNode<T>): void;
}

/**
 * `RGATreeSplitNode` is a node of RGATreeSplit.
 */
declare class RGATreeSplitNode<T extends RGATreeSplitValue> extends SplayNode<T> {
    private id;
    private removedAt?;
    private prev?;
    private next?;
    private insPrev?;
    private insNext?;
    constructor(id: RGATreeSplitNodeID, value?: T, removedAt?: TimeTicket);
    /**
     * `create` creates a instance of RGATreeSplitNode.
     */
    static create<T extends RGATreeSplitValue>(id: RGATreeSplitNodeID, value?: T): RGATreeSplitNode<T>;
    /**
     * `createComparator` creates a function to compare two RGATreeSplitNodeID.
     */
    static createComparator(): Comparator<RGATreeSplitNodeID>;
    /**
     * `getID` returns the ID of this RGATreeSplitNode.
     */
    getID(): RGATreeSplitNodeID;
    /**
     * `getCreatedAt` returns creation time of the Id of RGATreeSplitNode.
     */
    getCreatedAt(): TimeTicket;
    /**
     * `getLength` returns the length of this node.
     */
    getLength(): number;
    /**
     * `getContentLength` returns the length of this value.
     */
    getContentLength(): number;
    /**
     * `getPrev` returns a previous node of this node.
     */
    getPrev(): RGATreeSplitNode<T> | undefined;
    /**
     * `getNext` returns a next node of this node.
     */
    getNext(): RGATreeSplitNode<T> | undefined;
    /**
     * `getInsPrev` returns a previous node of this node insertion.
     */
    getInsPrev(): RGATreeSplitNode<T> | undefined;
    /**
     * `getInsNext` returns a next node of this node insertion.
     */
    getInsNext(): RGATreeSplitNode<T> | undefined;
    /**
     * `getInsPrevID` returns a ID of previous node insertion.
     */
    getInsPrevID(): RGATreeSplitNodeID;
    /**
     * `setPrev` sets previous node of this node.
     */
    setPrev(node?: RGATreeSplitNode<T>): void;
    /**
     * `setNext` sets next node of this node.
     */
    setNext(node?: RGATreeSplitNode<T>): void;
    /**
     * `setInsPrev` sets previous node of this node insertion.
     */
    setInsPrev(node?: RGATreeSplitNode<T>): void;
    /**
     * `setInsNext` sets next node of this node insertion.
     */
    setInsNext(node?: RGATreeSplitNode<T>): void;
    /**
     * `hasNext` checks if next node exists.
     */
    hasNext(): boolean;
    /**
     * `hasInsPrev` checks if previous insertion node exists.
     */
    hasInsPrev(): boolean;
    /**
     * `isRemoved` checks if removed time exists.
     */
    isRemoved(): boolean;
    /**
     * `getRemovedAt` returns the remove time of this node.
     */
    getRemovedAt(): TimeTicket | undefined;
    /**
     * `split` creates a new split node of the given offset.
     */
    split(offset: number): RGATreeSplitNode<T>;
    /**
     * `canDelete` checks if node is able to delete.
     */
    canDelete(editedAt: TimeTicket, latestCreatedAt: TimeTicket): boolean;
    /**
     * `canStyle` checks if node is able to set style.
     */
    canStyle(editedAt: TimeTicket, latestCreatedAt: TimeTicket): boolean;
    /**
     * `remove` removes node of given edited time.
     */
    remove(editedAt?: TimeTicket): void;
    /**
     * `createRange` creates ranges of RGATreeSplitPos.
     */
    createPosRange(): RGATreeSplitPosRange;
    /**
     * `deepcopy` returns a new instance of this RGATreeSplitNode without structural info.
     */
    deepcopy(): RGATreeSplitNode<T>;
    /**
     * `toTestString` returns a String containing
     * the meta data of the node for debugging purpose.
     */
    toTestString(): string;
    private splitValue;
}

/**
 * `RGATreeSplitNodeID` is an ID of RGATreeSplitNode.
 */
declare class RGATreeSplitNodeID {
    private createdAt;
    private offset;
    constructor(createdAt: TimeTicket, offset: number);
    /**
     * `of` creates a instance of RGATreeSplitNodeID.
     */
    static of(createdAt: TimeTicket, offset: number): RGATreeSplitNodeID;
    /**
     * `fromStruct` creates a instance of RGATreeSplitNodeID from the struct.
     */
    static fromStruct(struct: RGATreeSplitNodeIDStruct): RGATreeSplitNodeID;
    /**
     * `getCreatedAt` returns the creation time of this ID.
     */
    getCreatedAt(): TimeTicket;
    /**
     * `getOffset` returns returns the offset of this ID.
     */
    getOffset(): number;
    /**
     * `equals` returns whether given ID equals to this ID or not.
     */
    equals(other: RGATreeSplitNodeID): boolean;
    /**
     * `hasSameCreatedAt` returns whether given ID has same creation time with this ID.
     */
    hasSameCreatedAt(other: RGATreeSplitNodeID): boolean;
    /**
     * `split` creates a new ID with an offset from this ID.
     */
    split(offset: number): RGATreeSplitNodeID;
    /**
     * `toStruct` returns the structure of this node id.
     */
    toStruct(): RGATreeSplitNodeIDStruct;
    /**
     * `toTestString` returns a String containing
     * the meta data of the node id for debugging purpose.
     */
    toTestString(): string;
    /**
     * `toIDString` returns a string that can be used as an ID for this node id.
     */
    toIDString(): string;
}

/**
 * `RGATreeSplitNodeIDStruct` is a structure represents the meta data of the node id.
 * It is used to serialize and deserialize the node id.
 */
declare type RGATreeSplitNodeIDStruct = {
    createdAt: TimeTicketStruct;
    offset: number;
};

/**
 * `RGATreeSplitPos` is the position of the text inside the node.
 */
declare class RGATreeSplitPos {
    private id;
    private relativeOffset;
    constructor(id: RGATreeSplitNodeID, relativeOffset: number);
    /**
     * `of` creates a instance of RGATreeSplitPos.
     */
    static of(id: RGATreeSplitNodeID, relativeOffset: number): RGATreeSplitPos;
    /**
     * `fromStruct` creates a instance of RGATreeSplitPos from the struct.
     */
    static fromStruct(struct: RGATreeSplitPosStruct): RGATreeSplitPos;
    /**
     * `getID` returns the ID of this RGATreeSplitPos.
     */
    getID(): RGATreeSplitNodeID;
    /**
     * `getRelativeOffset` returns the relative offset of this RGATreeSplitPos.
     */
    getRelativeOffset(): number;
    /**
     * `getAbsoluteID` returns the absolute id of this RGATreeSplitPos.
     */
    getAbsoluteID(): RGATreeSplitNodeID;
    /**
     *`toTestString` returns a String containing
     * the meta data of the position for debugging purpose.
     */
    toTestString(): string;
    /**
     * `toStruct` returns the structure of this node pos.
     */
    toStruct(): RGATreeSplitPosStruct;
    /**
     * `equals` returns whether given pos equal to this pos or not.
     */
    equals(other: RGATreeSplitPos): boolean;
}

declare type RGATreeSplitPosRange = [RGATreeSplitPos, RGATreeSplitPos];

/**
 * `RGATreeSplitPosStruct` is a structure represents the meta data of the node pos.
 * It is used to serialize and deserialize the node pos.
 */
declare type RGATreeSplitPosStruct = {
    id: RGATreeSplitNodeIDStruct;
    relativeOffset: number;
};

declare interface RGATreeSplitValue {
    length: number;
    substring(indexStart: number, indexEnd?: number): RGATreeSplitValue;
}

/**
 * RHT is replicated hash table by creation time.
 * For more details about RHT: @see http://csl.skku.edu/papers/jpdc11.pdf
 */
declare class RHT {
    private nodeMapByKey;
    constructor();
    /**
     * `create` creates a new instance of RHT.
     */
    static create(): RHT;
    /**
     * `set` sets the value of the given key.
     */
    set(key: string, value: string, executedAt: TimeTicket): void;
    /**
     * `has` returns whether the element exists of the given key or not.
     */
    has(key: string): boolean;
    /**
     * `get` returns the value of the given key.
     */
    get(key: string): string | undefined;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): RHT;
    /**
     * `toJSON` returns the JSON encoding of this hashtable.
     */
    toJSON(): string;
    /**
     * `toXML` converts the given RHT to XML string.
     */
    toXML(): string;
    /**
     * `size` returns the size of RHT
     */
    size(): number;
    /**
     * `toObject` returns the object of this hashtable.
     */
    toObject(): Record<string, string>;
    [Symbol.iterator](): IterableIterator<RHTNode>;
}

/**
 * `RHTNode` is a node of RHT(Replicated Hashtable).
 */
declare class RHTNode {
    private key;
    private value;
    private updatedAt;
    constructor(key: string, value: string, updatedAt: TimeTicket);
    /**
     * `of` creates a new instance of RHTNode.
     */
    static of(key: string, value: string, createdAt: TimeTicket): RHTNode;
    /**
     * `getKey` returns a key of node.
     */
    getKey(): string;
    /**
     * `getValue` returns a value of node.
     */
    getValue(): string;
    /**
     * `getUpdatedAt `returns updated time of node.
     */
    getUpdatedAt(): TimeTicket;
}

/**
 * `SetOpInfo` represents the information of the set operation.
 */
export declare type SetOpInfo = {
    type: 'set';
    path: string;
    key: string;
};

/**
 * `SnapshotEvent` is an event that occurs when a snapshot is received from
 * the server.
 *
 * @public
 */
export declare interface SnapshotEvent extends BaseDocEvent {
    /**
     * enum {@link DocEventType}.Snapshot
     */
    type: DocEventType.Snapshot;
    /**
     * SnapshotEvent type
     */
    value: Uint8Array | undefined;
}

/**
 * `SplayNode` is a node of SplayTree.
 */
declare abstract class SplayNode<V> {
    protected value: V;
    private left?;
    private right?;
    private parent?;
    private weight;
    constructor(value: V);
    abstract getLength(): number;
    /**
     * `getNodeString` returns a string of weight and value of this node.
     */
    getNodeString(): string;
    /**
     * `getValue` returns value of this node.
     */
    getValue(): V;
    /**
     * `getLeftWeight` returns left weight of this node.
     */
    getLeftWeight(): number;
    /**
     * `getRightWeight` returns right weight of this node.
     */
    getRightWeight(): number;
    /**
     * `getWeight` returns weight of this node.
     */
    getWeight(): number;
    /**
     * `getLeft` returns a left node.
     */
    getLeft(): SplayNode<V> | undefined;
    /**
     * `getRight` returns a right node.
     */
    getRight(): SplayNode<V> | undefined;
    /**
     * `getParent` returns parent of this node.
     */
    getParent(): SplayNode<V> | undefined;
    /**
     * `hasLeft` check if the left node exists
     */
    hasLeft(): boolean;
    /**
     * `hasRight` check if the right node exists
     */
    hasRight(): boolean;
    /**
     * `hasParent` check if the parent node exists
     */
    hasParent(): boolean;
    /**
     * `setLeft` sets a left node.
     */
    setLeft(left?: SplayNode<V>): void;
    /**
     * `setRight` sets a right node.
     */
    setRight(right?: SplayNode<V>): void;
    /**
     * `setParent` sets a parent node.
     */
    setParent(parent?: SplayNode<V>): void;
    /**
     * `unlink` unlink parent, right and left node.
     */
    unlink(): void;
    /**
     * `hasLinks` checks if parent, right and left node exists.
     */
    hasLinks(): boolean;
    /**
     * `increaseWeight` increases weight.
     */
    increaseWeight(weight: number): void;
    /**
     * `initWeight` sets initial weight of this node.
     */
    initWeight(): void;
}

/**
 * `StatusChangedEvent` is an event that occurs when the Client's state changes.
 *
 * @public
 */
export declare interface StatusChangedEvent extends BaseClientEvent {
    /**
     * enum {@link ClientEventType}.StatusChanged
     */
    type: ClientEventType.StatusChanged;
    /**
     * `StatusChangedEvent` value
     */
    value: ClientStatus;
}

/**
 * `StreamConnectionStatus` represents whether the stream connection between the
 * client and the server is connected or not.
 * @public
 */
export declare enum StreamConnectionStatus {
    /**
     * `Connected` means that the stream connection is connected.
     */
    Connected = "connected",
    /**
     * `Disconnected` means that the stream connection is disconnected.
     */
    Disconnected = "disconnected"
}

/**
 * `StreamConnectionStatusChangedEvent` is an event that occurs when
 * the client's stream connection state changes.
 *
 * @public
 */
export declare interface StreamConnectionStatusChangedEvent extends BaseClientEvent {
    /**
     * `StreamConnectionStatusChangedEvent` type
     * enum {@link ClientEventType}.StreamConnectionStatusChangedEvent
     */
    type: ClientEventType.StreamConnectionStatusChanged;
    /**
     * `StreamConnectionStatusChangedEvent` value
     */
    value: StreamConnectionStatus;
}

/**
 * `StyleOpInfo` represents the information of the style operation.
 */
export declare type StyleOpInfo = {
    type: 'style';
    from: number;
    to: number;
    path: string;
    value: {
        attributes: Indexable;
    };
};

declare interface SubscribeFn<T> {
    (next: Observer<T> | NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    (observer: Observer<T>): Unsubscribe;
}

/**
 * `SyncMode` is the mode of synchronization. It is used to determine
 * whether to push and pull changes in PushPullChanges API.
 * @public
 */
export declare enum SyncMode {
    /**
     * `PushPull` is the mode that pushes and pulls changes.
     */
    PushPull = "pushpull",
    /**
     * `PushOnly` is the mode that pushes changes only.
     */
    PushOnly = "pushonly"
}

declare enum TagContained {
    All = "All",
    Opening = "Opening",
    Closing = "Closing"
}

/**
 * `Text` is an extended data type for the contents of a text editor.
 */
declare class Text_2<A extends Indexable = Indexable> {
    private context?;
    private text?;
    constructor(context?: ChangeContext, text?: CRDTText<A>);
    /**
     * `initialize` initialize this text with context and internal text.
     * @internal
     */
    initialize(context: ChangeContext, text: CRDTText<A>): void;
    /**
     * `getID` returns the ID of this text.
     */
    getID(): TimeTicket;
    /**
     * `edit` edits this text with the given content.
     */
    edit(fromIdx: number, toIdx: number, content: string, attributes?: A): [number, number] | undefined;
    /**
     * `delete` deletes the text in the given range.
     */
    delete(fromIdx: number, toIdx: number): [number, number] | undefined;
    /**
     * `empty` makes the text empty.
     */
    empty(): [number, number] | undefined;
    /**
     * `setStyle` styles this text with the given attributes.
     */
    setStyle(fromIdx: number, toIdx: number, attributes: A): boolean;
    /**
     * `indexRangeToPosRange` returns TextRangeStruct of the given index range.
     */
    indexRangeToPosRange(range: [number, number]): TextPosStructRange;
    /**
     * `posRangeToIndexRange` returns indexes of the given TextRangeStruct.
     */
    posRangeToIndexRange(range: TextPosStructRange): [number, number];
    /**
     * `toTestString` returns a String containing the meta data of the node
     * for debugging purpose.
     */
    toTestString(): string;
    /**
     * `values` returns values of this text.
     */
    values(): Array<TextValueType<A>>;
    /**
     * `length` returns size of RGATreeList.
     */
    get length(): number;
    /**
     * `checkWeight` returns false when there is an incorrect weight node.
     * for debugging purpose.
     */
    checkWeight(): boolean;
    /**
     * `toString` returns the string representation of this text.
     */
    toString(): string;
    /**
     * `createRangeForTest` returns pair of RGATreeSplitNodePos of the given indexes
     * for testing purpose.
     */
    createRangeForTest(fromIdx: number, toIdx: number): RGATreeSplitPosRange;
}
export { Text_2 as Text }

/**
 * `TextChange` represents the changes to the text
 * when executing the edit, setstyle methods.
 */
declare interface TextChange<A = Indexable> extends ValueChange<TextValueType<A>> {
    type: TextChangeType;
}

/**
 * `TextChangeType` is the type of TextChange.
 *
 */
declare enum TextChangeType {
    Content = "content",
    Style = "style"
}

/**
 * `TextNode` represents a text node. It has a string value.
 */
export declare type TextNode = {
    type: typeof DefaultTextType;
    value: string;
};

declare class TextNodePos extends jspb.Message {
    getCreatedAt(): TimeTicket_2 | undefined;
    setCreatedAt(value?: TimeTicket_2): TextNodePos;
    hasCreatedAt(): boolean;
    clearCreatedAt(): TextNodePos;

    getOffset(): number;
    setOffset(value: number): TextNodePos;

    getRelativeOffset(): number;
    setRelativeOffset(value: number): TextNodePos;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TextNodePos.AsObject;
    static toObject(includeInstance: boolean, msg: TextNodePos): TextNodePos.AsObject;
    static serializeBinaryToWriter(message: TextNodePos, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TextNodePos;
    static deserializeBinaryFromReader(message: TextNodePos, reader: jspb.BinaryReader): TextNodePos;
}

declare namespace TextNodePos {
    type AsObject = {
        createdAt?: TimeTicket_2.AsObject,
        offset: number,
        relativeOffset: number,
    }
}

/**
 * `TextOperationInfo` represents the OperationInfo for the yorkie.Text.
 */
export declare type TextOperationInfo = EditOpInfo | StyleOpInfo;

/**
 * `TextPosStruct` represents the structure of RGATreeSplitPos.
 * It is used to serialize and deserialize the RGATreeSplitPos.
 */
export declare type TextPosStruct = {
    id: {
        createdAt: TimeTicketStruct;
        offset: number;
    };
    relativeOffset: number;
};

/**
 * `TextPosStructRange` represents the structure of RGATreeSplitPosRange.
 * It is used to serialize and deserialize the RGATreeSplitPosRange.
 */
export declare type TextPosStructRange = [TextPosStruct, TextPosStruct];

/**
 * `TextValueType` is a value of Text
 * which has a attributes that expresses the text style.
 */
declare interface TextValueType<A> {
    attributes?: A;
    content?: string;
}

/**
 * `TimeTicket` is a timestamp of the logical clock. Ticket is immutable.
 * It is created by `ChangeID`.
 *
 * @public
 */
export declare class TimeTicket {
    private lamport;
    private delimiter;
    private actorID?;
    /** @hideconstructor */
    constructor(lamport: Long_2, delimiter: number, actorID?: string);
    /**
     * `of` creates an instance of Ticket.
     */
    static of(lamport: Long_2, delimiter: number, actorID?: string): TimeTicket;
    /**
     * `fromStruct` creates an instance of Ticket from the struct.
     */
    static fromStruct(struct: TimeTicketStruct): TimeTicket;
    /**
     * `toIDString` returns the lamport string for this Ticket.
     */
    toIDString(): string;
    /**
     * `toStruct` returns the structure of this Ticket.
     */
    toStruct(): TimeTicketStruct;
    /**
     * `toTestString` returns a string containing the meta data of the ticket
     * for debugging purpose.
     */
    toTestString(): string;
    /**
     * `setActor` creates a new instance of Ticket with the given actorID.
     */
    setActor(actorID: ActorID): TimeTicket;
    /**
     * `getLamportAsString` returns the lamport string.
     */
    getLamportAsString(): string;
    /**
     * `getDelimiter` returns delimiter.
     */
    getDelimiter(): number;
    /**
     * `getActorID` returns actorID.
     */
    getActorID(): string | undefined;
    /**
     * `after` returns whether the given ticket was created later.
     */
    after(other: TimeTicket): boolean;
    /**
     * `equals` returns whether the given ticket was created.
     */
    equals(other: TimeTicket): boolean;
    /**
     * `compare` returns an integer comparing two Ticket.
     *  The result will be 0 if id==other, -1 if `id < other`, and +1 if `id > other`.
     *  If the receiver or argument is nil, it would panic at runtime.
     */
    compare(other: TimeTicket): number;
}

declare class TimeTicket_2 extends jspb.Message {
    getLamport(): string;
    setLamport(value: string): TimeTicket_2;

    getDelimiter(): number;
    setDelimiter(value: number): TimeTicket_2;

    getActorId(): Uint8Array | string;
    getActorId_asU8(): Uint8Array;
    getActorId_asB64(): string;
    setActorId(value: Uint8Array | string): TimeTicket_2;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TimeTicket_2.AsObject;
    static toObject(includeInstance: boolean, msg: TimeTicket_2): TimeTicket_2.AsObject;
    static serializeBinaryToWriter(message: TimeTicket_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TimeTicket_2;
    static deserializeBinaryFromReader(message: TimeTicket_2, reader: jspb.BinaryReader): TimeTicket_2;
}

declare namespace TimeTicket_2 {
    type AsObject = {
        lamport: string,
        delimiter: number,
        actorId: Uint8Array | string,
    }
}

/**
 * `TimeTicketStruct` is a structure represents the meta data of the ticket.
 * It is used to serialize and deserialize the ticket.
 */
export declare type TimeTicketStruct = {
    lamport: string;
    delimiter: number;
    actorID: ActorID | undefined;
};

/**
 * `toChangePack` converts the given model to Protobuf format.
 */
declare function toChangePack(pack: ChangePack<Indexable>): ChangePack_2;

/**
 * `toHexString` converts the given byte array to hex string.
 */
declare function toHexString(bytes: Uint8Array): string;

/**
 * `toUnit8Array` converts the given hex string to byte array.
 */
declare function toUint8Array(hex: string): Uint8Array;

/**
 * `Tree` is a CRDT-based tree structure that is used to represent the document
 * tree of text-based editor such as ProseMirror.
 */
export declare class Tree {
    private initialRoot?;
    private context?;
    private tree?;
    constructor(initialRoot?: ElementNode);
    /**
     * `initialize` initialize this tree with context and internal tree.
     * @internal
     */
    initialize(context: ChangeContext, tree: CRDTTree): void;
    /**
     * `getID` returns the ID of this tree.
     */
    getID(): TimeTicket;
    /**
     * `buildRoot` builds the root of this tree with the given initial root
     * which set by the user.
     */
    buildRoot(context: ChangeContext): CRDTTreeNode;
    /**
     * `getSize` returns the size of this tree.
     */
    getSize(): number;
    /**
     * `getIndexTree` returns the index tree of this tree.
     */
    getIndexTree(): IndexTree<CRDTTreeNode>;
    /**
     * `styleByPath` sets the attributes to the elements of the given path.
     */
    styleByPath(path: Array<number>, attributes: {
        [key: string]: any;
    }): void;
    /**
     * `style` sets the attributes to the elements of the given range.
     */
    style(fromIdx: number, toIdx: number, attributes: {
        [key: string]: any;
    }): void;
    private editInternal;
    /**
     * `editByPath` edits this tree with the given node and path.
     */
    editByPath(fromPath: Array<number>, toPath: Array<number>, ...contents: Array<TreeNode>): boolean;
    /**
     * `edit` edits this tree with the given nodes.
     */
    edit(fromIdx: number, toIdx: number, ...contents: Array<TreeNode>): boolean;
    /**
     * `toXML` returns the XML string of this tree.
     */
    toXML(): string;
    /**
     * `toJSON` returns the JSON string of this tree.
     */
    toJSON(): string;
    /**
     * `getRootTreeNode` returns TreeNode of this tree.
     */
    getRootTreeNode(): TreeNode;
    /**
     * `indexToPath` returns the path of the given index.
     */
    indexToPath(index: number): Array<number>;
    /**
     * `pathToIndex` returns the index of given path.
     */
    pathToIndex(path: Array<number>): number;
    /**
     * `pathRangeToPosRange` converts the path range into the position range.
     */
    pathRangeToPosRange(range: [Array<number>, Array<number>]): TreePosStructRange;
    /**
     * `indexRangeToPosRange` converts the index range into the position range.
     */
    indexRangeToPosRange(range: [number, number]): TreePosStructRange;
    /**
     * `posRangeToIndexRange` converts the position range into the index range.
     */
    posRangeToIndexRange(range: TreePosStructRange): [number, number];
    /**
     * `posRangeToPathRange` converts the position range into the path range.
     */
    posRangeToPathRange(range: TreePosStructRange): [Array<number>, Array<number>];
}

/**
 * `TreeChange` represents the change in the tree.
 */
export declare interface TreeChange {
    actor: ActorID;
    type: TreeChangeType;
    from: number;
    to: number;
    fromPath: Array<number>;
    toPath: Array<number>;
    value?: Array<TreeNode> | {
        [key: string]: any;
    };
}

/**
 * `TreeChangeType` represents the type of change in the tree.
 */
export declare enum TreeChangeType {
    Content = "content",
    Style = "style"
}

/**
 * `TreeEditOpInfo` represents the information of the tree edit operation.
 */
declare type TreeEditOpInfo = {
    type: 'tree-edit';
    from: number;
    to: number;
    fromPath: Array<number>;
    toPath: Array<number>;
    value: TreeNode;
    path: string;
};

/**
 * `TreeNode` represents a node in the tree.
 */
export declare type TreeNode = TextNode | ElementNode;

declare class TreeNode_2 extends jspb.Message {
    getId(): TreeNodeID | undefined;
    setId(value?: TreeNodeID): TreeNode_2;
    hasId(): boolean;
    clearId(): TreeNode_2;

    getType(): string;
    setType(value: string): TreeNode_2;

    getValue(): string;
    setValue(value: string): TreeNode_2;

    getRemovedAt(): TimeTicket_2 | undefined;
    setRemovedAt(value?: TimeTicket_2): TreeNode_2;
    hasRemovedAt(): boolean;
    clearRemovedAt(): TreeNode_2;

    getInsPrevId(): TreeNodeID | undefined;
    setInsPrevId(value?: TreeNodeID): TreeNode_2;
    hasInsPrevId(): boolean;
    clearInsPrevId(): TreeNode_2;

    getInsNextId(): TreeNodeID | undefined;
    setInsNextId(value?: TreeNodeID): TreeNode_2;
    hasInsNextId(): boolean;
    clearInsNextId(): TreeNode_2;

    getDepth(): number;
    setDepth(value: number): TreeNode_2;

    getAttributesMap(): jspb.Map<string, NodeAttr>;
    clearAttributesMap(): TreeNode_2;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TreeNode_2.AsObject;
    static toObject(includeInstance: boolean, msg: TreeNode_2): TreeNode_2.AsObject;
    static serializeBinaryToWriter(message: TreeNode_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TreeNode_2;
    static deserializeBinaryFromReader(message: TreeNode_2, reader: jspb.BinaryReader): TreeNode_2;
}

declare namespace TreeNode_2 {
    type AsObject = {
        id?: TreeNodeID.AsObject,
        type: string,
        value: string,
        removedAt?: TimeTicket_2.AsObject,
        insPrevId?: TreeNodeID.AsObject,
        insNextId?: TreeNodeID.AsObject,
        depth: number,
        attributesMap: Array<[string, NodeAttr.AsObject]>,
    }
}

/**
 * `TreeNodeForTest` represents the JSON representation of a node in the tree.
 * It is used for testing.
 */
declare type TreeNodeForTest = TreeNode & {
    children?: Array<TreeNodeForTest>;
    size: number;
    isRemoved: boolean;
};

declare class TreeNodeID extends jspb.Message {
    getCreatedAt(): TimeTicket_2 | undefined;
    setCreatedAt(value?: TimeTicket_2): TreeNodeID;
    hasCreatedAt(): boolean;
    clearCreatedAt(): TreeNodeID;

    getOffset(): number;
    setOffset(value: number): TreeNodeID;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TreeNodeID.AsObject;
    static toObject(includeInstance: boolean, msg: TreeNodeID): TreeNodeID.AsObject;
    static serializeBinaryToWriter(message: TreeNodeID, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TreeNodeID;
    static deserializeBinaryFromReader(message: TreeNodeID, reader: jspb.BinaryReader): TreeNodeID;
}

declare namespace TreeNodeID {
    type AsObject = {
        createdAt?: TimeTicket_2.AsObject,
        offset: number,
    }
}

declare class TreeNodes extends jspb.Message {
    getContentList(): Array<TreeNode_2>;
    setContentList(value: Array<TreeNode_2>): TreeNodes;
    clearContentList(): TreeNodes;
    addContent(value?: TreeNode_2, index?: number): TreeNode_2;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TreeNodes.AsObject;
    static toObject(includeInstance: boolean, msg: TreeNodes): TreeNodes.AsObject;
    static serializeBinaryToWriter(message: TreeNodes, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TreeNodes;
    static deserializeBinaryFromReader(message: TreeNodes, reader: jspb.BinaryReader): TreeNodes;
}

declare namespace TreeNodes {
    type AsObject = {
        contentList: Array<TreeNode_2.AsObject>,
    }
}

/**
 * `NoteType` is the type of a node in the tree.
 */
declare type TreeNodeType = string;

/**
 * `TreeOperationInfo` represents the OperationInfo for the yorkie.Tree.
 */
export declare type TreeOperationInfo = TreeEditOpInfo | TreeStyleOpInfo;

/**
 * `TreePos` is the position of a node in the tree.
 *
 * `offset` is the position of node's token. For example, if the node is an
 * element node, the offset is the index of the child node. If the node is a
 * text node, the offset is the index of the character.
 */
declare type TreePos<T extends IndexTreeNode<T>> = {
    node: T;
    offset: number;
};

declare class TreePos_2 extends jspb.Message {
    getParentId(): TreeNodeID | undefined;
    setParentId(value?: TreeNodeID): TreePos_2;
    hasParentId(): boolean;
    clearParentId(): TreePos_2;

    getLeftSiblingId(): TreeNodeID | undefined;
    setLeftSiblingId(value?: TreeNodeID): TreePos_2;
    hasLeftSiblingId(): boolean;
    clearLeftSiblingId(): TreePos_2;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TreePos_2.AsObject;
    static toObject(includeInstance: boolean, msg: TreePos_2): TreePos_2.AsObject;
    static serializeBinaryToWriter(message: TreePos_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TreePos_2;
    static deserializeBinaryFromReader(message: TreePos_2, reader: jspb.BinaryReader): TreePos_2;
}

declare namespace TreePos_2 {
    type AsObject = {
        parentId?: TreeNodeID.AsObject,
        leftSiblingId?: TreeNodeID.AsObject,
    }
}

/**
 * `TreePosRange` represents a pair of CRDTTreePos.
 */
declare type TreePosRange = [CRDTTreePos, CRDTTreePos];

/**
 * `TreePosStructRange` represents the structure of TreeRange.
 * It is used to serialize and deserialize the TreeRange.
 */
export declare type TreePosStructRange = [CRDTTreePosStruct, CRDTTreePosStruct];

/**
 * `TreeStyleOpInfo` represents the information of the tree style operation.
 */
declare type TreeStyleOpInfo = {
    type: 'tree-style';
    from: number;
    to: number;
    fromPath: Array<number>;
    value: {
        [key: string]: any;
    };
    path: string;
};

export declare type Unsubscribe = () => void;

declare interface UnwatchedEvent<P extends Indexable> extends BaseDocEvent {
    type: DocEventType.Unwatched;
    value: {
        clientID: ActorID;
        presence: P;
    };
}

declare interface ValueChange<T> {
    actor: ActorID;
    from: number;
    to: number;
    value?: T;
}

declare enum ValueType { 
    VALUE_TYPE_NULL = 0,
    VALUE_TYPE_BOOLEAN = 1,
    VALUE_TYPE_INTEGER = 2,
    VALUE_TYPE_LONG = 3,
    VALUE_TYPE_DOUBLE = 4,
    VALUE_TYPE_STRING = 5,
    VALUE_TYPE_BYTES = 6,
    VALUE_TYPE_DATE = 7,
    VALUE_TYPE_JSON_OBJECT = 8,
    VALUE_TYPE_JSON_ARRAY = 9,
    VALUE_TYPE_TEXT = 10,
    VALUE_TYPE_INTEGER_CNT = 11,
    VALUE_TYPE_LONG_CNT = 12,
    VALUE_TYPE_TREE = 13,
}

declare interface WatchedEvent<P extends Indexable> extends BaseDocEvent {
    type: DocEventType.Watched;
    value: {
        clientID: ActorID;
        presence: P;
    };
}

/**
 * `WrappedElement` is a wrapper of JSONElement that provides `getID()`.
 */
export declare type WrappedElement<T = unknown, A extends Indexable = Indexable> = Primitive | JSONObject<T> | JSONArray<T> | Text_2<A> | Counter | Tree;

/**
 * The top-level yorkie namespace with additional properties.
 *
 * In production, this will be called exactly once and the result
 * assigned to the `yorkie` global.
 *
 * e.g) `new yorkie.Client(...);`
 *
 * @public
 */
declare const yorkie: {
    Client: typeof Client;
    Document: typeof Document_2;
    Primitive: typeof Primitive;
    Text: typeof Text_2;
    Counter: typeof Counter;
    Tree: typeof Tree;
    IntType: CounterType;
    LongType: CounterType;
};
export default yorkie;

export { }
