/*!
 * 
 * yorkie-js-sdk for building collaborative editing applications.
 *  - Version: v0.4.9
 *  - Date: 2023-11-25T06:33Z
 *  - Homepage: https://yorkie.dev
 *
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["yorkie"] = factory();
	else
		root["yorkie"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 19:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.findInternal=function(a,b,c){a instanceof String&&(a=String(a));for(var d=a.length,e=0;e<d;e++){var f=a[e];if(b.call(c,f,e,a))return{i:e,v:f}}return{i:-1,v:void 0}};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;
$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value)};$jscomp.getGlobal=function(a){return"undefined"!=typeof window&&window===a?a:"undefined"!=typeof __webpack_require__.g&&null!=__webpack_require__.g?__webpack_require__.g:a};$jscomp.global=$jscomp.getGlobal(this);
$jscomp.polyfill=function(a,b,c,d){if(b){c=$jscomp.global;a=a.split(".");for(d=0;d<a.length-1;d++){var e=a[d];e in c||(c[e]={});c=c[e]}a=a[a.length-1];d=c[a];b=b(d);b!=d&&null!=b&&$jscomp.defineProperty(c,a,{configurable:!0,writable:!0,value:b})}};$jscomp.polyfill("Array.prototype.findIndex",function(a){return a?a:function(a,c){return $jscomp.findInternal(this,a,c).i}},"es6","es3");
$jscomp.checkStringArgs=function(a,b,c){if(null==a)throw new TypeError("The 'this' value for String.prototype."+c+" must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype."+c+" must not be a regular expression");return a+""};
$jscomp.polyfill("String.prototype.endsWith",function(a){return a?a:function(a,c){var b=$jscomp.checkStringArgs(this,a,"endsWith");a+="";void 0===c&&(c=b.length);c=Math.max(0,Math.min(c|0,b.length));for(var e=a.length;0<e&&0<c;)if(b[--c]!=a[--e])return!1;return 0>=e}},"es6","es3");$jscomp.polyfill("Array.prototype.find",function(a){return a?a:function(a,c){return $jscomp.findInternal(this,a,c).v}},"es6","es3");
$jscomp.polyfill("String.prototype.startsWith",function(a){return a?a:function(a,c){var b=$jscomp.checkStringArgs(this,a,"startsWith");a+="";var e=b.length,f=a.length;c=Math.max(0,Math.min(c|0,b.length));for(var g=0;g<f&&c<e;)if(b[c++]!=a[g++])return!1;return g>=f}},"es6","es3");
$jscomp.polyfill("String.prototype.repeat",function(a){return a?a:function(a){var b=$jscomp.checkStringArgs(this,null,"repeat");if(0>a||1342177279<a)throw new RangeError("Invalid count value");a|=0;for(var d="";a;)if(a&1&&(d+=b),a>>>=1)b+=b;return d}},"es6","es3");var COMPILED=!0,goog=goog||{};goog.global=this||self;goog.isDef=function(a){return void 0!==a};goog.isString=function(a){return"string"==typeof a};goog.isBoolean=function(a){return"boolean"==typeof a};
goog.isNumber=function(a){return"number"==typeof a};goog.exportPath_=function(a,b,c){a=a.split(".");c=c||goog.global;a[0]in c||"undefined"==typeof c.execScript||c.execScript("var "+a[0]);for(var d;a.length&&(d=a.shift());)!a.length&&goog.isDef(b)?c[d]=b:c=c[d]&&c[d]!==Object.prototype[d]?c[d]:c[d]={}};
goog.define=function(a,b){if(!COMPILED){var c=goog.global.CLOSURE_UNCOMPILED_DEFINES,d=goog.global.CLOSURE_DEFINES;c&&void 0===c.nodeType&&Object.prototype.hasOwnProperty.call(c,a)?b=c[a]:d&&void 0===d.nodeType&&Object.prototype.hasOwnProperty.call(d,a)&&(b=d[a])}return b};goog.FEATURESET_YEAR=2012;goog.DEBUG=!0;goog.LOCALE="en";goog.TRUSTED_SITE=!0;goog.STRICT_MODE_COMPATIBLE=!1;goog.DISALLOW_TEST_ONLY_CODE=COMPILED&&!goog.DEBUG;goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING=!1;
goog.provide=function(a){if(goog.isInModuleLoader_())throw Error("goog.provide cannot be used within a module.");if(!COMPILED&&goog.isProvided_(a))throw Error('Namespace "'+a+'" already declared.');goog.constructNamespace_(a)};goog.constructNamespace_=function(a,b){if(!COMPILED){delete goog.implicitNamespaces_[a];for(var c=a;(c=c.substring(0,c.lastIndexOf(".")))&&!goog.getObjectByName(c);)goog.implicitNamespaces_[c]=!0}goog.exportPath_(a,b)};
goog.getScriptNonce=function(a){if(a&&a!=goog.global)return goog.getScriptNonce_(a.document);null===goog.cspNonce_&&(goog.cspNonce_=goog.getScriptNonce_(goog.global.document));return goog.cspNonce_};goog.NONCE_PATTERN_=/^[\w+/_-]+[=]{0,2}$/;goog.cspNonce_=null;goog.getScriptNonce_=function(a){return(a=a.querySelector&&a.querySelector("script[nonce]"))&&(a=a.nonce||a.getAttribute("nonce"))&&goog.NONCE_PATTERN_.test(a)?a:""};goog.VALID_MODULE_RE_=/^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
goog.module=function(a){if(!goog.isString(a)||!a||-1==a.search(goog.VALID_MODULE_RE_))throw Error("Invalid module identifier");if(!goog.isInGoogModuleLoader_())throw Error("Module "+a+" has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
if(goog.moduleLoaderState_.moduleName)throw Error("goog.module may only be called once per module.");goog.moduleLoaderState_.moduleName=a;if(!COMPILED){if(goog.isProvided_(a))throw Error('Namespace "'+a+'" already declared.');delete goog.implicitNamespaces_[a]}};goog.module.get=function(a){return goog.module.getInternal_(a)};
goog.module.getInternal_=function(a){if(!COMPILED){if(a in goog.loadedModules_)return goog.loadedModules_[a].exports;if(!goog.implicitNamespaces_[a])return a=goog.getObjectByName(a),null!=a?a:null}return null};goog.ModuleType={ES6:"es6",GOOG:"goog"};goog.moduleLoaderState_=null;goog.isInModuleLoader_=function(){return goog.isInGoogModuleLoader_()||goog.isInEs6ModuleLoader_()};goog.isInGoogModuleLoader_=function(){return!!goog.moduleLoaderState_&&goog.moduleLoaderState_.type==goog.ModuleType.GOOG};
goog.isInEs6ModuleLoader_=function(){if(goog.moduleLoaderState_&&goog.moduleLoaderState_.type==goog.ModuleType.ES6)return!0;var a=goog.global.$jscomp;return a?"function"!=typeof a.getCurrentModulePath?!1:!!a.getCurrentModulePath():!1};
goog.module.declareLegacyNamespace=function(){if(!COMPILED&&!goog.isInGoogModuleLoader_())throw Error("goog.module.declareLegacyNamespace must be called from within a goog.module");if(!COMPILED&&!goog.moduleLoaderState_.moduleName)throw Error("goog.module must be called prior to goog.module.declareLegacyNamespace.");goog.moduleLoaderState_.declareLegacyNamespace=!0};
goog.declareModuleId=function(a){if(!COMPILED){if(!goog.isInEs6ModuleLoader_())throw Error("goog.declareModuleId may only be called from within an ES6 module");if(goog.moduleLoaderState_&&goog.moduleLoaderState_.moduleName)throw Error("goog.declareModuleId may only be called once per module.");if(a in goog.loadedModules_)throw Error('Module with namespace "'+a+'" already exists.');}if(goog.moduleLoaderState_)goog.moduleLoaderState_.moduleName=a;else{var b=goog.global.$jscomp;if(!b||"function"!=typeof b.getCurrentModulePath)throw Error('Module with namespace "'+
a+'" has been loaded incorrectly.');b=b.require(b.getCurrentModulePath());goog.loadedModules_[a]={exports:b,type:goog.ModuleType.ES6,moduleId:a}}};goog.setTestOnly=function(a){if(goog.DISALLOW_TEST_ONLY_CODE)throw a=a||"",Error("Importing test-only code into non-debug environment"+(a?": "+a:"."));};goog.forwardDeclare=function(a){};
COMPILED||(goog.isProvided_=function(a){return a in goog.loadedModules_||!goog.implicitNamespaces_[a]&&goog.isDefAndNotNull(goog.getObjectByName(a))},goog.implicitNamespaces_={"goog.module":!0});goog.getObjectByName=function(a,b){a=a.split(".");b=b||goog.global;for(var c=0;c<a.length;c++)if(b=b[a[c]],!goog.isDefAndNotNull(b))return null;return b};goog.globalize=function(a,b){b=b||goog.global;for(var c in a)b[c]=a[c]};
goog.addDependency=function(a,b,c,d){!COMPILED&&goog.DEPENDENCIES_ENABLED&&goog.debugLoader_.addDependency(a,b,c,d)};goog.ENABLE_DEBUG_LOADER=!0;goog.logToConsole_=function(a){goog.global.console&&goog.global.console.error(a)};
goog.require=function(a){if(!COMPILED){goog.ENABLE_DEBUG_LOADER&&goog.debugLoader_.requested(a);if(goog.isProvided_(a)){if(goog.isInModuleLoader_())return goog.module.getInternal_(a)}else if(goog.ENABLE_DEBUG_LOADER){var b=goog.moduleLoaderState_;goog.moduleLoaderState_=null;try{goog.debugLoader_.load_(a)}finally{goog.moduleLoaderState_=b}}return null}};goog.requireType=function(a){return{}};goog.basePath="";goog.nullFunction=function(){};
goog.abstractMethod=function(){throw Error("unimplemented abstract method");};goog.addSingletonGetter=function(a){a.instance_=void 0;a.getInstance=function(){if(a.instance_)return a.instance_;goog.DEBUG&&(goog.instantiatedSingletons_[goog.instantiatedSingletons_.length]=a);return a.instance_=new a}};goog.instantiatedSingletons_=[];goog.LOAD_MODULE_USING_EVAL=!0;goog.SEAL_MODULE_EXPORTS=goog.DEBUG;goog.loadedModules_={};goog.DEPENDENCIES_ENABLED=!COMPILED&&goog.ENABLE_DEBUG_LOADER;goog.TRANSPILE="detect";
goog.ASSUME_ES_MODULES_TRANSPILED=!1;goog.TRANSPILE_TO_LANGUAGE="";goog.TRANSPILER="transpile.js";goog.hasBadLetScoping=null;goog.useSafari10Workaround=function(){if(null==goog.hasBadLetScoping){try{var a=!eval('"use strict";let x = 1; function f() { return typeof x; };f() == "number";')}catch(b){a=!1}goog.hasBadLetScoping=a}return goog.hasBadLetScoping};goog.workaroundSafari10EvalBug=function(a){return"(function(){"+a+"\n;})();\n"};
goog.loadModule=function(a){var b=goog.moduleLoaderState_;try{goog.moduleLoaderState_={moduleName:"",declareLegacyNamespace:!1,type:goog.ModuleType.GOOG};if(goog.isFunction(a))var c=a.call(void 0,{});else if(goog.isString(a))goog.useSafari10Workaround()&&(a=goog.workaroundSafari10EvalBug(a)),c=goog.loadModuleFromSource_.call(void 0,a);else throw Error("Invalid module definition");var d=goog.moduleLoaderState_.moduleName;if(goog.isString(d)&&d)goog.moduleLoaderState_.declareLegacyNamespace?goog.constructNamespace_(d,
c):goog.SEAL_MODULE_EXPORTS&&Object.seal&&"object"==typeof c&&null!=c&&Object.seal(c),goog.loadedModules_[d]={exports:c,type:goog.ModuleType.GOOG,moduleId:goog.moduleLoaderState_.moduleName};else throw Error('Invalid module name "'+d+'"');}finally{goog.moduleLoaderState_=b}};goog.loadModuleFromSource_=function(a){eval(a);return{}};goog.normalizePath_=function(a){a=a.split("/");for(var b=0;b<a.length;)"."==a[b]?a.splice(b,1):b&&".."==a[b]&&a[b-1]&&".."!=a[b-1]?a.splice(--b,2):b++;return a.join("/")};
goog.loadFileSync_=function(a){if(goog.global.CLOSURE_LOAD_FILE_SYNC)return goog.global.CLOSURE_LOAD_FILE_SYNC(a);try{var b=new goog.global.XMLHttpRequest;b.open("get",a,!1);b.send();return 0==b.status||200==b.status?b.responseText:null}catch(c){return null}};
goog.transpile_=function(a,b,c){var d=goog.global.$jscomp;d||(goog.global.$jscomp=d={});var e=d.transpile;if(!e){var f=goog.basePath+goog.TRANSPILER,g=goog.loadFileSync_(f);if(g){(function(){(0,eval)(g+"\n//# sourceURL="+f)}).call(goog.global);if(goog.global.$gwtExport&&goog.global.$gwtExport.$jscomp&&!goog.global.$gwtExport.$jscomp.transpile)throw Error('The transpiler did not properly export the "transpile" method. $gwtExport: '+JSON.stringify(goog.global.$gwtExport));goog.global.$jscomp.transpile=
goog.global.$gwtExport.$jscomp.transpile;d=goog.global.$jscomp;e=d.transpile}}e||(e=d.transpile=function(a,b){goog.logToConsole_(b+" requires transpilation but no transpiler was found.");return a});return e(a,b,c)};
goog.typeOf=function(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b};goog.isNull=function(a){return null===a};goog.isDefAndNotNull=function(a){return null!=a};goog.isArray=function(a){return"array"==goog.typeOf(a)};goog.isArrayLike=function(a){var b=goog.typeOf(a);return"array"==b||"object"==b&&"number"==typeof a.length};goog.isDateLike=function(a){return goog.isObject(a)&&"function"==typeof a.getFullYear};goog.isFunction=function(a){return"function"==goog.typeOf(a)};
goog.isObject=function(a){var b=typeof a;return"object"==b&&null!=a||"function"==b};goog.getUid=function(a){return a[goog.UID_PROPERTY_]||(a[goog.UID_PROPERTY_]=++goog.uidCounter_)};goog.hasUid=function(a){return!!a[goog.UID_PROPERTY_]};goog.removeUid=function(a){null!==a&&"removeAttribute"in a&&a.removeAttribute(goog.UID_PROPERTY_);try{delete a[goog.UID_PROPERTY_]}catch(b){}};goog.UID_PROPERTY_="closure_uid_"+(1E9*Math.random()>>>0);goog.uidCounter_=0;goog.getHashCode=goog.getUid;
goog.removeHashCode=goog.removeUid;goog.cloneObject=function(a){var b=goog.typeOf(a);if("object"==b||"array"==b){if("function"===typeof a.clone)return a.clone();b="array"==b?[]:{};for(var c in a)b[c]=goog.cloneObject(a[c]);return b}return a};goog.bindNative_=function(a,b,c){return a.call.apply(a.bind,arguments)};
goog.bindJs_=function(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}};goog.bind=function(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?goog.bind=goog.bindNative_:goog.bind=goog.bindJs_;return goog.bind.apply(null,arguments)};
goog.partial=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}};goog.mixin=function(a,b){for(var c in b)a[c]=b[c]};goog.now=goog.TRUSTED_SITE&&Date.now||function(){return+new Date};
goog.globalEval=function(a){if(goog.global.execScript)goog.global.execScript(a,"JavaScript");else if(goog.global.eval){if(null==goog.evalWorksForGlobals_){try{goog.global.eval("var _evalTest_ = 1;")}catch(d){}if("undefined"!=typeof goog.global._evalTest_){try{delete goog.global._evalTest_}catch(d){}goog.evalWorksForGlobals_=!0}else goog.evalWorksForGlobals_=!1}if(goog.evalWorksForGlobals_)goog.global.eval(a);else{var b=goog.global.document,c=b.createElement("SCRIPT");c.type="text/javascript";c.defer=
!1;c.appendChild(b.createTextNode(a));b.head.appendChild(c);b.head.removeChild(c)}}else throw Error("goog.globalEval not available");};goog.evalWorksForGlobals_=null;
goog.getCssName=function(a,b){if("."==String(a).charAt(0))throw Error('className passed in goog.getCssName must not start with ".". You passed: '+a);var c=function(a){return goog.cssNameMapping_[a]||a},d=function(a){a=a.split("-");for(var b=[],d=0;d<a.length;d++)b.push(c(a[d]));return b.join("-")};d=goog.cssNameMapping_?"BY_WHOLE"==goog.cssNameMappingStyle_?c:d:function(a){return a};a=b?a+"-"+d(b):d(a);return goog.global.CLOSURE_CSS_NAME_MAP_FN?goog.global.CLOSURE_CSS_NAME_MAP_FN(a):a};
goog.setCssNameMapping=function(a,b){goog.cssNameMapping_=a;goog.cssNameMappingStyle_=b};!COMPILED&&goog.global.CLOSURE_CSS_NAME_MAPPING&&(goog.cssNameMapping_=goog.global.CLOSURE_CSS_NAME_MAPPING);goog.getMsg=function(a,b,c){c&&c.html&&(a=a.replace(/</g,"&lt;"));b&&(a=a.replace(/\{\$([^}]+)}/g,function(a,c){return null!=b&&c in b?b[c]:a}));return a};goog.getMsgWithFallback=function(a,b){return a};goog.exportSymbol=function(a,b,c){goog.exportPath_(a,b,c)};
goog.exportProperty=function(a,b,c){a[b]=c};goog.inherits=function(a,b){function c(){}c.prototype=b.prototype;a.superClass_=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.base=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)}};
goog.base=function(a,b,c){var d=arguments.callee.caller;if(goog.STRICT_MODE_COMPATIBLE||goog.DEBUG&&!d)throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");if("undefined"!==typeof d.superClass_){for(var e=Array(arguments.length-1),f=1;f<arguments.length;f++)e[f-1]=arguments[f];return d.superClass_.constructor.apply(a,e)}if("string"!=typeof b&&"symbol"!=typeof b)throw Error("method names provided to goog.base must be a string or a symbol");
e=Array(arguments.length-2);for(f=2;f<arguments.length;f++)e[f-2]=arguments[f];f=!1;for(var g=a.constructor.prototype;g;g=Object.getPrototypeOf(g))if(g[b]===d)f=!0;else if(f)return g[b].apply(a,e);if(a[b]===d)return a.constructor.prototype[b].apply(a,e);throw Error("goog.base called from a method of one name to a method of a different name");};goog.scope=function(a){if(goog.isInModuleLoader_())throw Error("goog.scope is not supported within a module.");a.call(goog.global)};
COMPILED||(goog.global.COMPILED=COMPILED);goog.defineClass=function(a,b){var c=b.constructor,d=b.statics;c&&c!=Object.prototype.constructor||(c=function(){throw Error("cannot instantiate an interface (no constructor defined).");});c=goog.defineClass.createSealingConstructor_(c,a);a&&goog.inherits(c,a);delete b.constructor;delete b.statics;goog.defineClass.applyProperties_(c.prototype,b);null!=d&&(d instanceof Function?d(c):goog.defineClass.applyProperties_(c,d));return c};
goog.defineClass.SEAL_CLASS_INSTANCES=goog.DEBUG;goog.defineClass.createSealingConstructor_=function(a,b){if(!goog.defineClass.SEAL_CLASS_INSTANCES)return a;var c=!goog.defineClass.isUnsealable_(b),d=function(){var b=a.apply(this,arguments)||this;b[goog.UID_PROPERTY_]=b[goog.UID_PROPERTY_];this.constructor===d&&c&&Object.seal instanceof Function&&Object.seal(b);return b};return d};goog.defineClass.isUnsealable_=function(a){return a&&a.prototype&&a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]};
goog.defineClass.OBJECT_PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");goog.defineClass.applyProperties_=function(a,b){for(var c in b)Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c]);for(var d=0;d<goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length;d++)c=goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d],Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c])};
goog.tagUnsealableClass=function(a){!COMPILED&&goog.defineClass.SEAL_CLASS_INSTANCES&&(a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]=!0)};goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_="goog_defineClass_legacy_unsealable";
!COMPILED&&goog.DEPENDENCIES_ENABLED&&(goog.inHtmlDocument_=function(){var a=goog.global.document;return null!=a&&"write"in a},goog.isDocumentLoading_=function(){var a=goog.global.document;return a.attachEvent?"complete"!=a.readyState:"loading"==a.readyState},goog.findBasePath_=function(){if(goog.isDef(goog.global.CLOSURE_BASE_PATH)&&goog.isString(goog.global.CLOSURE_BASE_PATH))goog.basePath=goog.global.CLOSURE_BASE_PATH;else if(goog.inHtmlDocument_()){var a=goog.global.document,b=a.currentScript;
a=b?[b]:a.getElementsByTagName("SCRIPT");for(b=a.length-1;0<=b;--b){var c=a[b].src,d=c.lastIndexOf("?");d=-1==d?c.length:d;if("base.js"==c.substr(d-7,7)){goog.basePath=c.substr(0,d-7);break}}}},goog.findBasePath_(),goog.Transpiler=function(){this.requiresTranspilation_=null;this.transpilationTarget_=goog.TRANSPILE_TO_LANGUAGE},goog.Transpiler.prototype.createRequiresTranspilation_=function(){function a(a,b){e?d[a]=!0:b()?(c=a,d[a]=!1):e=d[a]=!0}function b(a){try{return!!eval(a)}catch(h){return!1}}
var c="es3",d={es3:!1},e=!1,f=goog.global.navigator&&goog.global.navigator.userAgent?goog.global.navigator.userAgent:"";a("es5",function(){return b("[1,].length==1")});a("es6",function(){return f.match(/Edge\/(\d+)(\.\d)*/i)?!1:b('(()=>{"use strict";class X{constructor(){if(new.target!=String)throw 1;this.x=42}}let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof String))throw 1;for(const a of[2,3]){if(a==2)continue;function f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()==3}})()')});
a("es7",function(){return b("2 ** 2 == 4")});a("es8",function(){return b("async () => 1, true")});a("es9",function(){return b("({...rest} = {}), true")});a("es_next",function(){return!1});return{target:c,map:d}},goog.Transpiler.prototype.needsTranspile=function(a,b){if("always"==goog.TRANSPILE)return!0;if("never"==goog.TRANSPILE)return!1;if(!this.requiresTranspilation_){var c=this.createRequiresTranspilation_();this.requiresTranspilation_=c.map;this.transpilationTarget_=this.transpilationTarget_||
c.target}if(a in this.requiresTranspilation_)return this.requiresTranspilation_[a]?!0:!goog.inHtmlDocument_()||"es6"!=b||"noModule"in goog.global.document.createElement("script")?!1:!0;throw Error("Unknown language mode: "+a);},goog.Transpiler.prototype.transpile=function(a,b){return goog.transpile_(a,b,this.transpilationTarget_)},goog.transpiler_=new goog.Transpiler,goog.protectScriptTag_=function(a){return a.replace(/<\/(SCRIPT)/ig,"\\x3c/$1")},goog.DebugLoader_=function(){this.dependencies_={};
this.idToPath_={};this.written_={};this.loadingDeps_=[];this.depsToLoad_=[];this.paused_=!1;this.factory_=new goog.DependencyFactory(goog.transpiler_);this.deferredCallbacks_={};this.deferredQueue_=[]},goog.DebugLoader_.prototype.bootstrap=function(a,b){function c(){d&&(goog.global.setTimeout(d,0),d=null)}var d=b;if(a.length){b=[];for(var e=0;e<a.length;e++){var f=this.getPathFromDeps_(a[e]);if(!f)throw Error("Unregonized namespace: "+a[e]);b.push(this.dependencies_[f])}f=goog.require;var g=0;for(e=
0;e<a.length;e++)f(a[e]),b[e].onLoad(function(){++g==a.length&&c()})}else c()},goog.DebugLoader_.prototype.loadClosureDeps=function(){this.depsToLoad_.push(this.factory_.createDependency(goog.normalizePath_(goog.basePath+"deps.js"),"deps.js",[],[],{},!1));this.loadDeps_()},goog.DebugLoader_.prototype.requested=function(a,b){(a=this.getPathFromDeps_(a))&&(b||this.areDepsLoaded_(this.dependencies_[a].requires))&&(b=this.deferredCallbacks_[a])&&(delete this.deferredCallbacks_[a],b())},goog.DebugLoader_.prototype.setDependencyFactory=
function(a){this.factory_=a},goog.DebugLoader_.prototype.load_=function(a){if(this.getPathFromDeps_(a)){var b=this,c=[],d=function(a){var e=b.getPathFromDeps_(a);if(!e)throw Error("Bad dependency path or symbol: "+a);if(!b.written_[e]){b.written_[e]=!0;a=b.dependencies_[e];for(e=0;e<a.requires.length;e++)goog.isProvided_(a.requires[e])||d(a.requires[e]);c.push(a)}};d(a);a=!!this.depsToLoad_.length;this.depsToLoad_=this.depsToLoad_.concat(c);this.paused_||a||this.loadDeps_()}else throw a="goog.require could not find: "+
a,goog.logToConsole_(a),Error(a);},goog.DebugLoader_.prototype.loadDeps_=function(){for(var a=this,b=this.paused_;this.depsToLoad_.length&&!b;)(function(){var c=!1,d=a.depsToLoad_.shift(),e=!1;a.loading_(d);var f={pause:function(){if(c)throw Error("Cannot call pause after the call to load.");b=!0},resume:function(){c?a.resume_():b=!1},loaded:function(){if(e)throw Error("Double call to loaded.");e=!0;a.loaded_(d)},pending:function(){for(var b=[],c=0;c<a.loadingDeps_.length;c++)b.push(a.loadingDeps_[c]);
return b},setModuleState:function(a){goog.moduleLoaderState_={type:a,moduleName:"",declareLegacyNamespace:!1}},registerEs6ModuleExports:function(a,b,c){c&&(goog.loadedModules_[c]={exports:b,type:goog.ModuleType.ES6,moduleId:c||""})},registerGoogModuleExports:function(a,b){goog.loadedModules_[a]={exports:b,type:goog.ModuleType.GOOG,moduleId:a}},clearModuleState:function(){goog.moduleLoaderState_=null},defer:function(b){if(c)throw Error("Cannot register with defer after the call to load.");a.defer_(d,
b)},areDepsLoaded:function(){return a.areDepsLoaded_(d.requires)}};try{d.load(f)}finally{c=!0}})();b&&this.pause_()},goog.DebugLoader_.prototype.pause_=function(){this.paused_=!0},goog.DebugLoader_.prototype.resume_=function(){this.paused_&&(this.paused_=!1,this.loadDeps_())},goog.DebugLoader_.prototype.loading_=function(a){this.loadingDeps_.push(a)},goog.DebugLoader_.prototype.loaded_=function(a){for(var b=0;b<this.loadingDeps_.length;b++)if(this.loadingDeps_[b]==a){this.loadingDeps_.splice(b,1);
break}for(b=0;b<this.deferredQueue_.length;b++)if(this.deferredQueue_[b]==a.path){this.deferredQueue_.splice(b,1);break}if(this.loadingDeps_.length==this.deferredQueue_.length&&!this.depsToLoad_.length)for(;this.deferredQueue_.length;)this.requested(this.deferredQueue_.shift(),!0);a.loaded()},goog.DebugLoader_.prototype.areDepsLoaded_=function(a){for(var b=0;b<a.length;b++){var c=this.getPathFromDeps_(a[b]);if(!c||!(c in this.deferredCallbacks_||goog.isProvided_(a[b])))return!1}return!0},goog.DebugLoader_.prototype.getPathFromDeps_=
function(a){return a in this.idToPath_?this.idToPath_[a]:a in this.dependencies_?a:null},goog.DebugLoader_.prototype.defer_=function(a,b){this.deferredCallbacks_[a.path]=b;this.deferredQueue_.push(a.path)},goog.LoadController=function(){},goog.LoadController.prototype.pause=function(){},goog.LoadController.prototype.resume=function(){},goog.LoadController.prototype.loaded=function(){},goog.LoadController.prototype.pending=function(){},goog.LoadController.prototype.registerEs6ModuleExports=function(a,
b,c){},goog.LoadController.prototype.setModuleState=function(a){},goog.LoadController.prototype.clearModuleState=function(){},goog.LoadController.prototype.defer=function(a){},goog.LoadController.prototype.areDepsLoaded=function(){},goog.Dependency=function(a,b,c,d,e){this.path=a;this.relativePath=b;this.provides=c;this.requires=d;this.loadFlags=e;this.loaded_=!1;this.loadCallbacks_=[]},goog.Dependency.prototype.getPathName=function(){var a=this.path,b=a.indexOf("://");0<=b&&(a=a.substring(b+3),b=
a.indexOf("/"),0<=b&&(a=a.substring(b+1)));return a},goog.Dependency.prototype.onLoad=function(a){this.loaded_?a():this.loadCallbacks_.push(a)},goog.Dependency.prototype.loaded=function(){this.loaded_=!0;var a=this.loadCallbacks_;this.loadCallbacks_=[];for(var b=0;b<a.length;b++)a[b]()},goog.Dependency.defer_=!1,goog.Dependency.callbackMap_={},goog.Dependency.registerCallback_=function(a){var b=Math.random().toString(32);goog.Dependency.callbackMap_[b]=a;return b},goog.Dependency.unregisterCallback_=
function(a){delete goog.Dependency.callbackMap_[a]},goog.Dependency.callback_=function(a,b){if(a in goog.Dependency.callbackMap_){for(var c=goog.Dependency.callbackMap_[a],d=[],e=1;e<arguments.length;e++)d.push(arguments[e]);c.apply(void 0,d)}else throw Error("Callback key "+a+" does not exist (was base.js loaded more than once?).");},goog.Dependency.prototype.load=function(a){if(goog.global.CLOSURE_IMPORT_SCRIPT)goog.global.CLOSURE_IMPORT_SCRIPT(this.path)?a.loaded():a.pause();else if(goog.inHtmlDocument_()){var b=
goog.global.document;if("complete"==b.readyState&&!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING){if(/\bdeps.js$/.test(this.path)){a.loaded();return}throw Error('Cannot write "'+this.path+'" after document load');}if(!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING&&goog.isDocumentLoading_()){var c=goog.Dependency.registerCallback_(function(b){goog.DebugLoader_.IS_OLD_IE_&&"complete"!=b.readyState||(goog.Dependency.unregisterCallback_(c),a.loaded())}),d=!goog.DebugLoader_.IS_OLD_IE_&&goog.getScriptNonce()?
' nonce="'+goog.getScriptNonce()+'"':"";d='<script src="'+this.path+'" '+(goog.DebugLoader_.IS_OLD_IE_?"onreadystatechange":"onload")+"=\"goog.Dependency.callback_('"+c+'\', this)" type="text/javascript" '+(goog.Dependency.defer_?"defer":"")+d+">\x3c/script>";b.write(goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createHTML(d):d)}else{var e=b.createElement("script");e.defer=goog.Dependency.defer_;e.async=!1;e.type="text/javascript";(d=goog.getScriptNonce())&&e.setAttribute("nonce",d);goog.DebugLoader_.IS_OLD_IE_?
(a.pause(),e.onreadystatechange=function(){if("loaded"==e.readyState||"complete"==e.readyState)a.loaded(),a.resume()}):e.onload=function(){e.onload=null;a.loaded()};e.src=goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createScriptURL(this.path):this.path;b.head.appendChild(e)}}else goog.logToConsole_("Cannot use default debug loader outside of HTML documents."),"deps.js"==this.relativePath?(goog.logToConsole_("Consider setting CLOSURE_IMPORT_SCRIPT before loading base.js, or setting CLOSURE_NO_DEPS to true."),
a.loaded()):a.pause()},goog.Es6ModuleDependency=function(a,b,c,d,e){goog.Dependency.call(this,a,b,c,d,e)},goog.inherits(goog.Es6ModuleDependency,goog.Dependency),goog.Es6ModuleDependency.prototype.load=function(a){function b(a,b){a=b?'<script type="module" crossorigin>'+b+"\x3c/script>":'<script type="module" crossorigin src="'+a+'">\x3c/script>';d.write(goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createHTML(a):a)}function c(a,b){var c=d.createElement("script");c.defer=!0;c.async=!1;c.type=
"module";c.setAttribute("crossorigin",!0);var e=goog.getScriptNonce();e&&c.setAttribute("nonce",e);b?c.textContent=goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createScript(b):b:c.src=goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createScriptURL(a):a;d.head.appendChild(c)}if(goog.global.CLOSURE_IMPORT_SCRIPT)goog.global.CLOSURE_IMPORT_SCRIPT(this.path)?a.loaded():a.pause();else if(goog.inHtmlDocument_()){var d=goog.global.document,e=this;if(goog.isDocumentLoading_()){var f=b;goog.Dependency.defer_=
!0}else f=c;var g=goog.Dependency.registerCallback_(function(){goog.Dependency.unregisterCallback_(g);a.setModuleState(goog.ModuleType.ES6)});f(void 0,'goog.Dependency.callback_("'+g+'")');f(this.path,void 0);var h=goog.Dependency.registerCallback_(function(b){goog.Dependency.unregisterCallback_(h);a.registerEs6ModuleExports(e.path,b,goog.moduleLoaderState_.moduleName)});f(void 0,'import * as m from "'+this.path+'"; goog.Dependency.callback_("'+h+'", m)');var k=goog.Dependency.registerCallback_(function(){goog.Dependency.unregisterCallback_(k);
a.clearModuleState();a.loaded()});f(void 0,'goog.Dependency.callback_("'+k+'")')}else goog.logToConsole_("Cannot use default debug loader outside of HTML documents."),a.pause()},goog.TransformedDependency=function(a,b,c,d,e){goog.Dependency.call(this,a,b,c,d,e);this.contents_=null;this.lazyFetch_=!goog.inHtmlDocument_()||!("noModule"in goog.global.document.createElement("script"))},goog.inherits(goog.TransformedDependency,goog.Dependency),goog.TransformedDependency.prototype.load=function(a){function b(){e.contents_=
goog.loadFileSync_(e.path);e.contents_&&(e.contents_=e.transform(e.contents_),e.contents_&&(e.contents_+="\n//# sourceURL="+e.path))}function c(){e.lazyFetch_&&b();if(e.contents_){f&&a.setModuleState(goog.ModuleType.ES6);try{var c=e.contents_;e.contents_=null;goog.globalEval(c);if(f)var d=goog.moduleLoaderState_.moduleName}finally{f&&a.clearModuleState()}f&&goog.global.$jscomp.require.ensure([e.getPathName()],function(){a.registerEs6ModuleExports(e.path,goog.global.$jscomp.require(e.getPathName()),
d)});a.loaded()}}function d(){var a=goog.global.document,b=goog.Dependency.registerCallback_(function(){goog.Dependency.unregisterCallback_(b);c()}),d='<script type="text/javascript">'+goog.protectScriptTag_('goog.Dependency.callback_("'+b+'");')+"\x3c/script>";a.write(goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createHTML(d):d)}var e=this;if(goog.global.CLOSURE_IMPORT_SCRIPT)b(),this.contents_&&goog.global.CLOSURE_IMPORT_SCRIPT("",this.contents_)?(this.contents_=null,a.loaded()):a.pause();
else{var f=this.loadFlags.module==goog.ModuleType.ES6;this.lazyFetch_||b();var g=1<a.pending().length,h=g&&goog.DebugLoader_.IS_OLD_IE_;g=goog.Dependency.defer_&&(g||goog.isDocumentLoading_());if(h||g)a.defer(function(){c()});else{var k=goog.global.document;h=goog.inHtmlDocument_()&&"ActiveXObject"in goog.global;if(f&&goog.inHtmlDocument_()&&goog.isDocumentLoading_()&&!h){goog.Dependency.defer_=!0;a.pause();var l=k.onreadystatechange;k.onreadystatechange=function(){"interactive"==k.readyState&&(k.onreadystatechange=
l,c(),a.resume());goog.isFunction(l)&&l.apply(void 0,arguments)}}else!goog.DebugLoader_.IS_OLD_IE_&&goog.inHtmlDocument_()&&goog.isDocumentLoading_()?d():c()}}},goog.TransformedDependency.prototype.transform=function(a){},goog.TranspiledDependency=function(a,b,c,d,e,f){goog.TransformedDependency.call(this,a,b,c,d,e);this.transpiler=f},goog.inherits(goog.TranspiledDependency,goog.TransformedDependency),goog.TranspiledDependency.prototype.transform=function(a){return this.transpiler.transpile(a,this.getPathName())},
goog.PreTranspiledEs6ModuleDependency=function(a,b,c,d,e){goog.TransformedDependency.call(this,a,b,c,d,e)},goog.inherits(goog.PreTranspiledEs6ModuleDependency,goog.TransformedDependency),goog.PreTranspiledEs6ModuleDependency.prototype.transform=function(a){return a},goog.GoogModuleDependency=function(a,b,c,d,e,f,g){goog.TransformedDependency.call(this,a,b,c,d,e);this.needsTranspile_=f;this.transpiler_=g},goog.inherits(goog.GoogModuleDependency,goog.TransformedDependency),goog.GoogModuleDependency.prototype.transform=
function(a){this.needsTranspile_&&(a=this.transpiler_.transpile(a,this.getPathName()));return goog.LOAD_MODULE_USING_EVAL&&goog.isDef(goog.global.JSON)?"goog.loadModule("+goog.global.JSON.stringify(a+"\n//# sourceURL="+this.path+"\n")+");":'goog.loadModule(function(exports) {"use strict";'+a+"\n;return exports});\n//# sourceURL="+this.path+"\n"},goog.DebugLoader_.IS_OLD_IE_=!(goog.global.atob||!goog.global.document||!goog.global.document.all),goog.DebugLoader_.prototype.addDependency=function(a,b,
c,d){b=b||[];a=a.replace(/\\/g,"/");var e=goog.normalizePath_(goog.basePath+a);d&&"boolean"!==typeof d||(d=d?{module:goog.ModuleType.GOOG}:{});c=this.factory_.createDependency(e,a,b,c,d,goog.transpiler_.needsTranspile(d.lang||"es3",d.module));this.dependencies_[e]=c;for(c=0;c<b.length;c++)this.idToPath_[b[c]]=e;this.idToPath_[a]=e},goog.DependencyFactory=function(a){this.transpiler=a},goog.DependencyFactory.prototype.createDependency=function(a,b,c,d,e,f){return e.module==goog.ModuleType.GOOG?new goog.GoogModuleDependency(a,
b,c,d,e,f,this.transpiler):f?new goog.TranspiledDependency(a,b,c,d,e,this.transpiler):e.module==goog.ModuleType.ES6?"never"==goog.TRANSPILE&&goog.ASSUME_ES_MODULES_TRANSPILED?new goog.PreTranspiledEs6ModuleDependency(a,b,c,d,e):new goog.Es6ModuleDependency(a,b,c,d,e):new goog.Dependency(a,b,c,d,e)},goog.debugLoader_=new goog.DebugLoader_,goog.loadClosureDeps=function(){goog.debugLoader_.loadClosureDeps()},goog.setDependencyFactory=function(a){goog.debugLoader_.setDependencyFactory(a)},goog.global.CLOSURE_NO_DEPS||
goog.debugLoader_.loadClosureDeps(),goog.bootstrap=function(a,b){goog.debugLoader_.bootstrap(a,b)});goog.TRUSTED_TYPES_POLICY_NAME="";goog.identity_=function(a){return a};goog.createTrustedTypesPolicy=function(a){var b=null;if("undefined"===typeof TrustedTypes||!TrustedTypes.createPolicy)return b;try{b=TrustedTypes.createPolicy(a,{createHTML:goog.identity_,createScript:goog.identity_,createScriptURL:goog.identity_,createURL:goog.identity_})}catch(c){goog.logToConsole_(c.message)}return b};
goog.TRUSTED_TYPES_POLICY_=goog.TRUSTED_TYPES_POLICY_NAME?goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME+"#base"):null;goog.object={};goog.object.is=function(a,b){return a===b?0!==a||1/a===1/b:a!==a&&b!==b};goog.object.forEach=function(a,b,c){for(var d in a)b.call(c,a[d],d,a)};goog.object.filter=function(a,b,c){var d={},e;for(e in a)b.call(c,a[e],e,a)&&(d[e]=a[e]);return d};goog.object.map=function(a,b,c){var d={},e;for(e in a)d[e]=b.call(c,a[e],e,a);return d};goog.object.some=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return!0;return!1};
goog.object.every=function(a,b,c){for(var d in a)if(!b.call(c,a[d],d,a))return!1;return!0};goog.object.getCount=function(a){var b=0,c;for(c in a)b++;return b};goog.object.getAnyKey=function(a){for(var b in a)return b};goog.object.getAnyValue=function(a){for(var b in a)return a[b]};goog.object.contains=function(a,b){return goog.object.containsValue(a,b)};goog.object.getValues=function(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b};
goog.object.getKeys=function(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b};goog.object.getValueByKeys=function(a,b){var c=goog.isArrayLike(b),d=c?b:arguments;for(c=c?0:1;c<d.length;c++){if(null==a)return;a=a[d[c]]}return a};goog.object.containsKey=function(a,b){return null!==a&&b in a};goog.object.containsValue=function(a,b){for(var c in a)if(a[c]==b)return!0;return!1};goog.object.findKey=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d};
goog.object.findValue=function(a,b,c){return(b=goog.object.findKey(a,b,c))&&a[b]};goog.object.isEmpty=function(a){for(var b in a)return!1;return!0};goog.object.clear=function(a){for(var b in a)delete a[b]};goog.object.remove=function(a,b){var c;(c=b in a)&&delete a[b];return c};goog.object.add=function(a,b,c){if(null!==a&&b in a)throw Error('The object already contains the key "'+b+'"');goog.object.set(a,b,c)};goog.object.get=function(a,b,c){return null!==a&&b in a?a[b]:c};
goog.object.set=function(a,b,c){a[b]=c};goog.object.setIfUndefined=function(a,b,c){return b in a?a[b]:a[b]=c};goog.object.setWithReturnValueIfNotSet=function(a,b,c){if(b in a)return a[b];c=c();return a[b]=c};goog.object.equals=function(a,b){for(var c in a)if(!(c in b)||a[c]!==b[c])return!1;for(var d in b)if(!(d in a))return!1;return!0};goog.object.clone=function(a){var b={},c;for(c in a)b[c]=a[c];return b};
goog.object.unsafeClone=function(a){var b=goog.typeOf(a);if("object"==b||"array"==b){if(goog.isFunction(a.clone))return a.clone();b="array"==b?[]:{};for(var c in a)b[c]=goog.object.unsafeClone(a[c]);return b}return a};goog.object.transpose=function(a){var b={},c;for(c in a)b[a[c]]=c;return b};goog.object.PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
goog.object.extend=function(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<goog.object.PROTOTYPE_FIELDS_.length;f++)c=goog.object.PROTOTYPE_FIELDS_[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};
goog.object.create=function(a){var b=arguments.length;if(1==b&&goog.isArray(arguments[0]))return goog.object.create.apply(null,arguments[0]);if(b%2)throw Error("Uneven number of arguments");for(var c={},d=0;d<b;d+=2)c[arguments[d]]=arguments[d+1];return c};goog.object.createSet=function(a){var b=arguments.length;if(1==b&&goog.isArray(arguments[0]))return goog.object.createSet.apply(null,arguments[0]);for(var c={},d=0;d<b;d++)c[arguments[d]]=!0;return c};
goog.object.createImmutableView=function(a){var b=a;Object.isFrozen&&!Object.isFrozen(a)&&(b=Object.create(a),Object.freeze(b));return b};goog.object.isImmutableView=function(a){return!!Object.isFrozen&&Object.isFrozen(a)};
goog.object.getAllPropertyNames=function(a,b,c){if(!a)return[];if(!Object.getOwnPropertyNames||!Object.getPrototypeOf)return goog.object.getKeys(a);for(var d={};a&&(a!==Object.prototype||b)&&(a!==Function.prototype||c);){for(var e=Object.getOwnPropertyNames(a),f=0;f<e.length;f++)d[e[f]]=!0;a=Object.getPrototypeOf(a)}return goog.object.getKeys(d)};goog.object.getSuperClass=function(a){return(a=Object.getPrototypeOf(a.prototype))&&a.constructor};goog.debug={};goog.debug.Error=function(a){if(Error.captureStackTrace)Error.captureStackTrace(this,goog.debug.Error);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a));this.reportErrorToServer=!0};goog.inherits(goog.debug.Error,Error);goog.debug.Error.prototype.name="CustomError";goog.dom={};goog.dom.NodeType={ELEMENT:1,ATTRIBUTE:2,TEXT:3,CDATA_SECTION:4,ENTITY_REFERENCE:5,ENTITY:6,PROCESSING_INSTRUCTION:7,COMMENT:8,DOCUMENT:9,DOCUMENT_TYPE:10,DOCUMENT_FRAGMENT:11,NOTATION:12};goog.asserts={};goog.asserts.ENABLE_ASSERTS=goog.DEBUG;goog.asserts.AssertionError=function(a,b){goog.debug.Error.call(this,goog.asserts.subs_(a,b));this.messagePattern=a};goog.inherits(goog.asserts.AssertionError,goog.debug.Error);goog.asserts.AssertionError.prototype.name="AssertionError";goog.asserts.DEFAULT_ERROR_HANDLER=function(a){throw a;};goog.asserts.errorHandler_=goog.asserts.DEFAULT_ERROR_HANDLER;
goog.asserts.subs_=function(a,b){a=a.split("%s");for(var c="",d=a.length-1,e=0;e<d;e++)c+=a[e]+(e<b.length?b[e]:"%s");return c+a[d]};goog.asserts.doAssertFailure_=function(a,b,c,d){var e="Assertion failed";if(c){e+=": "+c;var f=d}else a&&(e+=": "+a,f=b);a=new goog.asserts.AssertionError(""+e,f||[]);goog.asserts.errorHandler_(a)};goog.asserts.setErrorHandler=function(a){goog.asserts.ENABLE_ASSERTS&&(goog.asserts.errorHandler_=a)};
goog.asserts.assert=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!a&&goog.asserts.doAssertFailure_("",null,b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertExists=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&null==a&&goog.asserts.doAssertFailure_("Expected to exist: %s.",[a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.fail=function(a,b){goog.asserts.ENABLE_ASSERTS&&goog.asserts.errorHandler_(new goog.asserts.AssertionError("Failure"+(a?": "+a:""),Array.prototype.slice.call(arguments,1)))};goog.asserts.assertNumber=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isNumber(a)&&goog.asserts.doAssertFailure_("Expected number but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertString=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isString(a)&&goog.asserts.doAssertFailure_("Expected string but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertFunction=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isFunction(a)&&goog.asserts.doAssertFailure_("Expected function but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertObject=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isObject(a)&&goog.asserts.doAssertFailure_("Expected object but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertArray=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isArray(a)&&goog.asserts.doAssertFailure_("Expected array but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertBoolean=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isBoolean(a)&&goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertElement=function(a,b,c){!goog.asserts.ENABLE_ASSERTS||goog.isObject(a)&&a.nodeType==goog.dom.NodeType.ELEMENT||goog.asserts.doAssertFailure_("Expected Element but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertInstanceof=function(a,b,c,d){!goog.asserts.ENABLE_ASSERTS||a instanceof b||goog.asserts.doAssertFailure_("Expected instanceof %s but got %s.",[goog.asserts.getType_(b),goog.asserts.getType_(a)],c,Array.prototype.slice.call(arguments,3));return a};goog.asserts.assertFinite=function(a,b,c){!goog.asserts.ENABLE_ASSERTS||"number"==typeof a&&isFinite(a)||goog.asserts.doAssertFailure_("Expected %s to be a finite number but it is not.",[a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertObjectPrototypeIsIntact=function(){for(var a in Object.prototype)goog.asserts.fail(a+" should not be enumerable in Object.prototype.")};goog.asserts.getType_=function(a){return a instanceof Function?a.displayName||a.name||"unknown type name":a instanceof Object?a.constructor.displayName||a.constructor.name||Object.prototype.toString.call(a):null===a?"null":typeof a};var jspb={BinaryConstants:{},ConstBinaryMessage:function(){},BinaryMessage:function(){}};jspb.BinaryConstants.FieldType={INVALID:-1,DOUBLE:1,FLOAT:2,INT64:3,UINT64:4,INT32:5,FIXED64:6,FIXED32:7,BOOL:8,STRING:9,GROUP:10,MESSAGE:11,BYTES:12,UINT32:13,ENUM:14,SFIXED32:15,SFIXED64:16,SINT32:17,SINT64:18,FHASH64:30,VHASH64:31};jspb.BinaryConstants.WireType={INVALID:-1,VARINT:0,FIXED64:1,DELIMITED:2,START_GROUP:3,END_GROUP:4,FIXED32:5};
jspb.BinaryConstants.FieldTypeToWireType=function(a){var b=jspb.BinaryConstants.FieldType,c=jspb.BinaryConstants.WireType;switch(a){case b.INT32:case b.INT64:case b.UINT32:case b.UINT64:case b.SINT32:case b.SINT64:case b.BOOL:case b.ENUM:case b.VHASH64:return c.VARINT;case b.DOUBLE:case b.FIXED64:case b.SFIXED64:case b.FHASH64:return c.FIXED64;case b.STRING:case b.MESSAGE:case b.BYTES:return c.DELIMITED;case b.FLOAT:case b.FIXED32:case b.SFIXED32:return c.FIXED32;default:return c.INVALID}};
jspb.BinaryConstants.INVALID_FIELD_NUMBER=-1;jspb.BinaryConstants.FLOAT32_EPS=1.401298464324817E-45;jspb.BinaryConstants.FLOAT32_MIN=1.1754943508222875E-38;jspb.BinaryConstants.FLOAT32_MAX=3.4028234663852886E38;jspb.BinaryConstants.FLOAT64_EPS=4.9E-324;jspb.BinaryConstants.FLOAT64_MIN=2.2250738585072014E-308;jspb.BinaryConstants.FLOAT64_MAX=1.7976931348623157E308;jspb.BinaryConstants.TWO_TO_20=1048576;jspb.BinaryConstants.TWO_TO_23=8388608;jspb.BinaryConstants.TWO_TO_31=2147483648;
jspb.BinaryConstants.TWO_TO_32=4294967296;jspb.BinaryConstants.TWO_TO_52=4503599627370496;jspb.BinaryConstants.TWO_TO_63=0x7fffffffffffffff;jspb.BinaryConstants.TWO_TO_64=1.8446744073709552E19;jspb.BinaryConstants.ZERO_HASH="\x00\x00\x00\x00\x00\x00\x00\x00";goog.array={};goog.NATIVE_ARRAY_PROTOTYPES=goog.TRUSTED_SITE;goog.array.ASSUME_NATIVE_FUNCTIONS=2012<goog.FEATURESET_YEAR;goog.array.peek=function(a){return a[a.length-1]};goog.array.last=goog.array.peek;
goog.array.indexOf=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.indexOf)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(goog.isString(a))return goog.isString(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1};
goog.array.lastIndexOf=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.lastIndexOf)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.lastIndexOf.call(a,b,null==c?a.length-1:c)}:function(a,b,c){c=null==c?a.length-1:c;0>c&&(c=Math.max(0,a.length+c));if(goog.isString(a))return goog.isString(b)&&1==b.length?a.lastIndexOf(b,c):-1;for(;0<=c;c--)if(c in a&&a[c]===b)return c;return-1};
goog.array.forEach=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.forEach)?function(a,b,c){goog.asserts.assert(null!=a.length);Array.prototype.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)};goog.array.forEachRight=function(a,b,c){var d=a.length,e=goog.isString(a)?a.split(""):a;for(--d;0<=d;--d)d in e&&b.call(c,e[d],d,a)};
goog.array.filter=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.filter)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,g=goog.isString(a)?a.split(""):a,h=0;h<d;h++)if(h in g){var k=g[h];b.call(c,k,h,a)&&(e[f++]=k)}return e};
goog.array.map=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.map)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=goog.isString(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e};
goog.array.reduce=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.reduce)?function(a,b,c,d){goog.asserts.assert(null!=a.length);d&&(b=goog.bind(b,d));return Array.prototype.reduce.call(a,b,c)}:function(a,b,c,d){var e=c;goog.array.forEach(a,function(c,g){e=b.call(d,e,c,g,a)});return e};
goog.array.reduceRight=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.reduceRight)?function(a,b,c,d){goog.asserts.assert(null!=a.length);goog.asserts.assert(null!=b);d&&(b=goog.bind(b,d));return Array.prototype.reduceRight.call(a,b,c)}:function(a,b,c,d){var e=c;goog.array.forEachRight(a,function(c,g){e=b.call(d,e,c,g,a)});return e};
goog.array.some=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.some)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.some.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return!0;return!1};
goog.array.every=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.every)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return!1;return!0};goog.array.count=function(a,b,c){var d=0;goog.array.forEach(a,function(a,f,g){b.call(c,a,f,g)&&++d},c);return d};
goog.array.find=function(a,b,c){b=goog.array.findIndex(a,b,c);return 0>b?null:goog.isString(a)?a.charAt(b):a[b]};goog.array.findIndex=function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return-1};goog.array.findRight=function(a,b,c){b=goog.array.findIndexRight(a,b,c);return 0>b?null:goog.isString(a)?a.charAt(b):a[b]};
goog.array.findIndexRight=function(a,b,c){var d=a.length,e=goog.isString(a)?a.split(""):a;for(--d;0<=d;d--)if(d in e&&b.call(c,e[d],d,a))return d;return-1};goog.array.contains=function(a,b){return 0<=goog.array.indexOf(a,b)};goog.array.isEmpty=function(a){return 0==a.length};goog.array.clear=function(a){if(!goog.isArray(a))for(var b=a.length-1;0<=b;b--)delete a[b];a.length=0};goog.array.insert=function(a,b){goog.array.contains(a,b)||a.push(b)};
goog.array.insertAt=function(a,b,c){goog.array.splice(a,c,0,b)};goog.array.insertArrayAt=function(a,b,c){goog.partial(goog.array.splice,a,c,0).apply(null,b)};goog.array.insertBefore=function(a,b,c){var d;2==arguments.length||0>(d=goog.array.indexOf(a,c))?a.push(b):goog.array.insertAt(a,b,d)};goog.array.remove=function(a,b){b=goog.array.indexOf(a,b);var c;(c=0<=b)&&goog.array.removeAt(a,b);return c};
goog.array.removeLast=function(a,b){b=goog.array.lastIndexOf(a,b);return 0<=b?(goog.array.removeAt(a,b),!0):!1};goog.array.removeAt=function(a,b){goog.asserts.assert(null!=a.length);return 1==Array.prototype.splice.call(a,b,1).length};goog.array.removeIf=function(a,b,c){b=goog.array.findIndex(a,b,c);return 0<=b?(goog.array.removeAt(a,b),!0):!1};goog.array.removeAllIf=function(a,b,c){var d=0;goog.array.forEachRight(a,function(e,f){b.call(c,e,f,a)&&goog.array.removeAt(a,f)&&d++});return d};
goog.array.concat=function(a){return Array.prototype.concat.apply([],arguments)};goog.array.join=function(a){return Array.prototype.concat.apply([],arguments)};goog.array.toArray=function(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return[]};goog.array.clone=goog.array.toArray;goog.array.extend=function(a,b){for(var c=1;c<arguments.length;c++){var d=arguments[c];if(goog.isArrayLike(d)){var e=a.length||0,f=d.length||0;a.length=e+f;for(var g=0;g<f;g++)a[e+g]=d[g]}else a.push(d)}};
goog.array.splice=function(a,b,c,d){goog.asserts.assert(null!=a.length);return Array.prototype.splice.apply(a,goog.array.slice(arguments,1))};goog.array.slice=function(a,b,c){goog.asserts.assert(null!=a.length);return 2>=arguments.length?Array.prototype.slice.call(a,b):Array.prototype.slice.call(a,b,c)};
goog.array.removeDuplicates=function(a,b,c){b=b||a;var d=function(a){return goog.isObject(a)?"o"+goog.getUid(a):(typeof a).charAt(0)+a};c=c||d;d={};for(var e=0,f=0;f<a.length;){var g=a[f++],h=c(g);Object.prototype.hasOwnProperty.call(d,h)||(d[h]=!0,b[e++]=g)}b.length=e};goog.array.binarySearch=function(a,b,c){return goog.array.binarySearch_(a,c||goog.array.defaultCompare,!1,b)};goog.array.binarySelect=function(a,b,c){return goog.array.binarySearch_(a,b,!0,void 0,c)};
goog.array.binarySearch_=function(a,b,c,d,e){for(var f=0,g=a.length,h;f<g;){var k=f+g>>1;var l=c?b.call(e,a[k],k,a):b(d,a[k]);0<l?f=k+1:(g=k,h=!l)}return h?f:~f};goog.array.sort=function(a,b){a.sort(b||goog.array.defaultCompare)};goog.array.stableSort=function(a,b){for(var c=Array(a.length),d=0;d<a.length;d++)c[d]={index:d,value:a[d]};var e=b||goog.array.defaultCompare;goog.array.sort(c,function(a,b){return e(a.value,b.value)||a.index-b.index});for(d=0;d<a.length;d++)a[d]=c[d].value};
goog.array.sortByKey=function(a,b,c){var d=c||goog.array.defaultCompare;goog.array.sort(a,function(a,c){return d(b(a),b(c))})};goog.array.sortObjectsByKey=function(a,b,c){goog.array.sortByKey(a,function(a){return a[b]},c)};goog.array.isSorted=function(a,b,c){b=b||goog.array.defaultCompare;for(var d=1;d<a.length;d++){var e=b(a[d-1],a[d]);if(0<e||0==e&&c)return!1}return!0};
goog.array.equals=function(a,b,c){if(!goog.isArrayLike(a)||!goog.isArrayLike(b)||a.length!=b.length)return!1;var d=a.length;c=c||goog.array.defaultCompareEquality;for(var e=0;e<d;e++)if(!c(a[e],b[e]))return!1;return!0};goog.array.compare3=function(a,b,c){c=c||goog.array.defaultCompare;for(var d=Math.min(a.length,b.length),e=0;e<d;e++){var f=c(a[e],b[e]);if(0!=f)return f}return goog.array.defaultCompare(a.length,b.length)};goog.array.defaultCompare=function(a,b){return a>b?1:a<b?-1:0};
goog.array.inverseDefaultCompare=function(a,b){return-goog.array.defaultCompare(a,b)};goog.array.defaultCompareEquality=function(a,b){return a===b};goog.array.binaryInsert=function(a,b,c){c=goog.array.binarySearch(a,b,c);return 0>c?(goog.array.insertAt(a,b,-(c+1)),!0):!1};goog.array.binaryRemove=function(a,b,c){b=goog.array.binarySearch(a,b,c);return 0<=b?goog.array.removeAt(a,b):!1};
goog.array.bucket=function(a,b,c){for(var d={},e=0;e<a.length;e++){var f=a[e],g=b.call(c,f,e,a);goog.isDef(g)&&(d[g]||(d[g]=[])).push(f)}return d};goog.array.toObject=function(a,b,c){var d={};goog.array.forEach(a,function(e,f){d[b.call(c,e,f,a)]=e});return d};goog.array.range=function(a,b,c){var d=[],e=0,f=a;c=c||1;void 0!==b&&(e=a,f=b);if(0>c*(f-e))return[];if(0<c)for(a=e;a<f;a+=c)d.push(a);else for(a=e;a>f;a+=c)d.push(a);return d};
goog.array.repeat=function(a,b){for(var c=[],d=0;d<b;d++)c[d]=a;return c};goog.array.flatten=function(a){for(var b=[],c=0;c<arguments.length;c++){var d=arguments[c];if(goog.isArray(d))for(var e=0;e<d.length;e+=8192){var f=goog.array.slice(d,e,e+8192);f=goog.array.flatten.apply(null,f);for(var g=0;g<f.length;g++)b.push(f[g])}else b.push(d)}return b};
goog.array.rotate=function(a,b){goog.asserts.assert(null!=a.length);a.length&&(b%=a.length,0<b?Array.prototype.unshift.apply(a,a.splice(-b,b)):0>b&&Array.prototype.push.apply(a,a.splice(0,-b)));return a};goog.array.moveItem=function(a,b,c){goog.asserts.assert(0<=b&&b<a.length);goog.asserts.assert(0<=c&&c<a.length);b=Array.prototype.splice.call(a,b,1);Array.prototype.splice.call(a,c,0,b[0])};
goog.array.zip=function(a){if(!arguments.length)return[];for(var b=[],c=arguments[0].length,d=1;d<arguments.length;d++)arguments[d].length<c&&(c=arguments[d].length);for(d=0;d<c;d++){for(var e=[],f=0;f<arguments.length;f++)e.push(arguments[f][d]);b.push(e)}return b};goog.array.shuffle=function(a,b){b=b||Math.random;for(var c=a.length-1;0<c;c--){var d=Math.floor(b()*(c+1)),e=a[c];a[c]=a[d];a[d]=e}};goog.array.copyByIndex=function(a,b){var c=[];goog.array.forEach(b,function(b){c.push(a[b])});return c};
goog.array.concatMap=function(a,b,c){return goog.array.concat.apply([],goog.array.map(a,b,c))};goog.crypt={};goog.crypt.stringToByteArray=function(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);255<e&&(b[c++]=e&255,e>>=8);b[c++]=e}return b};goog.crypt.byteArrayToString=function(a){if(8192>=a.length)return String.fromCharCode.apply(null,a);for(var b="",c=0;c<a.length;c+=8192){var d=goog.array.slice(a,c,c+8192);b+=String.fromCharCode.apply(null,d)}return b};
goog.crypt.byteArrayToHex=function(a,b){return goog.array.map(a,function(a){a=a.toString(16);return 1<a.length?a:"0"+a}).join(b||"")};goog.crypt.hexToByteArray=function(a){goog.asserts.assert(0==a.length%2,"Key string length must be multiple of 2");for(var b=[],c=0;c<a.length;c+=2)b.push(parseInt(a.substring(c,c+2),16));return b};
goog.crypt.stringToUtf8ByteArray=function(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);128>e?b[c++]=e:(2048>e?b[c++]=e>>6|192:(55296==(e&64512)&&d+1<a.length&&56320==(a.charCodeAt(d+1)&64512)?(e=65536+((e&1023)<<10)+(a.charCodeAt(++d)&1023),b[c++]=e>>18|240,b[c++]=e>>12&63|128):b[c++]=e>>12|224,b[c++]=e>>6&63|128),b[c++]=e&63|128)}return b};
goog.crypt.utf8ByteArrayToString=function(a){for(var b=[],c=0,d=0;c<a.length;){var e=a[c++];if(128>e)b[d++]=String.fromCharCode(e);else if(191<e&&224>e){var f=a[c++];b[d++]=String.fromCharCode((e&31)<<6|f&63)}else if(239<e&&365>e){f=a[c++];var g=a[c++],h=a[c++];e=((e&7)<<18|(f&63)<<12|(g&63)<<6|h&63)-65536;b[d++]=String.fromCharCode(55296+(e>>10));b[d++]=String.fromCharCode(56320+(e&1023))}else f=a[c++],g=a[c++],b[d++]=String.fromCharCode((e&15)<<12|(f&63)<<6|g&63)}return b.join("")};
goog.crypt.xorByteArray=function(a,b){goog.asserts.assert(a.length==b.length,"XOR array lengths must match");for(var c=[],d=0;d<a.length;d++)c.push(a[d]^b[d]);return c};goog.dom.asserts={};goog.dom.asserts.assertIsLocation=function(a){if(goog.asserts.ENABLE_ASSERTS){var b=goog.dom.asserts.getWindow_(a);b&&(!a||!(a instanceof b.Location)&&a instanceof b.Element)&&goog.asserts.fail("Argument is not a Location (or a non-Element mock); got: %s",goog.dom.asserts.debugStringForType_(a))}return a};
goog.dom.asserts.assertIsElementType_=function(a,b){if(goog.asserts.ENABLE_ASSERTS){var c=goog.dom.asserts.getWindow_(a);c&&"undefined"!=typeof c[b]&&(a&&(a instanceof c[b]||!(a instanceof c.Location||a instanceof c.Element))||goog.asserts.fail("Argument is not a %s (or a non-Element, non-Location mock); got: %s",b,goog.dom.asserts.debugStringForType_(a)))}return a};goog.dom.asserts.assertIsHTMLAnchorElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLAnchorElement")};
goog.dom.asserts.assertIsHTMLButtonElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLButtonElement")};goog.dom.asserts.assertIsHTMLLinkElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLLinkElement")};goog.dom.asserts.assertIsHTMLImageElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLImageElement")};goog.dom.asserts.assertIsHTMLAudioElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLAudioElement")};
goog.dom.asserts.assertIsHTMLVideoElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLVideoElement")};goog.dom.asserts.assertIsHTMLInputElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLInputElement")};goog.dom.asserts.assertIsHTMLTextAreaElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLTextAreaElement")};goog.dom.asserts.assertIsHTMLCanvasElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLCanvasElement")};
goog.dom.asserts.assertIsHTMLEmbedElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLEmbedElement")};goog.dom.asserts.assertIsHTMLFormElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLFormElement")};goog.dom.asserts.assertIsHTMLFrameElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLFrameElement")};goog.dom.asserts.assertIsHTMLIFrameElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLIFrameElement")};
goog.dom.asserts.assertIsHTMLObjectElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLObjectElement")};goog.dom.asserts.assertIsHTMLScriptElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLScriptElement")};
goog.dom.asserts.debugStringForType_=function(a){if(goog.isObject(a))try{return a.constructor.displayName||a.constructor.name||Object.prototype.toString.call(a)}catch(b){return"<object could not be stringified>"}else return void 0===a?"undefined":null===a?"null":typeof a};goog.dom.asserts.getWindow_=function(a){try{var b=a&&a.ownerDocument,c=b&&(b.defaultView||b.parentWindow);c=c||goog.global;if(c.Element&&c.Location)return c}catch(d){}return null};goog.functions={};goog.functions.constant=function(a){return function(){return a}};goog.functions.FALSE=function(){return!1};goog.functions.TRUE=function(){return!0};goog.functions.NULL=function(){return null};goog.functions.identity=function(a,b){return a};goog.functions.error=function(a){return function(){throw Error(a);}};goog.functions.fail=function(a){return function(){throw a;}};
goog.functions.lock=function(a,b){b=b||0;return function(){return a.apply(this,Array.prototype.slice.call(arguments,0,b))}};goog.functions.nth=function(a){return function(){return arguments[a]}};goog.functions.partialRight=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=Array.prototype.slice.call(arguments);b.push.apply(b,c);return a.apply(this,b)}};goog.functions.withReturnValue=function(a,b){return goog.functions.sequence(a,goog.functions.constant(b))};
goog.functions.equalTo=function(a,b){return function(c){return b?a==c:a===c}};goog.functions.compose=function(a,b){var c=arguments,d=c.length;return function(){var a;d&&(a=c[d-1].apply(this,arguments));for(var b=d-2;0<=b;b--)a=c[b].call(this,a);return a}};goog.functions.sequence=function(a){var b=arguments,c=b.length;return function(){for(var a,e=0;e<c;e++)a=b[e].apply(this,arguments);return a}};
goog.functions.and=function(a){var b=arguments,c=b.length;return function(){for(var a=0;a<c;a++)if(!b[a].apply(this,arguments))return!1;return!0}};goog.functions.or=function(a){var b=arguments,c=b.length;return function(){for(var a=0;a<c;a++)if(b[a].apply(this,arguments))return!0;return!1}};goog.functions.not=function(a){return function(){return!a.apply(this,arguments)}};
goog.functions.create=function(a,b){var c=function(){};c.prototype=a.prototype;c=new c;a.apply(c,Array.prototype.slice.call(arguments,1));return c};goog.functions.CACHE_RETURN_VALUE=!0;goog.functions.cacheReturnValue=function(a){var b=!1,c;return function(){if(!goog.functions.CACHE_RETURN_VALUE)return a();b||(c=a(),b=!0);return c}};goog.functions.once=function(a){var b=a;return function(){if(b){var a=b;b=null;a()}}};
goog.functions.debounce=function(a,b,c){var d=0;return function(e){goog.global.clearTimeout(d);var f=arguments;d=goog.global.setTimeout(function(){a.apply(c,f)},b)}};goog.functions.throttle=function(a,b,c){var d=0,e=!1,f=[],g=function(){d=0;e&&(e=!1,h())},h=function(){d=goog.global.setTimeout(g,b);a.apply(c,f)};return function(a){f=arguments;d?e=!0:h()}};goog.functions.rateLimit=function(a,b,c){var d=0,e=function(){d=0};return function(f){d||(d=goog.global.setTimeout(e,b),a.apply(c,arguments))}};goog.dom.HtmlElement=function(){};goog.dom.TagName=function(a){this.tagName_=a};goog.dom.TagName.prototype.toString=function(){return this.tagName_};goog.dom.TagName.A=new goog.dom.TagName("A");goog.dom.TagName.ABBR=new goog.dom.TagName("ABBR");goog.dom.TagName.ACRONYM=new goog.dom.TagName("ACRONYM");goog.dom.TagName.ADDRESS=new goog.dom.TagName("ADDRESS");goog.dom.TagName.APPLET=new goog.dom.TagName("APPLET");goog.dom.TagName.AREA=new goog.dom.TagName("AREA");goog.dom.TagName.ARTICLE=new goog.dom.TagName("ARTICLE");
goog.dom.TagName.ASIDE=new goog.dom.TagName("ASIDE");goog.dom.TagName.AUDIO=new goog.dom.TagName("AUDIO");goog.dom.TagName.B=new goog.dom.TagName("B");goog.dom.TagName.BASE=new goog.dom.TagName("BASE");goog.dom.TagName.BASEFONT=new goog.dom.TagName("BASEFONT");goog.dom.TagName.BDI=new goog.dom.TagName("BDI");goog.dom.TagName.BDO=new goog.dom.TagName("BDO");goog.dom.TagName.BIG=new goog.dom.TagName("BIG");goog.dom.TagName.BLOCKQUOTE=new goog.dom.TagName("BLOCKQUOTE");goog.dom.TagName.BODY=new goog.dom.TagName("BODY");
goog.dom.TagName.BR=new goog.dom.TagName("BR");goog.dom.TagName.BUTTON=new goog.dom.TagName("BUTTON");goog.dom.TagName.CANVAS=new goog.dom.TagName("CANVAS");goog.dom.TagName.CAPTION=new goog.dom.TagName("CAPTION");goog.dom.TagName.CENTER=new goog.dom.TagName("CENTER");goog.dom.TagName.CITE=new goog.dom.TagName("CITE");goog.dom.TagName.CODE=new goog.dom.TagName("CODE");goog.dom.TagName.COL=new goog.dom.TagName("COL");goog.dom.TagName.COLGROUP=new goog.dom.TagName("COLGROUP");
goog.dom.TagName.COMMAND=new goog.dom.TagName("COMMAND");goog.dom.TagName.DATA=new goog.dom.TagName("DATA");goog.dom.TagName.DATALIST=new goog.dom.TagName("DATALIST");goog.dom.TagName.DD=new goog.dom.TagName("DD");goog.dom.TagName.DEL=new goog.dom.TagName("DEL");goog.dom.TagName.DETAILS=new goog.dom.TagName("DETAILS");goog.dom.TagName.DFN=new goog.dom.TagName("DFN");goog.dom.TagName.DIALOG=new goog.dom.TagName("DIALOG");goog.dom.TagName.DIR=new goog.dom.TagName("DIR");goog.dom.TagName.DIV=new goog.dom.TagName("DIV");
goog.dom.TagName.DL=new goog.dom.TagName("DL");goog.dom.TagName.DT=new goog.dom.TagName("DT");goog.dom.TagName.EM=new goog.dom.TagName("EM");goog.dom.TagName.EMBED=new goog.dom.TagName("EMBED");goog.dom.TagName.FIELDSET=new goog.dom.TagName("FIELDSET");goog.dom.TagName.FIGCAPTION=new goog.dom.TagName("FIGCAPTION");goog.dom.TagName.FIGURE=new goog.dom.TagName("FIGURE");goog.dom.TagName.FONT=new goog.dom.TagName("FONT");goog.dom.TagName.FOOTER=new goog.dom.TagName("FOOTER");goog.dom.TagName.FORM=new goog.dom.TagName("FORM");
goog.dom.TagName.FRAME=new goog.dom.TagName("FRAME");goog.dom.TagName.FRAMESET=new goog.dom.TagName("FRAMESET");goog.dom.TagName.H1=new goog.dom.TagName("H1");goog.dom.TagName.H2=new goog.dom.TagName("H2");goog.dom.TagName.H3=new goog.dom.TagName("H3");goog.dom.TagName.H4=new goog.dom.TagName("H4");goog.dom.TagName.H5=new goog.dom.TagName("H5");goog.dom.TagName.H6=new goog.dom.TagName("H6");goog.dom.TagName.HEAD=new goog.dom.TagName("HEAD");goog.dom.TagName.HEADER=new goog.dom.TagName("HEADER");
goog.dom.TagName.HGROUP=new goog.dom.TagName("HGROUP");goog.dom.TagName.HR=new goog.dom.TagName("HR");goog.dom.TagName.HTML=new goog.dom.TagName("HTML");goog.dom.TagName.I=new goog.dom.TagName("I");goog.dom.TagName.IFRAME=new goog.dom.TagName("IFRAME");goog.dom.TagName.IMG=new goog.dom.TagName("IMG");goog.dom.TagName.INPUT=new goog.dom.TagName("INPUT");goog.dom.TagName.INS=new goog.dom.TagName("INS");goog.dom.TagName.ISINDEX=new goog.dom.TagName("ISINDEX");goog.dom.TagName.KBD=new goog.dom.TagName("KBD");
goog.dom.TagName.KEYGEN=new goog.dom.TagName("KEYGEN");goog.dom.TagName.LABEL=new goog.dom.TagName("LABEL");goog.dom.TagName.LEGEND=new goog.dom.TagName("LEGEND");goog.dom.TagName.LI=new goog.dom.TagName("LI");goog.dom.TagName.LINK=new goog.dom.TagName("LINK");goog.dom.TagName.MAIN=new goog.dom.TagName("MAIN");goog.dom.TagName.MAP=new goog.dom.TagName("MAP");goog.dom.TagName.MARK=new goog.dom.TagName("MARK");goog.dom.TagName.MATH=new goog.dom.TagName("MATH");goog.dom.TagName.MENU=new goog.dom.TagName("MENU");
goog.dom.TagName.MENUITEM=new goog.dom.TagName("MENUITEM");goog.dom.TagName.META=new goog.dom.TagName("META");goog.dom.TagName.METER=new goog.dom.TagName("METER");goog.dom.TagName.NAV=new goog.dom.TagName("NAV");goog.dom.TagName.NOFRAMES=new goog.dom.TagName("NOFRAMES");goog.dom.TagName.NOSCRIPT=new goog.dom.TagName("NOSCRIPT");goog.dom.TagName.OBJECT=new goog.dom.TagName("OBJECT");goog.dom.TagName.OL=new goog.dom.TagName("OL");goog.dom.TagName.OPTGROUP=new goog.dom.TagName("OPTGROUP");
goog.dom.TagName.OPTION=new goog.dom.TagName("OPTION");goog.dom.TagName.OUTPUT=new goog.dom.TagName("OUTPUT");goog.dom.TagName.P=new goog.dom.TagName("P");goog.dom.TagName.PARAM=new goog.dom.TagName("PARAM");goog.dom.TagName.PICTURE=new goog.dom.TagName("PICTURE");goog.dom.TagName.PRE=new goog.dom.TagName("PRE");goog.dom.TagName.PROGRESS=new goog.dom.TagName("PROGRESS");goog.dom.TagName.Q=new goog.dom.TagName("Q");goog.dom.TagName.RP=new goog.dom.TagName("RP");goog.dom.TagName.RT=new goog.dom.TagName("RT");
goog.dom.TagName.RTC=new goog.dom.TagName("RTC");goog.dom.TagName.RUBY=new goog.dom.TagName("RUBY");goog.dom.TagName.S=new goog.dom.TagName("S");goog.dom.TagName.SAMP=new goog.dom.TagName("SAMP");goog.dom.TagName.SCRIPT=new goog.dom.TagName("SCRIPT");goog.dom.TagName.SECTION=new goog.dom.TagName("SECTION");goog.dom.TagName.SELECT=new goog.dom.TagName("SELECT");goog.dom.TagName.SMALL=new goog.dom.TagName("SMALL");goog.dom.TagName.SOURCE=new goog.dom.TagName("SOURCE");goog.dom.TagName.SPAN=new goog.dom.TagName("SPAN");
goog.dom.TagName.STRIKE=new goog.dom.TagName("STRIKE");goog.dom.TagName.STRONG=new goog.dom.TagName("STRONG");goog.dom.TagName.STYLE=new goog.dom.TagName("STYLE");goog.dom.TagName.SUB=new goog.dom.TagName("SUB");goog.dom.TagName.SUMMARY=new goog.dom.TagName("SUMMARY");goog.dom.TagName.SUP=new goog.dom.TagName("SUP");goog.dom.TagName.SVG=new goog.dom.TagName("SVG");goog.dom.TagName.TABLE=new goog.dom.TagName("TABLE");goog.dom.TagName.TBODY=new goog.dom.TagName("TBODY");goog.dom.TagName.TD=new goog.dom.TagName("TD");
goog.dom.TagName.TEMPLATE=new goog.dom.TagName("TEMPLATE");goog.dom.TagName.TEXTAREA=new goog.dom.TagName("TEXTAREA");goog.dom.TagName.TFOOT=new goog.dom.TagName("TFOOT");goog.dom.TagName.TH=new goog.dom.TagName("TH");goog.dom.TagName.THEAD=new goog.dom.TagName("THEAD");goog.dom.TagName.TIME=new goog.dom.TagName("TIME");goog.dom.TagName.TITLE=new goog.dom.TagName("TITLE");goog.dom.TagName.TR=new goog.dom.TagName("TR");goog.dom.TagName.TRACK=new goog.dom.TagName("TRACK");goog.dom.TagName.TT=new goog.dom.TagName("TT");
goog.dom.TagName.U=new goog.dom.TagName("U");goog.dom.TagName.UL=new goog.dom.TagName("UL");goog.dom.TagName.VAR=new goog.dom.TagName("VAR");goog.dom.TagName.VIDEO=new goog.dom.TagName("VIDEO");goog.dom.TagName.WBR=new goog.dom.TagName("WBR");goog.dom.tags={};goog.dom.tags.VOID_TAGS_={area:!0,base:!0,br:!0,col:!0,command:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0};goog.dom.tags.isVoidTag=function(a){return!0===goog.dom.tags.VOID_TAGS_[a]};goog.html={};goog.html.trustedtypes={};goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY=goog.TRUSTED_TYPES_POLICY_NAME?goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME+"#html"):null;goog.string={};goog.string.TypedString=function(){};goog.string.Const=function(a,b){this.stringConstValueWithSecurityContract__googStringSecurityPrivate_=a===goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_&&b||"";this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_=goog.string.Const.TYPE_MARKER_};goog.string.Const.prototype.implementsGoogStringTypedString=!0;goog.string.Const.prototype.getTypedStringValue=function(){return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_};
goog.string.Const.prototype.toString=function(){return"Const{"+this.stringConstValueWithSecurityContract__googStringSecurityPrivate_+"}"};goog.string.Const.unwrap=function(a){if(a instanceof goog.string.Const&&a.constructor===goog.string.Const&&a.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_===goog.string.Const.TYPE_MARKER_)return a.stringConstValueWithSecurityContract__googStringSecurityPrivate_;goog.asserts.fail("expected object of type Const, got '"+a+"'");return"type_error:Const"};
goog.string.Const.from=function(a){return new goog.string.Const(goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_,a)};goog.string.Const.TYPE_MARKER_={};goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_={};goog.string.Const.EMPTY=goog.string.Const.from("");goog.html.SafeScript=function(){this.privateDoNotAccessOrElseSafeScriptWrappedValue_="";this.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_};goog.html.SafeScript.prototype.implementsGoogStringTypedString=!0;goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog.html.SafeScript.fromConstant=function(a){a=goog.string.Const.unwrap(a);return 0===a.length?goog.html.SafeScript.EMPTY:goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeScript.fromConstantAndArgs=function(a,b){for(var c=[],d=1;d<arguments.length;d++)c.push(goog.html.SafeScript.stringify_(arguments[d]));return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("("+goog.string.Const.unwrap(a)+")("+c.join(", ")+");")};goog.html.SafeScript.fromJson=function(a){return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(goog.html.SafeScript.stringify_(a))};goog.html.SafeScript.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeScriptWrappedValue_.toString()};
goog.DEBUG&&(goog.html.SafeScript.prototype.toString=function(){return"SafeScript{"+this.privateDoNotAccessOrElseSafeScriptWrappedValue_+"}"});goog.html.SafeScript.unwrap=function(a){return goog.html.SafeScript.unwrapTrustedScript(a).toString()};
goog.html.SafeScript.unwrapTrustedScript=function(a){if(a instanceof goog.html.SafeScript&&a.constructor===goog.html.SafeScript&&a.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeScriptWrappedValue_;goog.asserts.fail("expected object of type SafeScript, got '"+a+"' of type "+goog.typeOf(a));return"type_error:SafeScript"};
goog.html.SafeScript.stringify_=function(a){return JSON.stringify(a).replace(/</g,"\\x3c")};goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse=function(a){return(new goog.html.SafeScript).initSecurityPrivateDoNotAccessOrElse_(a)};
goog.html.SafeScript.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeScriptWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScript(a):a;return this};goog.html.SafeScript.EMPTY=goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("");goog.fs={};goog.fs.url={};goog.fs.url.createObjectUrl=function(a){return goog.fs.url.getUrlObject_().createObjectURL(a)};goog.fs.url.revokeObjectUrl=function(a){goog.fs.url.getUrlObject_().revokeObjectURL(a)};goog.fs.url.getUrlObject_=function(){var a=goog.fs.url.findUrlObject_();if(null!=a)return a;throw Error("This browser doesn't seem to support blob URLs");};
goog.fs.url.findUrlObject_=function(){return goog.isDef(goog.global.URL)&&goog.isDef(goog.global.URL.createObjectURL)?goog.global.URL:goog.isDef(goog.global.webkitURL)&&goog.isDef(goog.global.webkitURL.createObjectURL)?goog.global.webkitURL:goog.isDef(goog.global.createObjectURL)?goog.global:null};goog.fs.url.browserSupportsObjectUrls=function(){return null!=goog.fs.url.findUrlObject_()};goog.i18n={};goog.i18n.bidi={};goog.i18n.bidi.FORCE_RTL=!1;
goog.i18n.bidi.IS_RTL=goog.i18n.bidi.FORCE_RTL||("ar"==goog.LOCALE.substring(0,2).toLowerCase()||"fa"==goog.LOCALE.substring(0,2).toLowerCase()||"he"==goog.LOCALE.substring(0,2).toLowerCase()||"iw"==goog.LOCALE.substring(0,2).toLowerCase()||"ps"==goog.LOCALE.substring(0,2).toLowerCase()||"sd"==goog.LOCALE.substring(0,2).toLowerCase()||"ug"==goog.LOCALE.substring(0,2).toLowerCase()||"ur"==goog.LOCALE.substring(0,2).toLowerCase()||"yi"==goog.LOCALE.substring(0,2).toLowerCase())&&(2==goog.LOCALE.length||
"-"==goog.LOCALE.substring(2,3)||"_"==goog.LOCALE.substring(2,3))||3<=goog.LOCALE.length&&"ckb"==goog.LOCALE.substring(0,3).toLowerCase()&&(3==goog.LOCALE.length||"-"==goog.LOCALE.substring(3,4)||"_"==goog.LOCALE.substring(3,4))||7<=goog.LOCALE.length&&("-"==goog.LOCALE.substring(2,3)||"_"==goog.LOCALE.substring(2,3))&&("adlm"==goog.LOCALE.substring(3,7).toLowerCase()||"arab"==goog.LOCALE.substring(3,7).toLowerCase()||"hebr"==goog.LOCALE.substring(3,7).toLowerCase()||"nkoo"==goog.LOCALE.substring(3,
7).toLowerCase()||"rohg"==goog.LOCALE.substring(3,7).toLowerCase()||"thaa"==goog.LOCALE.substring(3,7).toLowerCase())||8<=goog.LOCALE.length&&("-"==goog.LOCALE.substring(3,4)||"_"==goog.LOCALE.substring(3,4))&&("adlm"==goog.LOCALE.substring(4,8).toLowerCase()||"arab"==goog.LOCALE.substring(4,8).toLowerCase()||"hebr"==goog.LOCALE.substring(4,8).toLowerCase()||"nkoo"==goog.LOCALE.substring(4,8).toLowerCase()||"rohg"==goog.LOCALE.substring(4,8).toLowerCase()||"thaa"==goog.LOCALE.substring(4,8).toLowerCase());
goog.i18n.bidi.Format={LRE:"\u202a",RLE:"\u202b",PDF:"\u202c",LRM:"\u200e",RLM:"\u200f"};goog.i18n.bidi.Dir={LTR:1,RTL:-1,NEUTRAL:0};goog.i18n.bidi.RIGHT="right";goog.i18n.bidi.LEFT="left";goog.i18n.bidi.I18N_RIGHT=goog.i18n.bidi.IS_RTL?goog.i18n.bidi.LEFT:goog.i18n.bidi.RIGHT;goog.i18n.bidi.I18N_LEFT=goog.i18n.bidi.IS_RTL?goog.i18n.bidi.RIGHT:goog.i18n.bidi.LEFT;
goog.i18n.bidi.toDir=function(a,b){return"number"==typeof a?0<a?goog.i18n.bidi.Dir.LTR:0>a?goog.i18n.bidi.Dir.RTL:b?null:goog.i18n.bidi.Dir.NEUTRAL:null==a?null:a?goog.i18n.bidi.Dir.RTL:goog.i18n.bidi.Dir.LTR};goog.i18n.bidi.ltrChars_="A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0900-\u1fff\u200e\u2c00-\ud801\ud804-\ud839\ud83c-\udbff\uf900-\ufb1c\ufe00-\ufe6f\ufefd-\uffff";goog.i18n.bidi.rtlChars_="\u0591-\u06ef\u06fa-\u08ff\u200f\ud802-\ud803\ud83a-\ud83b\ufb1d-\ufdff\ufe70-\ufefc";
goog.i18n.bidi.htmlSkipReg_=/<[^>]*>|&[^;]+;/g;goog.i18n.bidi.stripHtmlIfNeeded_=function(a,b){return b?a.replace(goog.i18n.bidi.htmlSkipReg_,""):a};goog.i18n.bidi.rtlCharReg_=new RegExp("["+goog.i18n.bidi.rtlChars_+"]");goog.i18n.bidi.ltrCharReg_=new RegExp("["+goog.i18n.bidi.ltrChars_+"]");goog.i18n.bidi.hasAnyRtl=function(a,b){return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.hasRtlChar=goog.i18n.bidi.hasAnyRtl;
goog.i18n.bidi.hasAnyLtr=function(a,b){return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.ltrRe_=new RegExp("^["+goog.i18n.bidi.ltrChars_+"]");goog.i18n.bidi.rtlRe_=new RegExp("^["+goog.i18n.bidi.rtlChars_+"]");goog.i18n.bidi.isRtlChar=function(a){return goog.i18n.bidi.rtlRe_.test(a)};goog.i18n.bidi.isLtrChar=function(a){return goog.i18n.bidi.ltrRe_.test(a)};goog.i18n.bidi.isNeutralChar=function(a){return!goog.i18n.bidi.isLtrChar(a)&&!goog.i18n.bidi.isRtlChar(a)};
goog.i18n.bidi.ltrDirCheckRe_=new RegExp("^[^"+goog.i18n.bidi.rtlChars_+"]*["+goog.i18n.bidi.ltrChars_+"]");goog.i18n.bidi.rtlDirCheckRe_=new RegExp("^[^"+goog.i18n.bidi.ltrChars_+"]*["+goog.i18n.bidi.rtlChars_+"]");goog.i18n.bidi.startsWithRtl=function(a,b){return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isRtlText=goog.i18n.bidi.startsWithRtl;
goog.i18n.bidi.startsWithLtr=function(a,b){return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isLtrText=goog.i18n.bidi.startsWithLtr;goog.i18n.bidi.isRequiredLtrRe_=/^http:\/\/.*/;goog.i18n.bidi.isNeutralText=function(a,b){a=goog.i18n.bidi.stripHtmlIfNeeded_(a,b);return goog.i18n.bidi.isRequiredLtrRe_.test(a)||!goog.i18n.bidi.hasAnyLtr(a)&&!goog.i18n.bidi.hasAnyRtl(a)};
goog.i18n.bidi.ltrExitDirCheckRe_=new RegExp("["+goog.i18n.bidi.ltrChars_+"][^"+goog.i18n.bidi.rtlChars_+"]*$");goog.i18n.bidi.rtlExitDirCheckRe_=new RegExp("["+goog.i18n.bidi.rtlChars_+"][^"+goog.i18n.bidi.ltrChars_+"]*$");goog.i18n.bidi.endsWithLtr=function(a,b){return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isLtrExitText=goog.i18n.bidi.endsWithLtr;
goog.i18n.bidi.endsWithRtl=function(a,b){return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isRtlExitText=goog.i18n.bidi.endsWithRtl;goog.i18n.bidi.rtlLocalesRe_=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;goog.i18n.bidi.isRtlLanguage=function(a){return goog.i18n.bidi.rtlLocalesRe_.test(a)};goog.i18n.bidi.bracketGuardTextRe_=/(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g;
goog.i18n.bidi.guardBracketInText=function(a,b){b=(void 0===b?goog.i18n.bidi.hasAnyRtl(a):b)?goog.i18n.bidi.Format.RLM:goog.i18n.bidi.Format.LRM;return a.replace(goog.i18n.bidi.bracketGuardTextRe_,b+"$&"+b)};goog.i18n.bidi.enforceRtlInHtml=function(a){return"<"==a.charAt(0)?a.replace(/<\w+/,"$& dir=rtl"):"\n<span dir=rtl>"+a+"</span>"};goog.i18n.bidi.enforceRtlInText=function(a){return goog.i18n.bidi.Format.RLE+a+goog.i18n.bidi.Format.PDF};
goog.i18n.bidi.enforceLtrInHtml=function(a){return"<"==a.charAt(0)?a.replace(/<\w+/,"$& dir=ltr"):"\n<span dir=ltr>"+a+"</span>"};goog.i18n.bidi.enforceLtrInText=function(a){return goog.i18n.bidi.Format.LRE+a+goog.i18n.bidi.Format.PDF};goog.i18n.bidi.dimensionsRe_=/:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g;goog.i18n.bidi.leftRe_=/left/gi;goog.i18n.bidi.rightRe_=/right/gi;goog.i18n.bidi.tempRe_=/%%%%/g;
goog.i18n.bidi.mirrorCSS=function(a){return a.replace(goog.i18n.bidi.dimensionsRe_,":$1 $4 $3 $2").replace(goog.i18n.bidi.leftRe_,"%%%%").replace(goog.i18n.bidi.rightRe_,goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_,goog.i18n.bidi.RIGHT)};goog.i18n.bidi.doubleQuoteSubstituteRe_=/([\u0591-\u05f2])"/g;goog.i18n.bidi.singleQuoteSubstituteRe_=/([\u0591-\u05f2])'/g;
goog.i18n.bidi.normalizeHebrewQuote=function(a){return a.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_,"$1\u05f4").replace(goog.i18n.bidi.singleQuoteSubstituteRe_,"$1\u05f3")};goog.i18n.bidi.wordSeparatorRe_=/\s+/;goog.i18n.bidi.hasNumeralsRe_=/[\d\u06f0-\u06f9]/;goog.i18n.bidi.rtlDetectionThreshold_=.4;
goog.i18n.bidi.estimateDirection=function(a,b){var c=0,d=0,e=!1;a=goog.i18n.bidi.stripHtmlIfNeeded_(a,b).split(goog.i18n.bidi.wordSeparatorRe_);for(b=0;b<a.length;b++){var f=a[b];goog.i18n.bidi.startsWithRtl(f)?(c++,d++):goog.i18n.bidi.isRequiredLtrRe_.test(f)?e=!0:goog.i18n.bidi.hasAnyLtr(f)?d++:goog.i18n.bidi.hasNumeralsRe_.test(f)&&(e=!0)}return 0==d?e?goog.i18n.bidi.Dir.LTR:goog.i18n.bidi.Dir.NEUTRAL:c/d>goog.i18n.bidi.rtlDetectionThreshold_?goog.i18n.bidi.Dir.RTL:goog.i18n.bidi.Dir.LTR};
goog.i18n.bidi.detectRtlDirectionality=function(a,b){return goog.i18n.bidi.estimateDirection(a,b)==goog.i18n.bidi.Dir.RTL};goog.i18n.bidi.setElementDirAndAlign=function(a,b){a&&(b=goog.i18n.bidi.toDir(b))&&(a.style.textAlign=b==goog.i18n.bidi.Dir.RTL?goog.i18n.bidi.RIGHT:goog.i18n.bidi.LEFT,a.dir=b==goog.i18n.bidi.Dir.RTL?"rtl":"ltr")};
goog.i18n.bidi.setElementDirByTextDirectionality=function(a,b){switch(goog.i18n.bidi.estimateDirection(b)){case goog.i18n.bidi.Dir.LTR:a.dir="ltr";break;case goog.i18n.bidi.Dir.RTL:a.dir="rtl";break;default:a.removeAttribute("dir")}};goog.i18n.bidi.DirectionalString=function(){};goog.html.TrustedResourceUrl=function(){this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_="";this.trustedURL_=null;this.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_};goog.html.TrustedResourceUrl.prototype.implementsGoogStringTypedString=!0;goog.html.TrustedResourceUrl.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_.toString()};
goog.html.TrustedResourceUrl.prototype.implementsGoogI18nBidiDirectionalString=!0;goog.html.TrustedResourceUrl.prototype.getDirection=function(){return goog.i18n.bidi.Dir.LTR};
goog.html.TrustedResourceUrl.prototype.cloneWithParams=function(a,b){var c=goog.html.TrustedResourceUrl.unwrap(this);c=goog.html.TrustedResourceUrl.URL_PARAM_PARSER_.exec(c);var d=c[3]||"";return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(c[1]+goog.html.TrustedResourceUrl.stringifyParams_("?",c[2]||"",a)+goog.html.TrustedResourceUrl.stringifyParams_("#",d,b))};
goog.DEBUG&&(goog.html.TrustedResourceUrl.prototype.toString=function(){return"TrustedResourceUrl{"+this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_+"}"});goog.html.TrustedResourceUrl.unwrap=function(a){return goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(a).toString()};
goog.html.TrustedResourceUrl.unwrapTrustedScriptURL=function(a){if(a instanceof goog.html.TrustedResourceUrl&&a.constructor===goog.html.TrustedResourceUrl&&a.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_;goog.asserts.fail("expected object of type TrustedResourceUrl, got '"+a+"' of type "+goog.typeOf(a));return"type_error:TrustedResourceUrl"};
goog.html.TrustedResourceUrl.unwrapTrustedURL=function(a){return a.trustedURL_?a.trustedURL_:goog.html.TrustedResourceUrl.unwrap(a)};
goog.html.TrustedResourceUrl.format=function(a,b){var c=goog.string.Const.unwrap(a);if(!goog.html.TrustedResourceUrl.BASE_URL_.test(c))throw Error("Invalid TrustedResourceUrl format: "+c);a=c.replace(goog.html.TrustedResourceUrl.FORMAT_MARKER_,function(a,e){if(!Object.prototype.hasOwnProperty.call(b,e))throw Error('Found marker, "'+e+'", in format string, "'+c+'", but no valid label mapping found in args: '+JSON.stringify(b));a=b[e];return a instanceof goog.string.Const?goog.string.Const.unwrap(a):
encodeURIComponent(String(a))});return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(a)};goog.html.TrustedResourceUrl.FORMAT_MARKER_=/%{(\w+)}/g;goog.html.TrustedResourceUrl.BASE_URL_=/^((https:)?\/\/[0-9a-z.:[\]-]+\/|\/[^/\\]|[^:/\\%]+\/|[^:/\\%]*[?#]|about:blank#)/i;goog.html.TrustedResourceUrl.URL_PARAM_PARSER_=/^([^?#]*)(\?[^#]*)?(#[\s\S]*)?/;
goog.html.TrustedResourceUrl.formatWithParams=function(a,b,c,d){return goog.html.TrustedResourceUrl.format(a,b).cloneWithParams(c,d)};goog.html.TrustedResourceUrl.fromConstant=function(a){return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(a))};goog.html.TrustedResourceUrl.fromConstants=function(a){for(var b="",c=0;c<a.length;c++)b+=goog.string.Const.unwrap(a[c]);return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(b)};
goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse=function(a){var b=new goog.html.TrustedResourceUrl;b.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScriptURL(a):a;goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY&&(b.trustedURL_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createURL(a));return b};
goog.html.TrustedResourceUrl.stringifyParams_=function(a,b,c){if(null==c)return b;if(goog.isString(c))return c?a+encodeURIComponent(c):"";for(var d in c){var e=c[d];e=goog.isArray(e)?e:[e];for(var f=0;f<e.length;f++){var g=e[f];null!=g&&(b||(b=a),b+=(b.length>a.length?"&":"")+encodeURIComponent(d)+"="+encodeURIComponent(String(g)))}}return b};goog.string.internal={};goog.string.internal.startsWith=function(a,b){return 0==a.lastIndexOf(b,0)};goog.string.internal.endsWith=function(a,b){var c=a.length-b.length;return 0<=c&&a.indexOf(b,c)==c};goog.string.internal.caseInsensitiveStartsWith=function(a,b){return 0==goog.string.internal.caseInsensitiveCompare(b,a.substr(0,b.length))};goog.string.internal.caseInsensitiveEndsWith=function(a,b){return 0==goog.string.internal.caseInsensitiveCompare(b,a.substr(a.length-b.length,b.length))};
goog.string.internal.caseInsensitiveEquals=function(a,b){return a.toLowerCase()==b.toLowerCase()};goog.string.internal.isEmptyOrWhitespace=function(a){return/^[\s\xa0]*$/.test(a)};goog.string.internal.trim=goog.TRUSTED_SITE&&String.prototype.trim?function(a){return a.trim()}:function(a){return/^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1]};goog.string.internal.caseInsensitiveCompare=function(a,b){a=String(a).toLowerCase();b=String(b).toLowerCase();return a<b?-1:a==b?0:1};
goog.string.internal.newLineToBr=function(a,b){return a.replace(/(\r\n|\r|\n)/g,b?"<br />":"<br>")};
goog.string.internal.htmlEscape=function(a,b){if(b)a=a.replace(goog.string.internal.AMP_RE_,"&amp;").replace(goog.string.internal.LT_RE_,"&lt;").replace(goog.string.internal.GT_RE_,"&gt;").replace(goog.string.internal.QUOT_RE_,"&quot;").replace(goog.string.internal.SINGLE_QUOTE_RE_,"&#39;").replace(goog.string.internal.NULL_RE_,"&#0;");else{if(!goog.string.internal.ALL_RE_.test(a))return a;-1!=a.indexOf("&")&&(a=a.replace(goog.string.internal.AMP_RE_,"&amp;"));-1!=a.indexOf("<")&&(a=a.replace(goog.string.internal.LT_RE_,
"&lt;"));-1!=a.indexOf(">")&&(a=a.replace(goog.string.internal.GT_RE_,"&gt;"));-1!=a.indexOf('"')&&(a=a.replace(goog.string.internal.QUOT_RE_,"&quot;"));-1!=a.indexOf("'")&&(a=a.replace(goog.string.internal.SINGLE_QUOTE_RE_,"&#39;"));-1!=a.indexOf("\x00")&&(a=a.replace(goog.string.internal.NULL_RE_,"&#0;"))}return a};goog.string.internal.AMP_RE_=/&/g;goog.string.internal.LT_RE_=/</g;goog.string.internal.GT_RE_=/>/g;goog.string.internal.QUOT_RE_=/"/g;goog.string.internal.SINGLE_QUOTE_RE_=/'/g;
goog.string.internal.NULL_RE_=/\x00/g;goog.string.internal.ALL_RE_=/[\x00&<>"']/;goog.string.internal.whitespaceEscape=function(a,b){return goog.string.internal.newLineToBr(a.replace(/  /g," &#160;"),b)};goog.string.internal.contains=function(a,b){return-1!=a.indexOf(b)};goog.string.internal.caseInsensitiveContains=function(a,b){return goog.string.internal.contains(a.toLowerCase(),b.toLowerCase())};
goog.string.internal.compareVersions=function(a,b){var c=0;a=goog.string.internal.trim(String(a)).split(".");b=goog.string.internal.trim(String(b)).split(".");for(var d=Math.max(a.length,b.length),e=0;0==c&&e<d;e++){var f=a[e]||"",g=b[e]||"";do{f=/(\d*)(\D*)(.*)/.exec(f)||["","","",""];g=/(\d*)(\D*)(.*)/.exec(g)||["","","",""];if(0==f[0].length&&0==g[0].length)break;c=0==f[1].length?0:parseInt(f[1],10);var h=0==g[1].length?0:parseInt(g[1],10);c=goog.string.internal.compareElements_(c,h)||goog.string.internal.compareElements_(0==
f[2].length,0==g[2].length)||goog.string.internal.compareElements_(f[2],g[2]);f=f[3];g=g[3]}while(0==c)}return c};goog.string.internal.compareElements_=function(a,b){return a<b?-1:a>b?1:0};goog.html.SafeUrl=function(){this.privateDoNotAccessOrElseSafeUrlWrappedValue_="";this.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_};goog.html.SafeUrl.INNOCUOUS_STRING="about:invalid#zClosurez";goog.html.SafeUrl.prototype.implementsGoogStringTypedString=!0;goog.html.SafeUrl.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeUrlWrappedValue_.toString()};
goog.html.SafeUrl.prototype.implementsGoogI18nBidiDirectionalString=!0;goog.html.SafeUrl.prototype.getDirection=function(){return goog.i18n.bidi.Dir.LTR};goog.DEBUG&&(goog.html.SafeUrl.prototype.toString=function(){return"SafeUrl{"+this.privateDoNotAccessOrElseSafeUrlWrappedValue_+"}"});goog.html.SafeUrl.unwrap=function(a){return goog.html.SafeUrl.unwrapTrustedURL(a).toString()};
goog.html.SafeUrl.unwrapTrustedURL=function(a){if(a instanceof goog.html.SafeUrl&&a.constructor===goog.html.SafeUrl&&a.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeUrlWrappedValue_;goog.asserts.fail("expected object of type SafeUrl, got '"+a+"' of type "+goog.typeOf(a));return"type_error:SafeUrl"};goog.html.SafeUrl.fromConstant=function(a){return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(a))};
goog.html.SAFE_MIME_TYPE_PATTERN_=/^(?:audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-wav|wav|webm)|image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon)|text\/csv|video\/(?:mpeg|mp4|ogg|webm|quicktime))(?:;\w+=(?:\w+|"[\w;=]+"))*$/i;goog.html.SafeUrl.isSafeMimeType=function(a){return goog.html.SAFE_MIME_TYPE_PATTERN_.test(a)};goog.html.SafeUrl.fromBlob=function(a){a=goog.html.SAFE_MIME_TYPE_PATTERN_.test(a.type)?goog.fs.url.createObjectUrl(a):goog.html.SafeUrl.INNOCUOUS_STRING;return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.DATA_URL_PATTERN_=/^data:([^,]*);base64,[a-z0-9+\/]+=*$/i;goog.html.SafeUrl.fromDataUrl=function(a){a=a.replace(/(%0A|%0D)/g,"");var b=a.match(goog.html.DATA_URL_PATTERN_);b=b&&goog.html.SAFE_MIME_TYPE_PATTERN_.test(b[1]);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b?a:goog.html.SafeUrl.INNOCUOUS_STRING)};goog.html.SafeUrl.fromTelUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"tel:")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SIP_URL_PATTERN_=/^sip[s]?:[+a-z0-9_.!$%&'*\/=^`{|}~-]+@([a-z0-9-]+\.)+[a-z0-9]{2,63}$/i;goog.html.SafeUrl.fromSipUrl=function(a){goog.html.SIP_URL_PATTERN_.test(decodeURIComponent(a))||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeUrl.fromFacebookMessengerUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"fb-messenger://share")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.fromWhatsAppUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"whatsapp://send")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeUrl.fromSmsUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"sms:")&&goog.html.SafeUrl.isSmsUrlBodyValid_(a)||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.isSmsUrlBodyValid_=function(a){var b=a.indexOf("#");0<b&&(a=a.substring(0,b));b=a.match(/[?&]body=/gi);if(!b)return!0;if(1<b.length)return!1;a=a.match(/[?&]body=([^&]*)/)[1];if(!a)return!0;try{decodeURIComponent(a)}catch(c){return!1}return/^(?:[a-z0-9\-_.~]|%[0-9a-f]{2})+$/i.test(a)};goog.html.SafeUrl.fromSshUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"ssh://")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.sanitizeChromeExtensionUrl=function(a,b){return goog.html.SafeUrl.sanitizeExtensionUrl_(/^chrome-extension:\/\/([^\/]+)\//,a,b)};goog.html.SafeUrl.sanitizeFirefoxExtensionUrl=function(a,b){return goog.html.SafeUrl.sanitizeExtensionUrl_(/^moz-extension:\/\/([^\/]+)\//,a,b)};goog.html.SafeUrl.sanitizeEdgeExtensionUrl=function(a,b){return goog.html.SafeUrl.sanitizeExtensionUrl_(/^ms-browser-extension:\/\/([^\/]+)\//,a,b)};
goog.html.SafeUrl.sanitizeExtensionUrl_=function(a,b,c){(a=a.exec(b))?(a=a[1],-1==(c instanceof goog.string.Const?[goog.string.Const.unwrap(c)]:c.map(function(a){return goog.string.Const.unwrap(a)})).indexOf(a)&&(b=goog.html.SafeUrl.INNOCUOUS_STRING)):b=goog.html.SafeUrl.INNOCUOUS_STRING;return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b)};goog.html.SafeUrl.fromTrustedResourceUrl=function(a){return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.html.TrustedResourceUrl.unwrap(a))};
goog.html.SAFE_URL_PATTERN_=/^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;goog.html.SafeUrl.SAFE_URL_PATTERN=goog.html.SAFE_URL_PATTERN_;goog.html.SafeUrl.sanitize=function(a){if(a instanceof goog.html.SafeUrl)return a;a="object"==typeof a&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);goog.html.SAFE_URL_PATTERN_.test(a)||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.sanitizeAssertUnchanged=function(a,b){if(a instanceof goog.html.SafeUrl)return a;a="object"==typeof a&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);if(b&&/^data:/i.test(a)&&(b=goog.html.SafeUrl.fromDataUrl(a),b.getTypedStringValue()==a))return b;goog.asserts.assert(goog.html.SAFE_URL_PATTERN_.test(a),"%s does not match the safe URL pattern",a)||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse=function(a){var b=new goog.html.SafeUrl;b.privateDoNotAccessOrElseSafeUrlWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createURL(a):a;return b};goog.html.SafeUrl.ABOUT_BLANK=goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse("about:blank");goog.html.SafeStyle=function(){this.privateDoNotAccessOrElseSafeStyleWrappedValue_="";this.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_};goog.html.SafeStyle.prototype.implementsGoogStringTypedString=!0;goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
goog.html.SafeStyle.fromConstant=function(a){a=goog.string.Const.unwrap(a);if(0===a.length)return goog.html.SafeStyle.EMPTY;goog.asserts.assert(goog.string.internal.endsWith(a,";"),"Last character of style string is not ';': "+a);goog.asserts.assert(goog.string.internal.contains(a,":"),"Style string must contain at least one ':', to specify a \"name: value\" pair: "+a);return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeStyle.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeStyleWrappedValue_};goog.DEBUG&&(goog.html.SafeStyle.prototype.toString=function(){return"SafeStyle{"+this.privateDoNotAccessOrElseSafeStyleWrappedValue_+"}"});
goog.html.SafeStyle.unwrap=function(a){if(a instanceof goog.html.SafeStyle&&a.constructor===goog.html.SafeStyle&&a.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeStyleWrappedValue_;goog.asserts.fail("expected object of type SafeStyle, got '"+a+"' of type "+goog.typeOf(a));return"type_error:SafeStyle"};goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse=function(a){return(new goog.html.SafeStyle).initSecurityPrivateDoNotAccessOrElse_(a)};
goog.html.SafeStyle.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeStyleWrappedValue_=a;return this};goog.html.SafeStyle.EMPTY=goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse("");goog.html.SafeStyle.INNOCUOUS_STRING="zClosurez";
goog.html.SafeStyle.create=function(a){var b="",c;for(c in a){if(!/^[-_a-zA-Z0-9]+$/.test(c))throw Error("Name allows only [-_a-zA-Z0-9], got: "+c);var d=a[c];null!=d&&(d=goog.isArray(d)?goog.array.map(d,goog.html.SafeStyle.sanitizePropertyValue_).join(" "):goog.html.SafeStyle.sanitizePropertyValue_(d),b+=c+":"+d+";")}return b?goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b):goog.html.SafeStyle.EMPTY};
goog.html.SafeStyle.sanitizePropertyValue_=function(a){if(a instanceof goog.html.SafeUrl)return'url("'+goog.html.SafeUrl.unwrap(a).replace(/</g,"%3c").replace(/[\\"]/g,"\\$&")+'")';a=a instanceof goog.string.Const?goog.string.Const.unwrap(a):goog.html.SafeStyle.sanitizePropertyValueString_(String(a));if(/[{;}]/.test(a))throw new goog.asserts.AssertionError("Value does not allow [{;}], got: %s.",[a]);return a};
goog.html.SafeStyle.sanitizePropertyValueString_=function(a){var b=a.replace(goog.html.SafeStyle.FUNCTIONS_RE_,"$1").replace(goog.html.SafeStyle.FUNCTIONS_RE_,"$1").replace(goog.html.SafeStyle.URL_RE_,"url");if(goog.html.SafeStyle.VALUE_RE_.test(b)){if(goog.html.SafeStyle.COMMENT_RE_.test(a))return goog.asserts.fail("String value disallows comments, got: "+a),goog.html.SafeStyle.INNOCUOUS_STRING;if(!goog.html.SafeStyle.hasBalancedQuotes_(a))return goog.asserts.fail("String value requires balanced quotes, got: "+
a),goog.html.SafeStyle.INNOCUOUS_STRING;if(!goog.html.SafeStyle.hasBalancedSquareBrackets_(a))return goog.asserts.fail("String value requires balanced square brackets and one identifier per pair of brackets, got: "+a),goog.html.SafeStyle.INNOCUOUS_STRING}else return goog.asserts.fail("String value allows only "+goog.html.SafeStyle.VALUE_ALLOWED_CHARS_+" and simple functions, got: "+a),goog.html.SafeStyle.INNOCUOUS_STRING;return goog.html.SafeStyle.sanitizeUrl_(a)};
goog.html.SafeStyle.hasBalancedQuotes_=function(a){for(var b=!0,c=!0,d=0;d<a.length;d++){var e=a.charAt(d);"'"==e&&c?b=!b:'"'==e&&b&&(c=!c)}return b&&c};goog.html.SafeStyle.hasBalancedSquareBrackets_=function(a){for(var b=!0,c=/^[-_a-zA-Z0-9]$/,d=0;d<a.length;d++){var e=a.charAt(d);if("]"==e){if(b)return!1;b=!0}else if("["==e){if(!b)return!1;b=!1}else if(!b&&!c.test(e))return!1}return b};goog.html.SafeStyle.VALUE_ALLOWED_CHARS_="[-,.\"'%_!# a-zA-Z0-9\\[\\]]";
goog.html.SafeStyle.VALUE_RE_=new RegExp("^"+goog.html.SafeStyle.VALUE_ALLOWED_CHARS_+"+$");goog.html.SafeStyle.URL_RE_=/\b(url\([ \t\n]*)('[ -&(-\[\]-~]*'|"[ !#-\[\]-~]*"|[!#-&*-\[\]-~]*)([ \t\n]*\))/g;goog.html.SafeStyle.FUNCTIONS_RE_=/\b(hsl|hsla|rgb|rgba|matrix|calc|minmax|fit-content|repeat|(rotate|scale|translate)(X|Y|Z|3d)?)\([-+*/0-9a-z.%\[\], ]+\)/g;goog.html.SafeStyle.COMMENT_RE_=/\/\*/;
goog.html.SafeStyle.sanitizeUrl_=function(a){return a.replace(goog.html.SafeStyle.URL_RE_,function(a,c,d,e){var b="";d=d.replace(/^(['"])(.*)\1$/,function(a,c,d){b=c;return d});a=goog.html.SafeUrl.sanitize(d).getTypedStringValue();return c+b+a+b+e})};goog.html.SafeStyle.concat=function(a){var b="",c=function(a){goog.isArray(a)?goog.array.forEach(a,c):b+=goog.html.SafeStyle.unwrap(a)};goog.array.forEach(arguments,c);return b?goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b):goog.html.SafeStyle.EMPTY};goog.html.SafeStyleSheet=function(){this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_="";this.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_};goog.html.SafeStyleSheet.prototype.implementsGoogStringTypedString=!0;goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
goog.html.SafeStyleSheet.createRule=function(a,b){if(goog.string.internal.contains(a,"<"))throw Error("Selector does not allow '<', got: "+a);var c=a.replace(/('|")((?!\1)[^\r\n\f\\]|\\[\s\S])*\1/g,"");if(!/^[-_a-zA-Z0-9#.:* ,>+~[\]()=^$|]+$/.test(c))throw Error("Selector allows only [-_a-zA-Z0-9#.:* ,>+~[\\]()=^$|] and strings, got: "+a);if(!goog.html.SafeStyleSheet.hasBalancedBrackets_(c))throw Error("() and [] in selector must be balanced, got: "+a);b instanceof goog.html.SafeStyle||(b=goog.html.SafeStyle.create(b));
a=a+"{"+goog.html.SafeStyle.unwrap(b).replace(/</g,"\\3C ")+"}";return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeStyleSheet.hasBalancedBrackets_=function(a){for(var b={"(":")","[":"]"},c=[],d=0;d<a.length;d++){var e=a[d];if(b[e])c.push(b[e]);else if(goog.object.contains(b,e)&&c.pop()!=e)return!1}return 0==c.length};
goog.html.SafeStyleSheet.concat=function(a){var b="",c=function(a){goog.isArray(a)?goog.array.forEach(a,c):b+=goog.html.SafeStyleSheet.unwrap(a)};goog.array.forEach(arguments,c);return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(b)};
goog.html.SafeStyleSheet.fromConstant=function(a){a=goog.string.Const.unwrap(a);if(0===a.length)return goog.html.SafeStyleSheet.EMPTY;goog.asserts.assert(!goog.string.internal.contains(a,"<"),"Forbidden '<' character in style sheet string: "+a);return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeStyleSheet.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_};
goog.DEBUG&&(goog.html.SafeStyleSheet.prototype.toString=function(){return"SafeStyleSheet{"+this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_+"}"});
goog.html.SafeStyleSheet.unwrap=function(a){if(a instanceof goog.html.SafeStyleSheet&&a.constructor===goog.html.SafeStyleSheet&&a.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;goog.asserts.fail("expected object of type SafeStyleSheet, got '"+a+"' of type "+goog.typeOf(a));return"type_error:SafeStyleSheet"};
goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse=function(a){return(new goog.html.SafeStyleSheet).initSecurityPrivateDoNotAccessOrElse_(a)};goog.html.SafeStyleSheet.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_=a;return this};goog.html.SafeStyleSheet.EMPTY=goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse("");goog.labs={};goog.labs.userAgent={};goog.labs.userAgent.util={};goog.labs.userAgent.util.getNativeUserAgentString_=function(){var a=goog.labs.userAgent.util.getNavigator_();return a&&(a=a.userAgent)?a:""};goog.labs.userAgent.util.getNavigator_=function(){return goog.global.navigator};goog.labs.userAgent.util.userAgent_=goog.labs.userAgent.util.getNativeUserAgentString_();goog.labs.userAgent.util.setUserAgent=function(a){goog.labs.userAgent.util.userAgent_=a||goog.labs.userAgent.util.getNativeUserAgentString_()};
goog.labs.userAgent.util.getUserAgent=function(){return goog.labs.userAgent.util.userAgent_};goog.labs.userAgent.util.matchUserAgent=function(a){var b=goog.labs.userAgent.util.getUserAgent();return goog.string.internal.contains(b,a)};goog.labs.userAgent.util.matchUserAgentIgnoreCase=function(a){var b=goog.labs.userAgent.util.getUserAgent();return goog.string.internal.caseInsensitiveContains(b,a)};
goog.labs.userAgent.util.extractVersionTuples=function(a){for(var b=/(\w[\w ]+)\/([^\s]+)\s*(?:\((.*?)\))?/g,c=[],d;d=b.exec(a);)c.push([d[1],d[2],d[3]||void 0]);return c};goog.labs.userAgent.browser={};goog.labs.userAgent.browser.matchOpera_=function(){return goog.labs.userAgent.util.matchUserAgent("Opera")};goog.labs.userAgent.browser.matchIE_=function(){return goog.labs.userAgent.util.matchUserAgent("Trident")||goog.labs.userAgent.util.matchUserAgent("MSIE")};goog.labs.userAgent.browser.matchEdgeHtml_=function(){return goog.labs.userAgent.util.matchUserAgent("Edge")};goog.labs.userAgent.browser.matchEdgeChromium_=function(){return goog.labs.userAgent.util.matchUserAgent("Edg/")};
goog.labs.userAgent.browser.matchOperaChromium_=function(){return goog.labs.userAgent.util.matchUserAgent("OPR")};goog.labs.userAgent.browser.matchFirefox_=function(){return goog.labs.userAgent.util.matchUserAgent("Firefox")||goog.labs.userAgent.util.matchUserAgent("FxiOS")};
goog.labs.userAgent.browser.matchSafari_=function(){return goog.labs.userAgent.util.matchUserAgent("Safari")&&!(goog.labs.userAgent.browser.matchChrome_()||goog.labs.userAgent.browser.matchCoast_()||goog.labs.userAgent.browser.matchOpera_()||goog.labs.userAgent.browser.matchEdgeHtml_()||goog.labs.userAgent.browser.matchEdgeChromium_()||goog.labs.userAgent.browser.matchOperaChromium_()||goog.labs.userAgent.browser.matchFirefox_()||goog.labs.userAgent.browser.isSilk()||goog.labs.userAgent.util.matchUserAgent("Android"))};
goog.labs.userAgent.browser.matchCoast_=function(){return goog.labs.userAgent.util.matchUserAgent("Coast")};goog.labs.userAgent.browser.matchIosWebview_=function(){return(goog.labs.userAgent.util.matchUserAgent("iPad")||goog.labs.userAgent.util.matchUserAgent("iPhone"))&&!goog.labs.userAgent.browser.matchSafari_()&&!goog.labs.userAgent.browser.matchChrome_()&&!goog.labs.userAgent.browser.matchCoast_()&&!goog.labs.userAgent.browser.matchFirefox_()&&goog.labs.userAgent.util.matchUserAgent("AppleWebKit")};
goog.labs.userAgent.browser.matchChrome_=function(){return(goog.labs.userAgent.util.matchUserAgent("Chrome")||goog.labs.userAgent.util.matchUserAgent("CriOS"))&&!goog.labs.userAgent.browser.matchEdgeHtml_()};goog.labs.userAgent.browser.matchAndroidBrowser_=function(){return goog.labs.userAgent.util.matchUserAgent("Android")&&!(goog.labs.userAgent.browser.isChrome()||goog.labs.userAgent.browser.isFirefox()||goog.labs.userAgent.browser.isOpera()||goog.labs.userAgent.browser.isSilk())};
goog.labs.userAgent.browser.isOpera=goog.labs.userAgent.browser.matchOpera_;goog.labs.userAgent.browser.isIE=goog.labs.userAgent.browser.matchIE_;goog.labs.userAgent.browser.isEdge=goog.labs.userAgent.browser.matchEdgeHtml_;goog.labs.userAgent.browser.isEdgeChromium=goog.labs.userAgent.browser.matchEdgeChromium_;goog.labs.userAgent.browser.isOperaChromium=goog.labs.userAgent.browser.matchOperaChromium_;goog.labs.userAgent.browser.isFirefox=goog.labs.userAgent.browser.matchFirefox_;
goog.labs.userAgent.browser.isSafari=goog.labs.userAgent.browser.matchSafari_;goog.labs.userAgent.browser.isCoast=goog.labs.userAgent.browser.matchCoast_;goog.labs.userAgent.browser.isIosWebview=goog.labs.userAgent.browser.matchIosWebview_;goog.labs.userAgent.browser.isChrome=goog.labs.userAgent.browser.matchChrome_;goog.labs.userAgent.browser.isAndroidBrowser=goog.labs.userAgent.browser.matchAndroidBrowser_;goog.labs.userAgent.browser.isSilk=function(){return goog.labs.userAgent.util.matchUserAgent("Silk")};
goog.labs.userAgent.browser.getVersion=function(){function a(a){a=goog.array.find(a,d);return c[a]||""}var b=goog.labs.userAgent.util.getUserAgent();if(goog.labs.userAgent.browser.isIE())return goog.labs.userAgent.browser.getIEVersion_(b);b=goog.labs.userAgent.util.extractVersionTuples(b);var c={};goog.array.forEach(b,function(a){c[a[0]]=a[1]});var d=goog.partial(goog.object.containsKey,c);return goog.labs.userAgent.browser.isOpera()?a(["Version","Opera"]):goog.labs.userAgent.browser.isEdge()?a(["Edge"]):
goog.labs.userAgent.browser.isEdgeChromium()?a(["Edg"]):goog.labs.userAgent.browser.isChrome()?a(["Chrome","CriOS"]):(b=b[2])&&b[1]||""};goog.labs.userAgent.browser.isVersionOrHigher=function(a){return 0<=goog.string.internal.compareVersions(goog.labs.userAgent.browser.getVersion(),a)};
goog.labs.userAgent.browser.getIEVersion_=function(a){var b=/rv: *([\d\.]*)/.exec(a);if(b&&b[1])return b[1];b="";var c=/MSIE +([\d\.]+)/.exec(a);if(c&&c[1])if(a=/Trident\/(\d.\d)/.exec(a),"7.0"==c[1])if(a&&a[1])switch(a[1]){case "4.0":b="8.0";break;case "5.0":b="9.0";break;case "6.0":b="10.0";break;case "7.0":b="11.0"}else b="7.0";else b=c[1];return b};goog.html.SafeHtml=function(){this.privateDoNotAccessOrElseSafeHtmlWrappedValue_="";this.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;this.dir_=null};goog.html.SafeHtml.prototype.implementsGoogI18nBidiDirectionalString=!0;goog.html.SafeHtml.prototype.getDirection=function(){return this.dir_};goog.html.SafeHtml.prototype.implementsGoogStringTypedString=!0;goog.html.SafeHtml.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_.toString()};
goog.DEBUG&&(goog.html.SafeHtml.prototype.toString=function(){return"SafeHtml{"+this.privateDoNotAccessOrElseSafeHtmlWrappedValue_+"}"});goog.html.SafeHtml.unwrap=function(a){return goog.html.SafeHtml.unwrapTrustedHTML(a).toString()};
goog.html.SafeHtml.unwrapTrustedHTML=function(a){if(a instanceof goog.html.SafeHtml&&a.constructor===goog.html.SafeHtml&&a.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeHtmlWrappedValue_;goog.asserts.fail("expected object of type SafeHtml, got '"+a+"' of type "+goog.typeOf(a));return"type_error:SafeHtml"};
goog.html.SafeHtml.htmlEscape=function(a){if(a instanceof goog.html.SafeHtml)return a;var b="object"==typeof a,c=null;b&&a.implementsGoogI18nBidiDirectionalString&&(c=a.getDirection());a=b&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.htmlEscape(a),c)};
goog.html.SafeHtml.htmlEscapePreservingNewlines=function(a){if(a instanceof goog.html.SafeHtml)return a;a=goog.html.SafeHtml.htmlEscape(a);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.newLineToBr(goog.html.SafeHtml.unwrap(a)),a.getDirection())};
goog.html.SafeHtml.htmlEscapePreservingNewlinesAndSpaces=function(a){if(a instanceof goog.html.SafeHtml)return a;a=goog.html.SafeHtml.htmlEscape(a);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.whitespaceEscape(goog.html.SafeHtml.unwrap(a)),a.getDirection())};goog.html.SafeHtml.from=goog.html.SafeHtml.htmlEscape;goog.html.SafeHtml.VALID_NAMES_IN_TAG_=/^[a-zA-Z0-9-]+$/;
goog.html.SafeHtml.URL_ATTRIBUTES_={action:!0,cite:!0,data:!0,formaction:!0,href:!0,manifest:!0,poster:!0,src:!0};goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_={APPLET:!0,BASE:!0,EMBED:!0,IFRAME:!0,LINK:!0,MATH:!0,META:!0,OBJECT:!0,SCRIPT:!0,STYLE:!0,SVG:!0,TEMPLATE:!0};goog.html.SafeHtml.create=function(a,b,c){goog.html.SafeHtml.verifyTagName(String(a));return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(String(a),b,c)};
goog.html.SafeHtml.verifyTagName=function(a){if(!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(a))throw Error("Invalid tag name <"+a+">.");if(a.toUpperCase()in goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_)throw Error("Tag name <"+a+"> is not allowed for SafeHtml.");};
goog.html.SafeHtml.createIframe=function(a,b,c,d){a&&goog.html.TrustedResourceUrl.unwrap(a);var e={};e.src=a||null;e.srcdoc=b&&goog.html.SafeHtml.unwrap(b);a=goog.html.SafeHtml.combineAttributes(e,{sandbox:""},c);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe",a,d)};
goog.html.SafeHtml.createSandboxIframe=function(a,b,c,d){if(!goog.html.SafeHtml.canUseSandboxIframe())throw Error("The browser does not support sandboxed iframes.");var e={};e.src=a?goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(a)):null;e.srcdoc=b||null;e.sandbox="";a=goog.html.SafeHtml.combineAttributes(e,{},c);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe",a,d)};
goog.html.SafeHtml.canUseSandboxIframe=function(){return goog.global.HTMLIFrameElement&&"sandbox"in goog.global.HTMLIFrameElement.prototype};goog.html.SafeHtml.createScriptSrc=function(a,b){goog.html.TrustedResourceUrl.unwrap(a);a=goog.html.SafeHtml.combineAttributes({src:a},{},b);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script",a)};
goog.html.SafeHtml.createScript=function(a,b){for(var c in b){var d=c.toLowerCase();if("language"==d||"src"==d||"text"==d||"type"==d)throw Error('Cannot set "'+d+'" attribute');}c="";a=goog.array.concat(a);for(d=0;d<a.length;d++)c+=goog.html.SafeScript.unwrap(a[d]);a=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(c,goog.i18n.bidi.Dir.NEUTRAL);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script",b,a)};
goog.html.SafeHtml.createStyle=function(a,b){b=goog.html.SafeHtml.combineAttributes({type:"text/css"},{},b);var c="";a=goog.array.concat(a);for(var d=0;d<a.length;d++)c+=goog.html.SafeStyleSheet.unwrap(a[d]);a=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(c,goog.i18n.bidi.Dir.NEUTRAL);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("style",b,a)};
goog.html.SafeHtml.createMetaRefresh=function(a,b){a=goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(a));(goog.labs.userAgent.browser.isIE()||goog.labs.userAgent.browser.isEdge())&&goog.string.internal.contains(a,";")&&(a="'"+a.replace(/'/g,"%27")+"'");return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("meta",{"http-equiv":"refresh",content:(b||0)+"; url="+a})};
goog.html.SafeHtml.getAttrNameAndValue_=function(a,b,c){if(c instanceof goog.string.Const)c=goog.string.Const.unwrap(c);else if("style"==b.toLowerCase())c=goog.html.SafeHtml.getStyleValue_(c);else{if(/^on/i.test(b))throw Error('Attribute "'+b+'" requires goog.string.Const value, "'+c+'" given.');if(b.toLowerCase()in goog.html.SafeHtml.URL_ATTRIBUTES_)if(c instanceof goog.html.TrustedResourceUrl)c=goog.html.TrustedResourceUrl.unwrap(c);else if(c instanceof goog.html.SafeUrl)c=goog.html.SafeUrl.unwrap(c);
else if(goog.isString(c))c=goog.html.SafeUrl.sanitize(c).getTypedStringValue();else throw Error('Attribute "'+b+'" on tag "'+a+'" requires goog.html.SafeUrl, goog.string.Const, or string, value "'+c+'" given.');}c.implementsGoogStringTypedString&&(c=c.getTypedStringValue());goog.asserts.assert(goog.isString(c)||goog.isNumber(c),"String or number value expected, got "+typeof c+" with value: "+c);return b+'="'+goog.string.internal.htmlEscape(String(c))+'"'};
goog.html.SafeHtml.getStyleValue_=function(a){if(!goog.isObject(a))throw Error('The "style" attribute requires goog.html.SafeStyle or map of style properties, '+typeof a+" given: "+a);a instanceof goog.html.SafeStyle||(a=goog.html.SafeStyle.create(a));return goog.html.SafeStyle.unwrap(a)};goog.html.SafeHtml.createWithDir=function(a,b,c,d){b=goog.html.SafeHtml.create(b,c,d);b.dir_=a;return b};
goog.html.SafeHtml.join=function(a,b){a=goog.html.SafeHtml.htmlEscape(a);var c=a.getDirection(),d=[],e=function(a){goog.isArray(a)?goog.array.forEach(a,e):(a=goog.html.SafeHtml.htmlEscape(a),d.push(goog.html.SafeHtml.unwrap(a)),a=a.getDirection(),c==goog.i18n.bidi.Dir.NEUTRAL?c=a:a!=goog.i18n.bidi.Dir.NEUTRAL&&c!=a&&(c=null))};goog.array.forEach(b,e);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(d.join(goog.html.SafeHtml.unwrap(a)),c)};
goog.html.SafeHtml.concat=function(a){return goog.html.SafeHtml.join(goog.html.SafeHtml.EMPTY,Array.prototype.slice.call(arguments))};goog.html.SafeHtml.concatWithDir=function(a,b){var c=goog.html.SafeHtml.concat(goog.array.slice(arguments,1));c.dir_=a;return c};goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse=function(a,b){return(new goog.html.SafeHtml).initSecurityPrivateDoNotAccessOrElse_(a,b)};
goog.html.SafeHtml.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a,b){this.privateDoNotAccessOrElseSafeHtmlWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createHTML(a):a;this.dir_=b;return this};
goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse=function(a,b,c){var d=null;var e="<"+a+goog.html.SafeHtml.stringifyAttributes(a,b);goog.isDefAndNotNull(c)?goog.isArray(c)||(c=[c]):c=[];goog.dom.tags.isVoidTag(a.toLowerCase())?(goog.asserts.assert(!c.length,"Void tag <"+a+"> does not allow content."),e+=">"):(d=goog.html.SafeHtml.concat(c),e+=">"+goog.html.SafeHtml.unwrap(d)+"</"+a+">",d=d.getDirection());(a=b&&b.dir)&&(d=/^(ltr|rtl|auto)$/i.test(a)?goog.i18n.bidi.Dir.NEUTRAL:
null);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(e,d)};goog.html.SafeHtml.stringifyAttributes=function(a,b){var c="";if(b)for(var d in b){if(!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(d))throw Error('Invalid attribute name "'+d+'".');var e=b[d];goog.isDefAndNotNull(e)&&(c+=" "+goog.html.SafeHtml.getAttrNameAndValue_(a,d,e))}return c};
goog.html.SafeHtml.combineAttributes=function(a,b,c){var d={},e;for(e in a)goog.asserts.assert(e.toLowerCase()==e,"Must be lower case"),d[e]=a[e];for(e in b)goog.asserts.assert(e.toLowerCase()==e,"Must be lower case"),d[e]=b[e];for(e in c){var f=e.toLowerCase();if(f in a)throw Error('Cannot override "'+f+'" attribute, got "'+e+'" with value "'+c[e]+'"');f in b&&delete d[f];d[e]=c[e]}return d};
goog.html.SafeHtml.DOCTYPE_HTML=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<!DOCTYPE html>",goog.i18n.bidi.Dir.NEUTRAL);goog.html.SafeHtml.EMPTY=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("",goog.i18n.bidi.Dir.NEUTRAL);goog.html.SafeHtml.BR=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<br>",goog.i18n.bidi.Dir.NEUTRAL);goog.html.uncheckedconversions={};goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract=function(a,b,c){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(b,c||null)};
goog.html.uncheckedconversions.safeScriptFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(b)};
goog.html.uncheckedconversions.safeStyleFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b)};
goog.html.uncheckedconversions.safeStyleSheetFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(b)};
goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b)};
goog.html.uncheckedconversions.trustedResourceUrlFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(b)};goog.dom.safe={};goog.dom.safe.InsertAdjacentHtmlPosition={AFTERBEGIN:"afterbegin",AFTEREND:"afterend",BEFOREBEGIN:"beforebegin",BEFOREEND:"beforeend"};goog.dom.safe.insertAdjacentHtml=function(a,b,c){a.insertAdjacentHTML(b,goog.html.SafeHtml.unwrapTrustedHTML(c))};goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_={MATH:!0,SCRIPT:!0,STYLE:!0,SVG:!0,TEMPLATE:!0};
goog.dom.safe.isInnerHtmlCleanupRecursive_=goog.functions.cacheReturnValue(function(){if(goog.DEBUG&&"undefined"===typeof document)return!1;var a=document.createElement("div"),b=document.createElement("div");b.appendChild(document.createElement("div"));a.appendChild(b);if(goog.DEBUG&&!a.firstChild)return!1;b=a.firstChild.firstChild;a.innerHTML=goog.html.SafeHtml.unwrapTrustedHTML(goog.html.SafeHtml.EMPTY);return!b.parentElement});
goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse=function(a,b){if(goog.dom.safe.isInnerHtmlCleanupRecursive_())for(;a.lastChild;)a.removeChild(a.lastChild);a.innerHTML=goog.html.SafeHtml.unwrapTrustedHTML(b)};
goog.dom.safe.setInnerHtml=function(a,b){if(goog.asserts.ENABLE_ASSERTS){var c=a.tagName.toUpperCase();if(goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_[c])throw Error("goog.dom.safe.setInnerHtml cannot be used to set content of "+a.tagName+".");}goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(a,b)};goog.dom.safe.setOuterHtml=function(a,b){a.outerHTML=goog.html.SafeHtml.unwrapTrustedHTML(b)};
goog.dom.safe.setFormElementAction=function(a,b){b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);goog.dom.asserts.assertIsHTMLFormElement(a).action=goog.html.SafeUrl.unwrapTrustedURL(b)};goog.dom.safe.setButtonFormAction=function(a,b){b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);goog.dom.asserts.assertIsHTMLButtonElement(a).formAction=goog.html.SafeUrl.unwrapTrustedURL(b)};
goog.dom.safe.setInputFormAction=function(a,b){b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);goog.dom.asserts.assertIsHTMLInputElement(a).formAction=goog.html.SafeUrl.unwrapTrustedURL(b)};goog.dom.safe.setStyle=function(a,b){a.style.cssText=goog.html.SafeStyle.unwrap(b)};goog.dom.safe.documentWrite=function(a,b){a.write(goog.html.SafeHtml.unwrapTrustedHTML(b))};
goog.dom.safe.setAnchorHref=function(a,b){goog.dom.asserts.assertIsHTMLAnchorElement(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.href=goog.html.SafeUrl.unwrapTrustedURL(b)};goog.dom.safe.setImageSrc=function(a,b){goog.dom.asserts.assertIsHTMLImageElement(a);if(!(b instanceof goog.html.SafeUrl)){var c=/^data:image\//i.test(b);b=goog.html.SafeUrl.sanitizeAssertUnchanged(b,c)}a.src=goog.html.SafeUrl.unwrapTrustedURL(b)};
goog.dom.safe.setAudioSrc=function(a,b){goog.dom.asserts.assertIsHTMLAudioElement(a);if(!(b instanceof goog.html.SafeUrl)){var c=/^data:audio\//i.test(b);b=goog.html.SafeUrl.sanitizeAssertUnchanged(b,c)}a.src=goog.html.SafeUrl.unwrapTrustedURL(b)};goog.dom.safe.setVideoSrc=function(a,b){goog.dom.asserts.assertIsHTMLVideoElement(a);if(!(b instanceof goog.html.SafeUrl)){var c=/^data:video\//i.test(b);b=goog.html.SafeUrl.sanitizeAssertUnchanged(b,c)}a.src=goog.html.SafeUrl.unwrapTrustedURL(b)};
goog.dom.safe.setEmbedSrc=function(a,b){goog.dom.asserts.assertIsHTMLEmbedElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b)};goog.dom.safe.setFrameSrc=function(a,b){goog.dom.asserts.assertIsHTMLFrameElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedURL(b)};goog.dom.safe.setIframeSrc=function(a,b){goog.dom.asserts.assertIsHTMLIFrameElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedURL(b)};
goog.dom.safe.setIframeSrcdoc=function(a,b){goog.dom.asserts.assertIsHTMLIFrameElement(a);a.srcdoc=goog.html.SafeHtml.unwrapTrustedHTML(b)};
goog.dom.safe.setLinkHrefAndRel=function(a,b,c){goog.dom.asserts.assertIsHTMLLinkElement(a);a.rel=c;goog.string.internal.caseInsensitiveContains(c,"stylesheet")?(goog.asserts.assert(b instanceof goog.html.TrustedResourceUrl,'URL must be TrustedResourceUrl because "rel" contains "stylesheet"'),a.href=goog.html.TrustedResourceUrl.unwrapTrustedURL(b)):a.href=b instanceof goog.html.TrustedResourceUrl?goog.html.TrustedResourceUrl.unwrapTrustedURL(b):b instanceof goog.html.SafeUrl?goog.html.SafeUrl.unwrapTrustedURL(b):
goog.html.SafeUrl.unwrapTrustedURL(goog.html.SafeUrl.sanitizeAssertUnchanged(b))};goog.dom.safe.setObjectData=function(a,b){goog.dom.asserts.assertIsHTMLObjectElement(a);a.data=goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b)};goog.dom.safe.setScriptSrc=function(a,b){goog.dom.asserts.assertIsHTMLScriptElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b);(b=goog.getScriptNonce())&&a.setAttribute("nonce",b)};
goog.dom.safe.setScriptContent=function(a,b){goog.dom.asserts.assertIsHTMLScriptElement(a);a.text=goog.html.SafeScript.unwrapTrustedScript(b);(b=goog.getScriptNonce())&&a.setAttribute("nonce",b)};goog.dom.safe.setLocationHref=function(a,b){goog.dom.asserts.assertIsLocation(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.href=goog.html.SafeUrl.unwrapTrustedURL(b)};
goog.dom.safe.assignLocation=function(a,b){goog.dom.asserts.assertIsLocation(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.assign(goog.html.SafeUrl.unwrapTrustedURL(b))};goog.dom.safe.replaceLocation=function(a,b){goog.dom.asserts.assertIsLocation(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.replace(goog.html.SafeUrl.unwrapTrustedURL(b))};
goog.dom.safe.openInWindow=function(a,b,c,d,e){a=a instanceof goog.html.SafeUrl?a:goog.html.SafeUrl.sanitizeAssertUnchanged(a);return(b||goog.global).open(goog.html.SafeUrl.unwrapTrustedURL(a),c?goog.string.Const.unwrap(c):"",d,e)};goog.dom.safe.parseFromStringHtml=function(a,b){return goog.dom.safe.parseFromString(a,b,"text/html")};goog.dom.safe.parseFromString=function(a,b,c){return a.parseFromString(goog.html.SafeHtml.unwrapTrustedHTML(b),c)};
goog.dom.safe.createImageFromBlob=function(a){if(!/^image\/.*/g.test(a.type))throw Error("goog.dom.safe.createImageFromBlob only accepts MIME type image/.*.");var b=goog.global.URL.createObjectURL(a);a=new goog.global.Image;a.onload=function(){goog.global.URL.revokeObjectURL(b)};goog.dom.safe.setImageSrc(a,goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Image blob URL."),b));return a};goog.string.DETECT_DOUBLE_ESCAPING=!1;goog.string.FORCE_NON_DOM_HTML_UNESCAPING=!1;goog.string.Unicode={NBSP:"\u00a0"};goog.string.startsWith=goog.string.internal.startsWith;goog.string.endsWith=goog.string.internal.endsWith;goog.string.caseInsensitiveStartsWith=goog.string.internal.caseInsensitiveStartsWith;goog.string.caseInsensitiveEndsWith=goog.string.internal.caseInsensitiveEndsWith;goog.string.caseInsensitiveEquals=goog.string.internal.caseInsensitiveEquals;
goog.string.subs=function(a,b){for(var c=a.split("%s"),d="",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join("%s")};goog.string.collapseWhitespace=function(a){return a.replace(/[\s\xa0]+/g," ").replace(/^\s+|\s+$/g,"")};goog.string.isEmptyOrWhitespace=goog.string.internal.isEmptyOrWhitespace;goog.string.isEmptyString=function(a){return 0==a.length};goog.string.isEmpty=goog.string.isEmptyOrWhitespace;goog.string.isEmptyOrWhitespaceSafe=function(a){return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(a))};
goog.string.isEmptySafe=goog.string.isEmptyOrWhitespaceSafe;goog.string.isBreakingWhitespace=function(a){return!/[^\t\n\r ]/.test(a)};goog.string.isAlpha=function(a){return!/[^a-zA-Z]/.test(a)};goog.string.isNumeric=function(a){return!/[^0-9]/.test(a)};goog.string.isAlphaNumeric=function(a){return!/[^a-zA-Z0-9]/.test(a)};goog.string.isSpace=function(a){return" "==a};goog.string.isUnicodeChar=function(a){return 1==a.length&&" "<=a&&"~">=a||"\u0080"<=a&&"\ufffd">=a};
goog.string.stripNewlines=function(a){return a.replace(/(\r\n|\r|\n)+/g," ")};goog.string.canonicalizeNewlines=function(a){return a.replace(/(\r\n|\r|\n)/g,"\n")};goog.string.normalizeWhitespace=function(a){return a.replace(/\xa0|\s/g," ")};goog.string.normalizeSpaces=function(a){return a.replace(/\xa0|[ \t]+/g," ")};goog.string.collapseBreakingSpaces=function(a){return a.replace(/[\t\r\n ]+/g," ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g,"")};goog.string.trim=goog.string.internal.trim;
goog.string.trimLeft=function(a){return a.replace(/^[\s\xa0]+/,"")};goog.string.trimRight=function(a){return a.replace(/[\s\xa0]+$/,"")};goog.string.caseInsensitiveCompare=goog.string.internal.caseInsensitiveCompare;
goog.string.numberAwareCompare_=function(a,b,c){if(a==b)return 0;if(!a)return-1;if(!b)return 1;for(var d=a.toLowerCase().match(c),e=b.toLowerCase().match(c),f=Math.min(d.length,e.length),g=0;g<f;g++){c=d[g];var h=e[g];if(c!=h)return a=parseInt(c,10),!isNaN(a)&&(b=parseInt(h,10),!isNaN(b)&&a-b)?a-b:c<h?-1:1}return d.length!=e.length?d.length-e.length:a<b?-1:1};goog.string.intAwareCompare=function(a,b){return goog.string.numberAwareCompare_(a,b,/\d+|\D+/g)};
goog.string.floatAwareCompare=function(a,b){return goog.string.numberAwareCompare_(a,b,/\d+|\.\d+|\D+/g)};goog.string.numerateCompare=goog.string.floatAwareCompare;goog.string.urlEncode=function(a){return encodeURIComponent(String(a))};goog.string.urlDecode=function(a){return decodeURIComponent(a.replace(/\+/g," "))};goog.string.newLineToBr=goog.string.internal.newLineToBr;
goog.string.htmlEscape=function(a,b){a=goog.string.internal.htmlEscape(a,b);goog.string.DETECT_DOUBLE_ESCAPING&&(a=a.replace(goog.string.E_RE_,"&#101;"));return a};goog.string.E_RE_=/e/g;goog.string.unescapeEntities=function(a){return goog.string.contains(a,"&")?!goog.string.FORCE_NON_DOM_HTML_UNESCAPING&&"document"in goog.global?goog.string.unescapeEntitiesUsingDom_(a):goog.string.unescapePureXmlEntities_(a):a};
goog.string.unescapeEntitiesWithDocument=function(a,b){return goog.string.contains(a,"&")?goog.string.unescapeEntitiesUsingDom_(a,b):a};
goog.string.unescapeEntitiesUsingDom_=function(a,b){var c={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"'};var d=b?b.createElement("div"):goog.global.document.createElement("div");return a.replace(goog.string.HTML_ENTITY_PATTERN_,function(a,b){var e=c[a];if(e)return e;"#"==b.charAt(0)&&(b=Number("0"+b.substr(1)),isNaN(b)||(e=String.fromCharCode(b)));e||(goog.dom.safe.setInnerHtml(d,goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Single HTML entity."),
a+" ")),e=d.firstChild.nodeValue.slice(0,-1));return c[a]=e})};goog.string.unescapePureXmlEntities_=function(a){return a.replace(/&([^;]+);/g,function(a,c){switch(c){case "amp":return"&";case "lt":return"<";case "gt":return">";case "quot":return'"';default:return"#"!=c.charAt(0)||(c=Number("0"+c.substr(1)),isNaN(c))?a:String.fromCharCode(c)}})};goog.string.HTML_ENTITY_PATTERN_=/&([^;\s<&]+);?/g;goog.string.whitespaceEscape=function(a,b){return goog.string.newLineToBr(a.replace(/  /g," &#160;"),b)};
goog.string.preserveSpaces=function(a){return a.replace(/(^|[\n ]) /g,"$1"+goog.string.Unicode.NBSP)};goog.string.stripQuotes=function(a,b){for(var c=b.length,d=0;d<c;d++){var e=1==c?b:b.charAt(d);if(a.charAt(0)==e&&a.charAt(a.length-1)==e)return a.substring(1,a.length-1)}return a};goog.string.truncate=function(a,b,c){c&&(a=goog.string.unescapeEntities(a));a.length>b&&(a=a.substring(0,b-3)+"...");c&&(a=goog.string.htmlEscape(a));return a};
goog.string.truncateMiddle=function(a,b,c,d){c&&(a=goog.string.unescapeEntities(a));if(d&&a.length>b){d>b&&(d=b);var e=a.length-d;a=a.substring(0,b-d)+"..."+a.substring(e)}else a.length>b&&(d=Math.floor(b/2),e=a.length-d,a=a.substring(0,d+b%2)+"..."+a.substring(e));c&&(a=goog.string.htmlEscape(a));return a};goog.string.specialEscapeChars_={"\x00":"\\0","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\x0B",'"':'\\"',"\\":"\\\\","<":"\\u003C"};goog.string.jsEscapeCache_={"'":"\\'"};
goog.string.quote=function(a){a=String(a);for(var b=['"'],c=0;c<a.length;c++){var d=a.charAt(c),e=d.charCodeAt(0);b[c+1]=goog.string.specialEscapeChars_[d]||(31<e&&127>e?d:goog.string.escapeChar(d))}b.push('"');return b.join("")};goog.string.escapeString=function(a){for(var b=[],c=0;c<a.length;c++)b[c]=goog.string.escapeChar(a.charAt(c));return b.join("")};
goog.string.escapeChar=function(a){if(a in goog.string.jsEscapeCache_)return goog.string.jsEscapeCache_[a];if(a in goog.string.specialEscapeChars_)return goog.string.jsEscapeCache_[a]=goog.string.specialEscapeChars_[a];var b=a.charCodeAt(0);if(31<b&&127>b)var c=a;else{if(256>b){if(c="\\x",16>b||256<b)c+="0"}else c="\\u",4096>b&&(c+="0");c+=b.toString(16).toUpperCase()}return goog.string.jsEscapeCache_[a]=c};goog.string.contains=goog.string.internal.contains;goog.string.caseInsensitiveContains=goog.string.internal.caseInsensitiveContains;
goog.string.countOf=function(a,b){return a&&b?a.split(b).length-1:0};goog.string.removeAt=function(a,b,c){var d=a;0<=b&&b<a.length&&0<c&&(d=a.substr(0,b)+a.substr(b+c,a.length-b-c));return d};goog.string.remove=function(a,b){return a.replace(b,"")};goog.string.removeAll=function(a,b){b=new RegExp(goog.string.regExpEscape(b),"g");return a.replace(b,"")};goog.string.replaceAll=function(a,b,c){b=new RegExp(goog.string.regExpEscape(b),"g");return a.replace(b,c.replace(/\$/g,"$$$$"))};
goog.string.regExpEscape=function(a){return String(a).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")};goog.string.repeat=String.prototype.repeat?function(a,b){return a.repeat(b)}:function(a,b){return Array(b+1).join(a)};goog.string.padNumber=function(a,b,c){a=goog.isDef(c)?a.toFixed(c):String(a);c=a.indexOf(".");-1==c&&(c=a.length);return goog.string.repeat("0",Math.max(0,b-c))+a};goog.string.makeSafe=function(a){return null==a?"":String(a)};
goog.string.buildString=function(a){return Array.prototype.join.call(arguments,"")};goog.string.getRandomString=function(){return Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^goog.now()).toString(36)};goog.string.compareVersions=goog.string.internal.compareVersions;goog.string.hashCode=function(a){for(var b=0,c=0;c<a.length;++c)b=31*b+a.charCodeAt(c)>>>0;return b};goog.string.uniqueStringCounter_=2147483648*Math.random()|0;
goog.string.createUniqueString=function(){return"goog_"+goog.string.uniqueStringCounter_++};goog.string.toNumber=function(a){var b=Number(a);return 0==b&&goog.string.isEmptyOrWhitespace(a)?NaN:b};goog.string.isLowerCamelCase=function(a){return/^[a-z]+([A-Z][a-z]*)*$/.test(a)};goog.string.isUpperCamelCase=function(a){return/^([A-Z][a-z]*)+$/.test(a)};goog.string.toCamelCase=function(a){return String(a).replace(/\-([a-z])/g,function(a,c){return c.toUpperCase()})};
goog.string.toSelectorCase=function(a){return String(a).replace(/([A-Z])/g,"-$1").toLowerCase()};goog.string.toTitleCase=function(a,b){b=goog.isString(b)?goog.string.regExpEscape(b):"\\s";return a.replace(new RegExp("(^"+(b?"|["+b+"]+":"")+")([a-z])","g"),function(a,b,e){return b+e.toUpperCase()})};goog.string.capitalize=function(a){return String(a.charAt(0)).toUpperCase()+String(a.substr(1)).toLowerCase()};
goog.string.parseInt=function(a){isFinite(a)&&(a=String(a));return goog.isString(a)?/^\s*-?0x/i.test(a)?parseInt(a,16):parseInt(a,10):NaN};goog.string.splitLimit=function(a,b,c){a=a.split(b);for(var d=[];0<c&&a.length;)d.push(a.shift()),c--;a.length&&d.push(a.join(b));return d};goog.string.lastComponent=function(a,b){if(b)"string"==typeof b&&(b=[b]);else return a;for(var c=-1,d=0;d<b.length;d++)if(""!=b[d]){var e=a.lastIndexOf(b[d]);e>c&&(c=e)}return-1==c?a:a.slice(c+1)};
goog.string.editDistance=function(a,b){var c=[],d=[];if(a==b)return 0;if(!a.length||!b.length)return Math.max(a.length,b.length);for(var e=0;e<b.length+1;e++)c[e]=e;for(e=0;e<a.length;e++){d[0]=e+1;for(var f=0;f<b.length;f++)d[f+1]=Math.min(d[f]+1,c[f+1]+1,c[f]+Number(a[e]!=b[f]));for(f=0;f<c.length;f++)c[f]=d[f]}return d[b.length]};goog.labs.userAgent.engine={};goog.labs.userAgent.engine.isPresto=function(){return goog.labs.userAgent.util.matchUserAgent("Presto")};goog.labs.userAgent.engine.isTrident=function(){return goog.labs.userAgent.util.matchUserAgent("Trident")||goog.labs.userAgent.util.matchUserAgent("MSIE")};goog.labs.userAgent.engine.isEdge=function(){return goog.labs.userAgent.util.matchUserAgent("Edge")};
goog.labs.userAgent.engine.isWebKit=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("WebKit")&&!goog.labs.userAgent.engine.isEdge()};goog.labs.userAgent.engine.isGecko=function(){return goog.labs.userAgent.util.matchUserAgent("Gecko")&&!goog.labs.userAgent.engine.isWebKit()&&!goog.labs.userAgent.engine.isTrident()&&!goog.labs.userAgent.engine.isEdge()};
goog.labs.userAgent.engine.getVersion=function(){var a=goog.labs.userAgent.util.getUserAgent();if(a){a=goog.labs.userAgent.util.extractVersionTuples(a);var b=goog.labs.userAgent.engine.getEngineTuple_(a);if(b)return"Gecko"==b[0]?goog.labs.userAgent.engine.getVersionForKey_(a,"Firefox"):b[1];a=a[0];var c;if(a&&(c=a[2])&&(c=/Trident\/([^\s;]+)/.exec(c)))return c[1]}return""};
goog.labs.userAgent.engine.getEngineTuple_=function(a){if(!goog.labs.userAgent.engine.isEdge())return a[1];for(var b=0;b<a.length;b++){var c=a[b];if("Edge"==c[0])return c}};goog.labs.userAgent.engine.isVersionOrHigher=function(a){return 0<=goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(),a)};goog.labs.userAgent.engine.getVersionForKey_=function(a,b){return(a=goog.array.find(a,function(a){return b==a[0]}))&&a[1]||""};goog.labs.userAgent.platform={};goog.labs.userAgent.platform.isAndroid=function(){return goog.labs.userAgent.util.matchUserAgent("Android")};goog.labs.userAgent.platform.isIpod=function(){return goog.labs.userAgent.util.matchUserAgent("iPod")};goog.labs.userAgent.platform.isIphone=function(){return goog.labs.userAgent.util.matchUserAgent("iPhone")&&!goog.labs.userAgent.util.matchUserAgent("iPod")&&!goog.labs.userAgent.util.matchUserAgent("iPad")};goog.labs.userAgent.platform.isIpad=function(){return goog.labs.userAgent.util.matchUserAgent("iPad")};
goog.labs.userAgent.platform.isIos=function(){return goog.labs.userAgent.platform.isIphone()||goog.labs.userAgent.platform.isIpad()||goog.labs.userAgent.platform.isIpod()};goog.labs.userAgent.platform.isMacintosh=function(){return goog.labs.userAgent.util.matchUserAgent("Macintosh")};goog.labs.userAgent.platform.isLinux=function(){return goog.labs.userAgent.util.matchUserAgent("Linux")};goog.labs.userAgent.platform.isWindows=function(){return goog.labs.userAgent.util.matchUserAgent("Windows")};
goog.labs.userAgent.platform.isChromeOS=function(){return goog.labs.userAgent.util.matchUserAgent("CrOS")};goog.labs.userAgent.platform.isChromecast=function(){return goog.labs.userAgent.util.matchUserAgent("CrKey")};goog.labs.userAgent.platform.isKaiOS=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("KaiOS")};goog.labs.userAgent.platform.isGo2Phone=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("GAFP")};
goog.labs.userAgent.platform.getVersion=function(){var a=goog.labs.userAgent.util.getUserAgent(),b="";goog.labs.userAgent.platform.isWindows()?(b=/Windows (?:NT|Phone) ([0-9.]+)/,b=(a=b.exec(a))?a[1]:"0.0"):goog.labs.userAgent.platform.isIos()?(b=/(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/,b=(a=b.exec(a))&&a[1].replace(/_/g,".")):goog.labs.userAgent.platform.isMacintosh()?(b=/Mac OS X ([0-9_.]+)/,b=(a=b.exec(a))?a[1].replace(/_/g,"."):"10"):goog.labs.userAgent.platform.isKaiOS()?(b=/(?:KaiOS)\/(\S+)/i,
b=(a=b.exec(a))&&a[1]):goog.labs.userAgent.platform.isAndroid()?(b=/Android\s+([^\);]+)(\)|;)/,b=(a=b.exec(a))&&a[1]):goog.labs.userAgent.platform.isChromeOS()&&(b=/(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/,b=(a=b.exec(a))&&a[1]);return b||""};goog.labs.userAgent.platform.isVersionOrHigher=function(a){return 0<=goog.string.compareVersions(goog.labs.userAgent.platform.getVersion(),a)};goog.reflect={};goog.reflect.object=function(a,b){return b};goog.reflect.objectProperty=function(a,b){return a};goog.reflect.sinkValue=function(a){goog.reflect.sinkValue[" "](a);return a};goog.reflect.sinkValue[" "]=goog.nullFunction;goog.reflect.canAccessProperty=function(a,b){try{return goog.reflect.sinkValue(a[b]),!0}catch(c){}return!1};goog.reflect.cache=function(a,b,c,d){d=d?d(b):b;return Object.prototype.hasOwnProperty.call(a,d)?a[d]:a[d]=c(b)};goog.userAgent={};goog.userAgent.ASSUME_IE=!1;goog.userAgent.ASSUME_EDGE=!1;goog.userAgent.ASSUME_GECKO=!1;goog.userAgent.ASSUME_WEBKIT=!1;goog.userAgent.ASSUME_MOBILE_WEBKIT=!1;goog.userAgent.ASSUME_OPERA=!1;goog.userAgent.ASSUME_ANY_VERSION=!1;goog.userAgent.BROWSER_KNOWN_=goog.userAgent.ASSUME_IE||goog.userAgent.ASSUME_EDGE||goog.userAgent.ASSUME_GECKO||goog.userAgent.ASSUME_MOBILE_WEBKIT||goog.userAgent.ASSUME_WEBKIT||goog.userAgent.ASSUME_OPERA;goog.userAgent.getUserAgentString=function(){return goog.labs.userAgent.util.getUserAgent()};
goog.userAgent.getNavigatorTyped=function(){return goog.global.navigator||null};goog.userAgent.getNavigator=function(){return goog.userAgent.getNavigatorTyped()};goog.userAgent.OPERA=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_OPERA:goog.labs.userAgent.browser.isOpera();goog.userAgent.IE=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_IE:goog.labs.userAgent.browser.isIE();goog.userAgent.EDGE=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_EDGE:goog.labs.userAgent.engine.isEdge();
goog.userAgent.EDGE_OR_IE=goog.userAgent.EDGE||goog.userAgent.IE;goog.userAgent.GECKO=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_GECKO:goog.labs.userAgent.engine.isGecko();goog.userAgent.WEBKIT=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_WEBKIT||goog.userAgent.ASSUME_MOBILE_WEBKIT:goog.labs.userAgent.engine.isWebKit();goog.userAgent.isMobile_=function(){return goog.userAgent.WEBKIT&&goog.labs.userAgent.util.matchUserAgent("Mobile")};
goog.userAgent.MOBILE=goog.userAgent.ASSUME_MOBILE_WEBKIT||goog.userAgent.isMobile_();goog.userAgent.SAFARI=goog.userAgent.WEBKIT;goog.userAgent.determinePlatform_=function(){var a=goog.userAgent.getNavigatorTyped();return a&&a.platform||""};goog.userAgent.PLATFORM=goog.userAgent.determinePlatform_();goog.userAgent.ASSUME_MAC=!1;goog.userAgent.ASSUME_WINDOWS=!1;goog.userAgent.ASSUME_LINUX=!1;goog.userAgent.ASSUME_X11=!1;goog.userAgent.ASSUME_ANDROID=!1;goog.userAgent.ASSUME_IPHONE=!1;
goog.userAgent.ASSUME_IPAD=!1;goog.userAgent.ASSUME_IPOD=!1;goog.userAgent.ASSUME_KAIOS=!1;goog.userAgent.ASSUME_GO2PHONE=!1;goog.userAgent.PLATFORM_KNOWN_=goog.userAgent.ASSUME_MAC||goog.userAgent.ASSUME_WINDOWS||goog.userAgent.ASSUME_LINUX||goog.userAgent.ASSUME_X11||goog.userAgent.ASSUME_ANDROID||goog.userAgent.ASSUME_IPHONE||goog.userAgent.ASSUME_IPAD||goog.userAgent.ASSUME_IPOD;goog.userAgent.MAC=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_MAC:goog.labs.userAgent.platform.isMacintosh();
goog.userAgent.WINDOWS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_WINDOWS:goog.labs.userAgent.platform.isWindows();goog.userAgent.isLegacyLinux_=function(){return goog.labs.userAgent.platform.isLinux()||goog.labs.userAgent.platform.isChromeOS()};goog.userAgent.LINUX=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_LINUX:goog.userAgent.isLegacyLinux_();goog.userAgent.isX11_=function(){var a=goog.userAgent.getNavigatorTyped();return!!a&&goog.string.contains(a.appVersion||"","X11")};
goog.userAgent.X11=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_X11:goog.userAgent.isX11_();goog.userAgent.ANDROID=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_ANDROID:goog.labs.userAgent.platform.isAndroid();goog.userAgent.IPHONE=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPHONE:goog.labs.userAgent.platform.isIphone();goog.userAgent.IPAD=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPAD:goog.labs.userAgent.platform.isIpad();
goog.userAgent.IPOD=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPOD:goog.labs.userAgent.platform.isIpod();goog.userAgent.IOS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPHONE||goog.userAgent.ASSUME_IPAD||goog.userAgent.ASSUME_IPOD:goog.labs.userAgent.platform.isIos();goog.userAgent.KAIOS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_KAIOS:goog.labs.userAgent.platform.isKaiOS();goog.userAgent.GO2PHONE=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_GO2PHONE:goog.labs.userAgent.platform.isGo2Phone();
goog.userAgent.determineVersion_=function(){var a="",b=goog.userAgent.getVersionRegexResult_();b&&(a=b?b[1]:"");return goog.userAgent.IE&&(b=goog.userAgent.getDocumentMode_(),null!=b&&b>parseFloat(a))?String(b):a};
goog.userAgent.getVersionRegexResult_=function(){var a=goog.userAgent.getUserAgentString();if(goog.userAgent.GECKO)return/rv:([^\);]+)(\)|;)/.exec(a);if(goog.userAgent.EDGE)return/Edge\/([\d\.]+)/.exec(a);if(goog.userAgent.IE)return/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(goog.userAgent.WEBKIT)return/WebKit\/(\S+)/.exec(a);if(goog.userAgent.OPERA)return/(?:Version)[ \/]?(\S+)/.exec(a)};goog.userAgent.getDocumentMode_=function(){var a=goog.global.document;return a?a.documentMode:void 0};
goog.userAgent.VERSION=goog.userAgent.determineVersion_();goog.userAgent.compare=function(a,b){return goog.string.compareVersions(a,b)};goog.userAgent.isVersionOrHigherCache_={};goog.userAgent.isVersionOrHigher=function(a){return goog.userAgent.ASSUME_ANY_VERSION||goog.reflect.cache(goog.userAgent.isVersionOrHigherCache_,a,function(){return 0<=goog.string.compareVersions(goog.userAgent.VERSION,a)})};goog.userAgent.isVersion=goog.userAgent.isVersionOrHigher;
goog.userAgent.isDocumentModeOrHigher=function(a){return Number(goog.userAgent.DOCUMENT_MODE)>=a};goog.userAgent.isDocumentMode=goog.userAgent.isDocumentModeOrHigher;goog.userAgent.DOCUMENT_MODE=function(){if(goog.global.document&&goog.userAgent.IE)return goog.userAgent.getDocumentMode_()}();goog.userAgent.product={};goog.userAgent.product.ASSUME_FIREFOX=!1;goog.userAgent.product.ASSUME_IPHONE=!1;goog.userAgent.product.ASSUME_IPAD=!1;goog.userAgent.product.ASSUME_ANDROID=!1;goog.userAgent.product.ASSUME_CHROME=!1;goog.userAgent.product.ASSUME_SAFARI=!1;
goog.userAgent.product.PRODUCT_KNOWN_=goog.userAgent.ASSUME_IE||goog.userAgent.ASSUME_EDGE||goog.userAgent.ASSUME_OPERA||goog.userAgent.product.ASSUME_FIREFOX||goog.userAgent.product.ASSUME_IPHONE||goog.userAgent.product.ASSUME_IPAD||goog.userAgent.product.ASSUME_ANDROID||goog.userAgent.product.ASSUME_CHROME||goog.userAgent.product.ASSUME_SAFARI;goog.userAgent.product.OPERA=goog.userAgent.OPERA;goog.userAgent.product.IE=goog.userAgent.IE;goog.userAgent.product.EDGE=goog.userAgent.EDGE;
goog.userAgent.product.FIREFOX=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_FIREFOX:goog.labs.userAgent.browser.isFirefox();goog.userAgent.product.isIphoneOrIpod_=function(){return goog.labs.userAgent.platform.isIphone()||goog.labs.userAgent.platform.isIpod()};goog.userAgent.product.IPHONE=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_IPHONE:goog.userAgent.product.isIphoneOrIpod_();
goog.userAgent.product.IPAD=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_IPAD:goog.labs.userAgent.platform.isIpad();goog.userAgent.product.ANDROID=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_ANDROID:goog.labs.userAgent.browser.isAndroidBrowser();goog.userAgent.product.CHROME=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_CHROME:goog.labs.userAgent.browser.isChrome();
goog.userAgent.product.isSafariDesktop_=function(){return goog.labs.userAgent.browser.isSafari()&&!goog.labs.userAgent.platform.isIos()};goog.userAgent.product.SAFARI=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_SAFARI:goog.userAgent.product.isSafariDesktop_();goog.crypt.base64={};goog.crypt.base64.DEFAULT_ALPHABET_COMMON_="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";goog.crypt.base64.ENCODED_VALS=goog.crypt.base64.DEFAULT_ALPHABET_COMMON_+"+/=";goog.crypt.base64.ENCODED_VALS_WEBSAFE=goog.crypt.base64.DEFAULT_ALPHABET_COMMON_+"-_.";goog.crypt.base64.Alphabet={DEFAULT:0,NO_PADDING:1,WEBSAFE:2,WEBSAFE_DOT_PADDING:3,WEBSAFE_NO_PADDING:4};goog.crypt.base64.paddingChars_="=.";
goog.crypt.base64.isPadding_=function(a){return goog.string.contains(goog.crypt.base64.paddingChars_,a)};goog.crypt.base64.byteToCharMaps_={};goog.crypt.base64.charToByteMap_=null;goog.crypt.base64.ASSUME_NATIVE_SUPPORT_=goog.userAgent.GECKO||goog.userAgent.WEBKIT&&!goog.userAgent.product.SAFARI||goog.userAgent.OPERA;goog.crypt.base64.HAS_NATIVE_ENCODE_=goog.crypt.base64.ASSUME_NATIVE_SUPPORT_||"function"==typeof goog.global.btoa;
goog.crypt.base64.HAS_NATIVE_DECODE_=goog.crypt.base64.ASSUME_NATIVE_SUPPORT_||!goog.userAgent.product.SAFARI&&!goog.userAgent.IE&&"function"==typeof goog.global.atob;
goog.crypt.base64.encodeByteArray=function(a,b){goog.asserts.assert(goog.isArrayLike(a),"encodeByteArray takes an array as a parameter");void 0===b&&(b=goog.crypt.base64.Alphabet.DEFAULT);goog.crypt.base64.init_();b=goog.crypt.base64.byteToCharMaps_[b];for(var c=[],d=0;d<a.length;d+=3){var e=a[d],f=d+1<a.length,g=f?a[d+1]:0,h=d+2<a.length,k=h?a[d+2]:0,l=e>>2;e=(e&3)<<4|g>>4;g=(g&15)<<2|k>>6;k&=63;h||(k=64,f||(g=64));c.push(b[l],b[e],b[g]||"",b[k]||"")}return c.join("")};
goog.crypt.base64.encodeString=function(a,b){return goog.crypt.base64.HAS_NATIVE_ENCODE_&&!b?goog.global.btoa(a):goog.crypt.base64.encodeByteArray(goog.crypt.stringToByteArray(a),b)};goog.crypt.base64.decodeString=function(a,b){if(goog.crypt.base64.HAS_NATIVE_DECODE_&&!b)return goog.global.atob(a);var c="";goog.crypt.base64.decodeStringInternal_(a,function(a){c+=String.fromCharCode(a)});return c};
goog.crypt.base64.decodeStringToByteArray=function(a,b){var c=[];goog.crypt.base64.decodeStringInternal_(a,function(a){c.push(a)});return c};
goog.crypt.base64.decodeStringToUint8Array=function(a){goog.asserts.assert(!goog.userAgent.IE||goog.userAgent.isVersionOrHigher("10"),"Browser does not support typed arrays");var b=a.length,c=3*b/4;c%3?c=Math.floor(c):goog.crypt.base64.isPadding_(a[b-1])&&(c=goog.crypt.base64.isPadding_(a[b-2])?c-2:c-1);var d=new Uint8Array(c),e=0;goog.crypt.base64.decodeStringInternal_(a,function(a){d[e++]=a});return d.subarray(0,e)};
goog.crypt.base64.decodeStringInternal_=function(a,b){function c(b){for(;d<a.length;){var c=a.charAt(d++),e=goog.crypt.base64.charToByteMap_[c];if(null!=e)return e;if(!goog.string.isEmptyOrWhitespace(c))throw Error("Unknown base64 encoding at char: "+c);}return b}goog.crypt.base64.init_();for(var d=0;;){var e=c(-1),f=c(0),g=c(64),h=c(64);if(64===h&&-1===e)break;b(e<<2|f>>4);64!=g&&(b(f<<4&240|g>>2),64!=h&&b(g<<6&192|h))}};
goog.crypt.base64.init_=function(){if(!goog.crypt.base64.charToByteMap_){goog.crypt.base64.charToByteMap_={};for(var a=goog.crypt.base64.DEFAULT_ALPHABET_COMMON_.split(""),b=["+/=","+/","-_=","-_.","-_"],c=0;5>c;c++){var d=a.concat(b[c].split(""));goog.crypt.base64.byteToCharMaps_[c]=d;for(var e=0;e<d.length;e++){var f=d[e],g=goog.crypt.base64.charToByteMap_[f];void 0===g?goog.crypt.base64.charToByteMap_[f]=e:goog.asserts.assert(g===e)}}}};jspb.utils={};jspb.utils.split64Low=0;jspb.utils.split64High=0;jspb.utils.splitUint64=function(a){var b=a>>>0;a=Math.floor((a-b)/jspb.BinaryConstants.TWO_TO_32)>>>0;jspb.utils.split64Low=b;jspb.utils.split64High=a};jspb.utils.splitInt64=function(a){var b=0>a;a=Math.abs(a);var c=a>>>0;a=Math.floor((a-c)/jspb.BinaryConstants.TWO_TO_32);a>>>=0;b&&(a=~a>>>0,c=(~c>>>0)+1,4294967295<c&&(c=0,a++,4294967295<a&&(a=0)));jspb.utils.split64Low=c;jspb.utils.split64High=a};
jspb.utils.splitZigzag64=function(a){var b=0>a;a=2*Math.abs(a);jspb.utils.splitUint64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;b&&(0==a?0==c?c=a=4294967295:(c--,a=4294967295):a--);jspb.utils.split64Low=a;jspb.utils.split64High=c};
jspb.utils.splitFloat32=function(a){var b=0>a?1:0;a=b?-a:a;if(0===a)0<1/a?(jspb.utils.split64High=0,jspb.utils.split64Low=0):(jspb.utils.split64High=0,jspb.utils.split64Low=2147483648);else if(isNaN(a))jspb.utils.split64High=0,jspb.utils.split64Low=2147483647;else if(a>jspb.BinaryConstants.FLOAT32_MAX)jspb.utils.split64High=0,jspb.utils.split64Low=(b<<31|2139095040)>>>0;else if(a<jspb.BinaryConstants.FLOAT32_MIN)a=Math.round(a/Math.pow(2,-149)),jspb.utils.split64High=0,jspb.utils.split64Low=(b<<31|
a)>>>0;else{var c=Math.floor(Math.log(a)/Math.LN2);a*=Math.pow(2,-c);a=Math.round(a*jspb.BinaryConstants.TWO_TO_23);16777216<=a&&++c;jspb.utils.split64High=0;jspb.utils.split64Low=(b<<31|c+127<<23|a&8388607)>>>0}};
jspb.utils.splitFloat64=function(a){var b=0>a?1:0;a=b?-a:a;if(0===a)jspb.utils.split64High=0<1/a?0:2147483648,jspb.utils.split64Low=0;else if(isNaN(a))jspb.utils.split64High=2147483647,jspb.utils.split64Low=4294967295;else if(a>jspb.BinaryConstants.FLOAT64_MAX)jspb.utils.split64High=(b<<31|2146435072)>>>0,jspb.utils.split64Low=0;else if(a<jspb.BinaryConstants.FLOAT64_MIN){var c=a/Math.pow(2,-1074);a=c/jspb.BinaryConstants.TWO_TO_32;jspb.utils.split64High=(b<<31|a)>>>0;jspb.utils.split64Low=c>>>0}else{c=
a;var d=0;if(2<=c)for(;2<=c&&1023>d;)d++,c/=2;else for(;1>c&&-1022<d;)c*=2,d--;c=a*Math.pow(2,-d);a=c*jspb.BinaryConstants.TWO_TO_20&1048575;c=c*jspb.BinaryConstants.TWO_TO_52>>>0;jspb.utils.split64High=(b<<31|d+1023<<20|a)>>>0;jspb.utils.split64Low=c}};
jspb.utils.splitHash64=function(a){var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=a.charCodeAt(4),g=a.charCodeAt(5),h=a.charCodeAt(6);a=a.charCodeAt(7);jspb.utils.split64Low=b+(c<<8)+(d<<16)+(e<<24)>>>0;jspb.utils.split64High=f+(g<<8)+(h<<16)+(a<<24)>>>0};jspb.utils.joinUint64=function(a,b){return b*jspb.BinaryConstants.TWO_TO_32+(a>>>0)};
jspb.utils.joinInt64=function(a,b){var c=b&2147483648;c&&(a=~a+1>>>0,b=~b>>>0,0==a&&(b=b+1>>>0));a=jspb.utils.joinUint64(a,b);return c?-a:a};jspb.utils.toZigzag64=function(a,b,c){var d=b>>31;return c(a<<1^d,(b<<1|a>>>31)^d)};jspb.utils.joinZigzag64=function(a,b){return jspb.utils.fromZigzag64(a,b,jspb.utils.joinInt64)};jspb.utils.fromZigzag64=function(a,b,c){var d=-(a&1);return c((a>>>1|b<<31)^d,b>>>1^d)};
jspb.utils.joinFloat32=function(a,b){b=2*(a>>31)+1;var c=a>>>23&255;a&=8388607;return 255==c?a?NaN:Infinity*b:0==c?b*Math.pow(2,-149)*a:b*Math.pow(2,c-150)*(a+Math.pow(2,23))};jspb.utils.joinFloat64=function(a,b){var c=2*(b>>31)+1,d=b>>>20&2047;a=jspb.BinaryConstants.TWO_TO_32*(b&1048575)+a;return 2047==d?a?NaN:Infinity*c:0==d?c*Math.pow(2,-1074)*a:c*Math.pow(2,d-1075)*(a+jspb.BinaryConstants.TWO_TO_52)};
jspb.utils.joinHash64=function(a,b){return String.fromCharCode(a>>>0&255,a>>>8&255,a>>>16&255,a>>>24&255,b>>>0&255,b>>>8&255,b>>>16&255,b>>>24&255)};jspb.utils.DIGITS="0123456789abcdef".split("");jspb.utils.ZERO_CHAR_CODE_=48;jspb.utils.A_CHAR_CODE_=97;
jspb.utils.joinUnsignedDecimalString=function(a,b){function c(a,b){a=a?String(a):"";return b?"0000000".slice(a.length)+a:a}if(2097151>=b)return""+jspb.utils.joinUint64(a,b);var d=(a>>>24|b<<8)>>>0&16777215;b=b>>16&65535;a=(a&16777215)+6777216*d+6710656*b;d+=8147497*b;b*=2;1E7<=a&&(d+=Math.floor(a/1E7),a%=1E7);1E7<=d&&(b+=Math.floor(d/1E7),d%=1E7);return c(b,0)+c(d,b)+c(a,1)};
jspb.utils.joinSignedDecimalString=function(a,b){var c=b&2147483648;c&&(a=~a+1>>>0,b=~b+(0==a?1:0)>>>0);a=jspb.utils.joinUnsignedDecimalString(a,b);return c?"-"+a:a};jspb.utils.hash64ToDecimalString=function(a,b){jspb.utils.splitHash64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;return b?jspb.utils.joinSignedDecimalString(a,c):jspb.utils.joinUnsignedDecimalString(a,c)};
jspb.utils.hash64ArrayToDecimalStrings=function(a,b){for(var c=Array(a.length),d=0;d<a.length;d++)c[d]=jspb.utils.hash64ToDecimalString(a[d],b);return c};
jspb.utils.decimalStringToHash64=function(a){function b(a,b){for(var c=0;8>c&&(1!==a||0<b);c++)b=a*e[c]+b,e[c]=b&255,b>>>=8}function c(){for(var a=0;8>a;a++)e[a]=~e[a]&255}goog.asserts.assert(0<a.length);var d=!1;"-"===a[0]&&(d=!0,a=a.slice(1));for(var e=[0,0,0,0,0,0,0,0],f=0;f<a.length;f++)b(10,a.charCodeAt(f)-jspb.utils.ZERO_CHAR_CODE_);d&&(c(),b(1,1));return goog.crypt.byteArrayToString(e)};jspb.utils.splitDecimalString=function(a){jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a))};
jspb.utils.toHexDigit_=function(a){return String.fromCharCode(10>a?jspb.utils.ZERO_CHAR_CODE_+a:jspb.utils.A_CHAR_CODE_-10+a)};jspb.utils.fromHexCharCode_=function(a){return a>=jspb.utils.A_CHAR_CODE_?a-jspb.utils.A_CHAR_CODE_+10:a-jspb.utils.ZERO_CHAR_CODE_};jspb.utils.hash64ToHexString=function(a){var b=Array(18);b[0]="0";b[1]="x";for(var c=0;8>c;c++){var d=a.charCodeAt(7-c);b[2*c+2]=jspb.utils.toHexDigit_(d>>4);b[2*c+3]=jspb.utils.toHexDigit_(d&15)}return b.join("")};
jspb.utils.hexStringToHash64=function(a){a=a.toLowerCase();goog.asserts.assert(18==a.length);goog.asserts.assert("0"==a[0]);goog.asserts.assert("x"==a[1]);for(var b="",c=0;8>c;c++){var d=jspb.utils.fromHexCharCode_(a.charCodeAt(2*c+2)),e=jspb.utils.fromHexCharCode_(a.charCodeAt(2*c+3));b=String.fromCharCode(16*d+e)+b}return b};
jspb.utils.hash64ToNumber=function(a,b){jspb.utils.splitHash64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;return b?jspb.utils.joinInt64(a,c):jspb.utils.joinUint64(a,c)};jspb.utils.numberToHash64=function(a){jspb.utils.splitInt64(a);return jspb.utils.joinHash64(jspb.utils.split64Low,jspb.utils.split64High)};jspb.utils.countVarints=function(a,b,c){for(var d=0,e=b;e<c;e++)d+=a[e]>>7;return c-b-d};
jspb.utils.countVarintFields=function(a,b,c,d){var e=0;d=8*d+jspb.BinaryConstants.WireType.VARINT;if(128>d)for(;b<c&&a[b++]==d;)for(e++;;){var f=a[b++];if(0==(f&128))break}else for(;b<c;){for(f=d;128<f;){if(a[b]!=(f&127|128))return e;b++;f>>=7}if(a[b++]!=f)break;for(e++;f=a[b++],0!=(f&128););}return e};jspb.utils.countFixedFields_=function(a,b,c,d,e){var f=0;if(128>d)for(;b<c&&a[b++]==d;)f++,b+=e;else for(;b<c;){for(var g=d;128<g;){if(a[b++]!=(g&127|128))return f;g>>=7}if(a[b++]!=g)break;f++;b+=e}return f};
jspb.utils.countFixed32Fields=function(a,b,c,d){return jspb.utils.countFixedFields_(a,b,c,8*d+jspb.BinaryConstants.WireType.FIXED32,4)};jspb.utils.countFixed64Fields=function(a,b,c,d){return jspb.utils.countFixedFields_(a,b,c,8*d+jspb.BinaryConstants.WireType.FIXED64,8)};
jspb.utils.countDelimitedFields=function(a,b,c,d){var e=0;for(d=8*d+jspb.BinaryConstants.WireType.DELIMITED;b<c;){for(var f=d;128<f;){if(a[b++]!=(f&127|128))return e;f>>=7}if(a[b++]!=f)break;e++;for(var g=0,h=1;f=a[b++],g+=(f&127)*h,h*=128,0!=(f&128););b+=g}return e};jspb.utils.debugBytesToTextFormat=function(a){var b='"';if(a){a=jspb.utils.byteSourceToUint8Array(a);for(var c=0;c<a.length;c++)b+="\\x",16>a[c]&&(b+="0"),b+=a[c].toString(16)}return b+'"'};
jspb.utils.debugScalarToTextFormat=function(a){return"string"===typeof a?goog.string.quote(a):a.toString()};jspb.utils.stringToByteArray=function(a){for(var b=new Uint8Array(a.length),c=0;c<a.length;c++){var d=a.charCodeAt(c);if(255<d)throw Error("Conversion error: string contains codepoint outside of byte range");b[c]=d}return b};
jspb.utils.byteSourceToUint8Array=function(a){if(a.constructor===Uint8Array)return a;if(a.constructor===ArrayBuffer||"undefined"!=typeof Buffer&&a.constructor===Buffer||a.constructor===Array)return new Uint8Array(a);if(a.constructor===String)return goog.crypt.base64.decodeStringToUint8Array(a);goog.asserts.fail("Type not convertible to Uint8Array.");return new Uint8Array(0)};jspb.BinaryDecoder=function(a,b,c){this.bytes_=null;this.cursor_=this.end_=this.start_=0;this.error_=!1;a&&this.setBlock(a,b,c)};jspb.BinaryDecoder.instanceCache_=[];jspb.BinaryDecoder.alloc=function(a,b,c){if(jspb.BinaryDecoder.instanceCache_.length){var d=jspb.BinaryDecoder.instanceCache_.pop();a&&d.setBlock(a,b,c);return d}return new jspb.BinaryDecoder(a,b,c)};jspb.BinaryDecoder.prototype.free=function(){this.clear();100>jspb.BinaryDecoder.instanceCache_.length&&jspb.BinaryDecoder.instanceCache_.push(this)};
jspb.BinaryDecoder.prototype.clone=function(){return jspb.BinaryDecoder.alloc(this.bytes_,this.start_,this.end_-this.start_)};jspb.BinaryDecoder.prototype.clear=function(){this.bytes_=null;this.cursor_=this.end_=this.start_=0;this.error_=!1};jspb.BinaryDecoder.prototype.getBuffer=function(){return this.bytes_};
jspb.BinaryDecoder.prototype.setBlock=function(a,b,c){this.bytes_=jspb.utils.byteSourceToUint8Array(a);this.start_=void 0!==b?b:0;this.end_=void 0!==c?this.start_+c:this.bytes_.length;this.cursor_=this.start_};jspb.BinaryDecoder.prototype.getEnd=function(){return this.end_};jspb.BinaryDecoder.prototype.setEnd=function(a){this.end_=a};jspb.BinaryDecoder.prototype.reset=function(){this.cursor_=this.start_};jspb.BinaryDecoder.prototype.getCursor=function(){return this.cursor_};
jspb.BinaryDecoder.prototype.setCursor=function(a){this.cursor_=a};jspb.BinaryDecoder.prototype.advance=function(a){this.cursor_+=a;goog.asserts.assert(this.cursor_<=this.end_)};jspb.BinaryDecoder.prototype.atEnd=function(){return this.cursor_==this.end_};jspb.BinaryDecoder.prototype.pastEnd=function(){return this.cursor_>this.end_};jspb.BinaryDecoder.prototype.getError=function(){return this.error_||0>this.cursor_||this.cursor_>this.end_};
jspb.BinaryDecoder.prototype.readSplitVarint64=function(a){for(var b=128,c=0,d=0,e=0;4>e&&128<=b;e++)b=this.bytes_[this.cursor_++],c|=(b&127)<<7*e;128<=b&&(b=this.bytes_[this.cursor_++],c|=(b&127)<<28,d|=(b&127)>>4);if(128<=b)for(e=0;5>e&&128<=b;e++)b=this.bytes_[this.cursor_++],d|=(b&127)<<7*e+3;if(128>b)return a(c>>>0,d>>>0);goog.asserts.fail("Failed to read varint, encoding is invalid.");this.error_=!0};
jspb.BinaryDecoder.prototype.readSplitZigzagVarint64=function(a){return this.readSplitVarint64(function(b,c){return jspb.utils.fromZigzag64(b,c,a)})};jspb.BinaryDecoder.prototype.readSplitFixed64=function(a){var b=this.bytes_,c=this.cursor_;this.cursor_+=8;for(var d=0,e=0,f=c+7;f>=c;f--)d=d<<8|b[f],e=e<<8|b[f+4];return a(d,e)};jspb.BinaryDecoder.prototype.skipVarint=function(){for(;this.bytes_[this.cursor_]&128;)this.cursor_++;this.cursor_++};
jspb.BinaryDecoder.prototype.unskipVarint=function(a){for(;128<a;)this.cursor_--,a>>>=7;this.cursor_--};
jspb.BinaryDecoder.prototype.readUnsignedVarint32=function(){var a=this.bytes_;var b=a[this.cursor_+0];var c=b&127;if(128>b)return this.cursor_+=1,goog.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+1];c|=(b&127)<<7;if(128>b)return this.cursor_+=2,goog.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+2];c|=(b&127)<<14;if(128>b)return this.cursor_+=3,goog.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+3];c|=(b&127)<<21;if(128>b)return this.cursor_+=4,goog.asserts.assert(this.cursor_<=
this.end_),c;b=a[this.cursor_+4];c|=(b&15)<<28;if(128>b)return this.cursor_+=5,goog.asserts.assert(this.cursor_<=this.end_),c>>>0;this.cursor_+=5;128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&goog.asserts.assert(!1);goog.asserts.assert(this.cursor_<=this.end_);return c};jspb.BinaryDecoder.prototype.readSignedVarint32=jspb.BinaryDecoder.prototype.readUnsignedVarint32;jspb.BinaryDecoder.prototype.readUnsignedVarint32String=function(){return this.readUnsignedVarint32().toString()};
jspb.BinaryDecoder.prototype.readSignedVarint32String=function(){return this.readSignedVarint32().toString()};jspb.BinaryDecoder.prototype.readZigzagVarint32=function(){var a=this.readUnsignedVarint32();return a>>>1^-(a&1)};jspb.BinaryDecoder.prototype.readUnsignedVarint64=function(){return this.readSplitVarint64(jspb.utils.joinUint64)};jspb.BinaryDecoder.prototype.readUnsignedVarint64String=function(){return this.readSplitVarint64(jspb.utils.joinUnsignedDecimalString)};
jspb.BinaryDecoder.prototype.readSignedVarint64=function(){return this.readSplitVarint64(jspb.utils.joinInt64)};jspb.BinaryDecoder.prototype.readSignedVarint64String=function(){return this.readSplitVarint64(jspb.utils.joinSignedDecimalString)};jspb.BinaryDecoder.prototype.readZigzagVarint64=function(){return this.readSplitVarint64(jspb.utils.joinZigzag64)};jspb.BinaryDecoder.prototype.readZigzagVarintHash64=function(){return this.readSplitZigzagVarint64(jspb.utils.joinHash64)};
jspb.BinaryDecoder.prototype.readZigzagVarint64String=function(){return this.readSplitZigzagVarint64(jspb.utils.joinSignedDecimalString)};jspb.BinaryDecoder.prototype.readUint8=function(){var a=this.bytes_[this.cursor_+0];this.cursor_+=1;goog.asserts.assert(this.cursor_<=this.end_);return a};jspb.BinaryDecoder.prototype.readUint16=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1];this.cursor_+=2;goog.asserts.assert(this.cursor_<=this.end_);return a<<0|b<<8};
jspb.BinaryDecoder.prototype.readUint32=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1],c=this.bytes_[this.cursor_+2],d=this.bytes_[this.cursor_+3];this.cursor_+=4;goog.asserts.assert(this.cursor_<=this.end_);return(a<<0|b<<8|c<<16|d<<24)>>>0};jspb.BinaryDecoder.prototype.readUint64=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinUint64(a,b)};
jspb.BinaryDecoder.prototype.readUint64String=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinUnsignedDecimalString(a,b)};jspb.BinaryDecoder.prototype.readInt8=function(){var a=this.bytes_[this.cursor_+0];this.cursor_+=1;goog.asserts.assert(this.cursor_<=this.end_);return a<<24>>24};
jspb.BinaryDecoder.prototype.readInt16=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1];this.cursor_+=2;goog.asserts.assert(this.cursor_<=this.end_);return(a<<0|b<<8)<<16>>16};jspb.BinaryDecoder.prototype.readInt32=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1],c=this.bytes_[this.cursor_+2],d=this.bytes_[this.cursor_+3];this.cursor_+=4;goog.asserts.assert(this.cursor_<=this.end_);return a<<0|b<<8|c<<16|d<<24};
jspb.BinaryDecoder.prototype.readInt64=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinInt64(a,b)};jspb.BinaryDecoder.prototype.readInt64String=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinSignedDecimalString(a,b)};jspb.BinaryDecoder.prototype.readFloat=function(){var a=this.readUint32();return jspb.utils.joinFloat32(a,0)};
jspb.BinaryDecoder.prototype.readDouble=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinFloat64(a,b)};jspb.BinaryDecoder.prototype.readBool=function(){return!!this.bytes_[this.cursor_++]};jspb.BinaryDecoder.prototype.readEnum=function(){return this.readSignedVarint32()};
jspb.BinaryDecoder.prototype.readString=function(a){var b=this.bytes_,c=this.cursor_;a=c+a;for(var d=[],e="";c<a;){var f=b[c++];if(128>f)d.push(f);else if(192>f)continue;else if(224>f){var g=b[c++];d.push((f&31)<<6|g&63)}else if(240>f){g=b[c++];var h=b[c++];d.push((f&15)<<12|(g&63)<<6|h&63)}else if(248>f){g=b[c++];h=b[c++];var k=b[c++];f=(f&7)<<18|(g&63)<<12|(h&63)<<6|k&63;f-=65536;d.push((f>>10&1023)+55296,(f&1023)+56320)}8192<=d.length&&(e+=String.fromCharCode.apply(null,d),d.length=0)}e+=goog.crypt.byteArrayToString(d);
this.cursor_=c;return e};jspb.BinaryDecoder.prototype.readStringWithLength=function(){var a=this.readUnsignedVarint32();return this.readString(a)};jspb.BinaryDecoder.prototype.readBytes=function(a){if(0>a||this.cursor_+a>this.bytes_.length)return this.error_=!0,goog.asserts.fail("Invalid byte length!"),new Uint8Array(0);var b=this.bytes_.subarray(this.cursor_,this.cursor_+a);this.cursor_+=a;goog.asserts.assert(this.cursor_<=this.end_);return b};jspb.BinaryDecoder.prototype.readVarintHash64=function(){return this.readSplitVarint64(jspb.utils.joinHash64)};
jspb.BinaryDecoder.prototype.readFixedHash64=function(){var a=this.bytes_,b=this.cursor_,c=a[b+0],d=a[b+1],e=a[b+2],f=a[b+3],g=a[b+4],h=a[b+5],k=a[b+6];a=a[b+7];this.cursor_+=8;return String.fromCharCode(c,d,e,f,g,h,k,a)};jspb.BinaryReader=function(a,b,c){this.decoder_=jspb.BinaryDecoder.alloc(a,b,c);this.fieldCursor_=this.decoder_.getCursor();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;this.error_=!1;this.readCallbacks_=null};jspb.BinaryReader.instanceCache_=[];
jspb.BinaryReader.alloc=function(a,b,c){if(jspb.BinaryReader.instanceCache_.length){var d=jspb.BinaryReader.instanceCache_.pop();a&&d.decoder_.setBlock(a,b,c);return d}return new jspb.BinaryReader(a,b,c)};jspb.BinaryReader.prototype.alloc=jspb.BinaryReader.alloc;
jspb.BinaryReader.prototype.free=function(){this.decoder_.clear();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;this.error_=!1;this.readCallbacks_=null;100>jspb.BinaryReader.instanceCache_.length&&jspb.BinaryReader.instanceCache_.push(this)};jspb.BinaryReader.prototype.getFieldCursor=function(){return this.fieldCursor_};jspb.BinaryReader.prototype.getCursor=function(){return this.decoder_.getCursor()};
jspb.BinaryReader.prototype.getBuffer=function(){return this.decoder_.getBuffer()};jspb.BinaryReader.prototype.getFieldNumber=function(){return this.nextField_};jspb.BinaryReader.prototype.getWireType=function(){return this.nextWireType_};jspb.BinaryReader.prototype.isDelimited=function(){return this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED};jspb.BinaryReader.prototype.isEndGroup=function(){return this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP};
jspb.BinaryReader.prototype.getError=function(){return this.error_||this.decoder_.getError()};jspb.BinaryReader.prototype.setBlock=function(a,b,c){this.decoder_.setBlock(a,b,c);this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID};jspb.BinaryReader.prototype.reset=function(){this.decoder_.reset();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID};
jspb.BinaryReader.prototype.advance=function(a){this.decoder_.advance(a)};
jspb.BinaryReader.prototype.nextField=function(){if(this.decoder_.atEnd())return!1;if(this.getError())return goog.asserts.fail("Decoder hit an error"),!1;this.fieldCursor_=this.decoder_.getCursor();var a=this.decoder_.readUnsignedVarint32(),b=a>>>3;a&=7;if(a!=jspb.BinaryConstants.WireType.VARINT&&a!=jspb.BinaryConstants.WireType.FIXED32&&a!=jspb.BinaryConstants.WireType.FIXED64&&a!=jspb.BinaryConstants.WireType.DELIMITED&&a!=jspb.BinaryConstants.WireType.START_GROUP&&a!=jspb.BinaryConstants.WireType.END_GROUP)return goog.asserts.fail("Invalid wire type: %s (at position %s)",
a,this.fieldCursor_),this.error_=!0,!1;this.nextField_=b;this.nextWireType_=a;return!0};jspb.BinaryReader.prototype.unskipHeader=function(){this.decoder_.unskipVarint(this.nextField_<<3|this.nextWireType_)};jspb.BinaryReader.prototype.skipMatchingFields=function(){var a=this.nextField_;for(this.unskipHeader();this.nextField()&&this.getFieldNumber()==a;)this.skipField();this.decoder_.atEnd()||this.unskipHeader()};
jspb.BinaryReader.prototype.skipVarintField=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.VARINT?(goog.asserts.fail("Invalid wire type for skipVarintField"),this.skipField()):this.decoder_.skipVarint()};jspb.BinaryReader.prototype.skipDelimitedField=function(){if(this.nextWireType_!=jspb.BinaryConstants.WireType.DELIMITED)goog.asserts.fail("Invalid wire type for skipDelimitedField"),this.skipField();else{var a=this.decoder_.readUnsignedVarint32();this.decoder_.advance(a)}};
jspb.BinaryReader.prototype.skipFixed32Field=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.FIXED32?(goog.asserts.fail("Invalid wire type for skipFixed32Field"),this.skipField()):this.decoder_.advance(4)};jspb.BinaryReader.prototype.skipFixed64Field=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.FIXED64?(goog.asserts.fail("Invalid wire type for skipFixed64Field"),this.skipField()):this.decoder_.advance(8)};
jspb.BinaryReader.prototype.skipGroup=function(){var a=this.nextField_;do{if(!this.nextField()){goog.asserts.fail("Unmatched start-group tag: stream EOF");this.error_=!0;break}if(this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP){this.nextField_!=a&&(goog.asserts.fail("Unmatched end-group tag"),this.error_=!0);break}this.skipField()}while(1)};
jspb.BinaryReader.prototype.skipField=function(){switch(this.nextWireType_){case jspb.BinaryConstants.WireType.VARINT:this.skipVarintField();break;case jspb.BinaryConstants.WireType.FIXED64:this.skipFixed64Field();break;case jspb.BinaryConstants.WireType.DELIMITED:this.skipDelimitedField();break;case jspb.BinaryConstants.WireType.FIXED32:this.skipFixed32Field();break;case jspb.BinaryConstants.WireType.START_GROUP:this.skipGroup();break;default:goog.asserts.fail("Invalid wire encoding for field.")}};
jspb.BinaryReader.prototype.registerReadCallback=function(a,b){null===this.readCallbacks_&&(this.readCallbacks_={});goog.asserts.assert(!this.readCallbacks_[a]);this.readCallbacks_[a]=b};jspb.BinaryReader.prototype.runReadCallback=function(a){goog.asserts.assert(null!==this.readCallbacks_);a=this.readCallbacks_[a];goog.asserts.assert(a);return a(this)};
jspb.BinaryReader.prototype.readAny=function(a){this.nextWireType_=jspb.BinaryConstants.FieldTypeToWireType(a);var b=jspb.BinaryConstants.FieldType;switch(a){case b.DOUBLE:return this.readDouble();case b.FLOAT:return this.readFloat();case b.INT64:return this.readInt64();case b.UINT64:return this.readUint64();case b.INT32:return this.readInt32();case b.FIXED64:return this.readFixed64();case b.FIXED32:return this.readFixed32();case b.BOOL:return this.readBool();case b.STRING:return this.readString();
case b.GROUP:goog.asserts.fail("Group field type not supported in readAny()");case b.MESSAGE:goog.asserts.fail("Message field type not supported in readAny()");case b.BYTES:return this.readBytes();case b.UINT32:return this.readUint32();case b.ENUM:return this.readEnum();case b.SFIXED32:return this.readSfixed32();case b.SFIXED64:return this.readSfixed64();case b.SINT32:return this.readSint32();case b.SINT64:return this.readSint64();case b.FHASH64:return this.readFixedHash64();case b.VHASH64:return this.readVarintHash64();
default:goog.asserts.fail("Invalid field type in readAny()")}return 0};jspb.BinaryReader.prototype.readMessage=function(a,b){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var c=this.decoder_.getEnd(),d=this.decoder_.readUnsignedVarint32();d=this.decoder_.getCursor()+d;this.decoder_.setEnd(d);b(a,this);this.decoder_.setCursor(d);this.decoder_.setEnd(c)};
jspb.BinaryReader.prototype.readGroup=function(a,b,c){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.START_GROUP);goog.asserts.assert(this.nextField_==a);c(b,this);this.error_||this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP||(goog.asserts.fail("Group submessage did not end with an END_GROUP tag"),this.error_=!0)};
jspb.BinaryReader.prototype.getFieldDecoder=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32(),b=this.decoder_.getCursor(),c=b+a;a=jspb.BinaryDecoder.alloc(this.decoder_.getBuffer(),b,a);this.decoder_.setCursor(c);return a};jspb.BinaryReader.prototype.readInt32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint32()};
jspb.BinaryReader.prototype.readInt32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint32String()};jspb.BinaryReader.prototype.readInt64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64()};jspb.BinaryReader.prototype.readInt64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64String()};
jspb.BinaryReader.prototype.readUint32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint32()};jspb.BinaryReader.prototype.readUint32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint32String()};jspb.BinaryReader.prototype.readUint64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint64()};
jspb.BinaryReader.prototype.readUint64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint64String()};jspb.BinaryReader.prototype.readSint32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint32()};jspb.BinaryReader.prototype.readSint64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint64()};
jspb.BinaryReader.prototype.readSint64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint64String()};jspb.BinaryReader.prototype.readFixed32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readUint32()};jspb.BinaryReader.prototype.readFixed64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readUint64()};
jspb.BinaryReader.prototype.readFixed64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readUint64String()};jspb.BinaryReader.prototype.readSfixed32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readInt32()};jspb.BinaryReader.prototype.readSfixed32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readInt32().toString()};
jspb.BinaryReader.prototype.readSfixed64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readInt64()};jspb.BinaryReader.prototype.readSfixed64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readInt64String()};jspb.BinaryReader.prototype.readFloat=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readFloat()};
jspb.BinaryReader.prototype.readDouble=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readDouble()};jspb.BinaryReader.prototype.readBool=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return!!this.decoder_.readUnsignedVarint32()};jspb.BinaryReader.prototype.readEnum=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64()};
jspb.BinaryReader.prototype.readString=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32();return this.decoder_.readString(a)};jspb.BinaryReader.prototype.readBytes=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32();return this.decoder_.readBytes(a)};
jspb.BinaryReader.prototype.readVarintHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readVarintHash64()};jspb.BinaryReader.prototype.readSintHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarintHash64()};jspb.BinaryReader.prototype.readSplitVarint64=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSplitVarint64(a)};
jspb.BinaryReader.prototype.readSplitZigzagVarint64=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSplitVarint64(function(b,c){return jspb.utils.fromZigzag64(b,c,a)})};jspb.BinaryReader.prototype.readFixedHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readFixedHash64()};
jspb.BinaryReader.prototype.readSplitFixed64=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readSplitFixed64(a)};jspb.BinaryReader.prototype.readPackedField_=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var b=this.decoder_.readUnsignedVarint32();b=this.decoder_.getCursor()+b;for(var c=[];this.decoder_.getCursor()<b;)c.push(a.call(this.decoder_));return c};
jspb.BinaryReader.prototype.readPackedInt32=function(){return this.readPackedField_(this.decoder_.readSignedVarint32)};jspb.BinaryReader.prototype.readPackedInt32String=function(){return this.readPackedField_(this.decoder_.readSignedVarint32String)};jspb.BinaryReader.prototype.readPackedInt64=function(){return this.readPackedField_(this.decoder_.readSignedVarint64)};jspb.BinaryReader.prototype.readPackedInt64String=function(){return this.readPackedField_(this.decoder_.readSignedVarint64String)};
jspb.BinaryReader.prototype.readPackedUint32=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint32)};jspb.BinaryReader.prototype.readPackedUint32String=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint32String)};jspb.BinaryReader.prototype.readPackedUint64=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint64)};jspb.BinaryReader.prototype.readPackedUint64String=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint64String)};
jspb.BinaryReader.prototype.readPackedSint32=function(){return this.readPackedField_(this.decoder_.readZigzagVarint32)};jspb.BinaryReader.prototype.readPackedSint64=function(){return this.readPackedField_(this.decoder_.readZigzagVarint64)};jspb.BinaryReader.prototype.readPackedSint64String=function(){return this.readPackedField_(this.decoder_.readZigzagVarint64String)};jspb.BinaryReader.prototype.readPackedFixed32=function(){return this.readPackedField_(this.decoder_.readUint32)};
jspb.BinaryReader.prototype.readPackedFixed64=function(){return this.readPackedField_(this.decoder_.readUint64)};jspb.BinaryReader.prototype.readPackedFixed64String=function(){return this.readPackedField_(this.decoder_.readUint64String)};jspb.BinaryReader.prototype.readPackedSfixed32=function(){return this.readPackedField_(this.decoder_.readInt32)};jspb.BinaryReader.prototype.readPackedSfixed64=function(){return this.readPackedField_(this.decoder_.readInt64)};
jspb.BinaryReader.prototype.readPackedSfixed64String=function(){return this.readPackedField_(this.decoder_.readInt64String)};jspb.BinaryReader.prototype.readPackedFloat=function(){return this.readPackedField_(this.decoder_.readFloat)};jspb.BinaryReader.prototype.readPackedDouble=function(){return this.readPackedField_(this.decoder_.readDouble)};jspb.BinaryReader.prototype.readPackedBool=function(){return this.readPackedField_(this.decoder_.readBool)};jspb.BinaryReader.prototype.readPackedEnum=function(){return this.readPackedField_(this.decoder_.readEnum)};
jspb.BinaryReader.prototype.readPackedVarintHash64=function(){return this.readPackedField_(this.decoder_.readVarintHash64)};jspb.BinaryReader.prototype.readPackedFixedHash64=function(){return this.readPackedField_(this.decoder_.readFixedHash64)};jspb.BinaryEncoder=function(){this.buffer_=[]};jspb.BinaryEncoder.prototype.length=function(){return this.buffer_.length};jspb.BinaryEncoder.prototype.end=function(){var a=this.buffer_;this.buffer_=[];return a};
jspb.BinaryEncoder.prototype.writeSplitVarint64=function(a,b){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(b==Math.floor(b));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);for(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32);0<b||127<a;)this.buffer_.push(a&127|128),a=(a>>>7|b<<25)>>>0,b>>>=7;this.buffer_.push(a)};
jspb.BinaryEncoder.prototype.writeSplitFixed64=function(a,b){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(b==Math.floor(b));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32);this.writeUint32(a);this.writeUint32(b)};
jspb.BinaryEncoder.prototype.writeUnsignedVarint32=function(a){goog.asserts.assert(a==Math.floor(a));for(goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);127<a;)this.buffer_.push(a&127|128),a>>>=7;this.buffer_.push(a)};
jspb.BinaryEncoder.prototype.writeSignedVarint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);if(0<=a)this.writeUnsignedVarint32(a);else{for(var b=0;9>b;b++)this.buffer_.push(a&127|128),a>>=7;this.buffer_.push(1)}};
jspb.BinaryEncoder.prototype.writeUnsignedVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_64);jspb.utils.splitInt64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeSignedVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitInt64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeZigzagVarint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.writeUnsignedVarint32((a<<1^a>>31)>>>0)};jspb.BinaryEncoder.prototype.writeZigzagVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitZigzag64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeZigzagVarint64String=function(a){this.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(a))};jspb.BinaryEncoder.prototype.writeZigzagVarintHash64=function(a){var b=this;jspb.utils.splitHash64(a);jspb.utils.toZigzag64(jspb.utils.split64Low,jspb.utils.split64High,function(a,d){b.writeSplitVarint64(a>>>0,d>>>0)})};
jspb.BinaryEncoder.prototype.writeUint8=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&256>a);this.buffer_.push(a>>>0&255)};jspb.BinaryEncoder.prototype.writeUint16=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&65536>a);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255)};
jspb.BinaryEncoder.prototype.writeUint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);this.buffer_.push(a>>>16&255);this.buffer_.push(a>>>24&255)};jspb.BinaryEncoder.prototype.writeUint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_64);jspb.utils.splitUint64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeInt8=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(-128<=a&&128>a);this.buffer_.push(a>>>0&255)};jspb.BinaryEncoder.prototype.writeInt16=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(-32768<=a&&32768>a);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255)};
jspb.BinaryEncoder.prototype.writeInt32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);this.buffer_.push(a>>>16&255);this.buffer_.push(a>>>24&255)};
jspb.BinaryEncoder.prototype.writeInt64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitInt64(a);this.writeSplitFixed64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeInt64String=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(+a>=-jspb.BinaryConstants.TWO_TO_63&&+a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a));this.writeSplitFixed64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeFloat=function(a){goog.asserts.assert(Infinity===a||-Infinity===a||isNaN(a)||a>=-jspb.BinaryConstants.FLOAT32_MAX&&a<=jspb.BinaryConstants.FLOAT32_MAX);jspb.utils.splitFloat32(a);this.writeUint32(jspb.utils.split64Low)};
jspb.BinaryEncoder.prototype.writeDouble=function(a){goog.asserts.assert(Infinity===a||-Infinity===a||isNaN(a)||a>=-jspb.BinaryConstants.FLOAT64_MAX&&a<=jspb.BinaryConstants.FLOAT64_MAX);jspb.utils.splitFloat64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High)};jspb.BinaryEncoder.prototype.writeBool=function(a){goog.asserts.assert("boolean"===typeof a||"number"===typeof a);this.buffer_.push(a?1:0)};
jspb.BinaryEncoder.prototype.writeEnum=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.writeSignedVarint32(a)};jspb.BinaryEncoder.prototype.writeBytes=function(a){this.buffer_.push.apply(this.buffer_,a)};jspb.BinaryEncoder.prototype.writeVarintHash64=function(a){jspb.utils.splitHash64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeFixedHash64=function(a){jspb.utils.splitHash64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeString=function(a){for(var b=this.buffer_.length,c=0;c<a.length;c++){var d=a.charCodeAt(c);if(128>d)this.buffer_.push(d);else if(2048>d)this.buffer_.push(d>>6|192),this.buffer_.push(d&63|128);else if(65536>d)if(55296<=d&&56319>=d&&c+1<a.length){var e=a.charCodeAt(c+1);56320<=e&&57343>=e&&(d=1024*(d-55296)+e-56320+65536,this.buffer_.push(d>>18|240),this.buffer_.push(d>>12&63|128),this.buffer_.push(d>>6&63|128),this.buffer_.push(d&63|128),c++)}else this.buffer_.push(d>>
12|224),this.buffer_.push(d>>6&63|128),this.buffer_.push(d&63|128)}return this.buffer_.length-b};jspb.arith={};jspb.arith.UInt64=function(a,b){this.lo=a;this.hi=b};jspb.arith.UInt64.prototype.cmp=function(a){return this.hi<a.hi||this.hi==a.hi&&this.lo<a.lo?-1:this.hi==a.hi&&this.lo==a.lo?0:1};jspb.arith.UInt64.prototype.rightShift=function(){return new jspb.arith.UInt64((this.lo>>>1|(this.hi&1)<<31)>>>0,this.hi>>>1>>>0)};jspb.arith.UInt64.prototype.leftShift=function(){return new jspb.arith.UInt64(this.lo<<1>>>0,(this.hi<<1|this.lo>>>31)>>>0)};
jspb.arith.UInt64.prototype.msb=function(){return!!(this.hi&2147483648)};jspb.arith.UInt64.prototype.lsb=function(){return!!(this.lo&1)};jspb.arith.UInt64.prototype.zero=function(){return 0==this.lo&&0==this.hi};jspb.arith.UInt64.prototype.add=function(a){return new jspb.arith.UInt64((this.lo+a.lo&4294967295)>>>0>>>0,((this.hi+a.hi&4294967295)>>>0)+(4294967296<=this.lo+a.lo?1:0)>>>0)};
jspb.arith.UInt64.prototype.sub=function(a){return new jspb.arith.UInt64((this.lo-a.lo&4294967295)>>>0>>>0,((this.hi-a.hi&4294967295)>>>0)-(0>this.lo-a.lo?1:0)>>>0)};jspb.arith.UInt64.mul32x32=function(a,b){var c=a&65535;a>>>=16;var d=b&65535,e=b>>>16;b=c*d+65536*(c*e&65535)+65536*(a*d&65535);for(c=a*e+(c*e>>>16)+(a*d>>>16);4294967296<=b;)b-=4294967296,c+=1;return new jspb.arith.UInt64(b>>>0,c>>>0)};
jspb.arith.UInt64.prototype.mul=function(a){var b=jspb.arith.UInt64.mul32x32(this.lo,a);a=jspb.arith.UInt64.mul32x32(this.hi,a);a.hi=a.lo;a.lo=0;return b.add(a)};
jspb.arith.UInt64.prototype.div=function(a){if(0==a)return[];var b=new jspb.arith.UInt64(0,0),c=new jspb.arith.UInt64(this.lo,this.hi);a=new jspb.arith.UInt64(a,0);for(var d=new jspb.arith.UInt64(1,0);!a.msb();)a=a.leftShift(),d=d.leftShift();for(;!d.zero();)0>=a.cmp(c)&&(b=b.add(d),c=c.sub(a)),a=a.rightShift(),d=d.rightShift();return[b,c]};jspb.arith.UInt64.prototype.toString=function(){for(var a="",b=this;!b.zero();){b=b.div(10);var c=b[0];a=b[1].lo+a;b=c}""==a&&(a="0");return a};
jspb.arith.UInt64.fromString=function(a){for(var b=new jspb.arith.UInt64(0,0),c=new jspb.arith.UInt64(0,0),d=0;d<a.length;d++){if("0">a[d]||"9"<a[d])return null;var e=parseInt(a[d],10);c.lo=e;b=b.mul(10).add(c)}return b};jspb.arith.UInt64.prototype.clone=function(){return new jspb.arith.UInt64(this.lo,this.hi)};jspb.arith.Int64=function(a,b){this.lo=a;this.hi=b};
jspb.arith.Int64.prototype.add=function(a){return new jspb.arith.Int64((this.lo+a.lo&4294967295)>>>0>>>0,((this.hi+a.hi&4294967295)>>>0)+(4294967296<=this.lo+a.lo?1:0)>>>0)};jspb.arith.Int64.prototype.sub=function(a){return new jspb.arith.Int64((this.lo-a.lo&4294967295)>>>0>>>0,((this.hi-a.hi&4294967295)>>>0)-(0>this.lo-a.lo?1:0)>>>0)};jspb.arith.Int64.prototype.clone=function(){return new jspb.arith.Int64(this.lo,this.hi)};
jspb.arith.Int64.prototype.toString=function(){var a=0!=(this.hi&2147483648),b=new jspb.arith.UInt64(this.lo,this.hi);a&&(b=(new jspb.arith.UInt64(0,0)).sub(b));return(a?"-":"")+b.toString()};jspb.arith.Int64.fromString=function(a){var b=0<a.length&&"-"==a[0];b&&(a=a.substring(1));a=jspb.arith.UInt64.fromString(a);if(null===a)return null;b&&(a=(new jspb.arith.UInt64(0,0)).sub(a));return new jspb.arith.Int64(a.lo,a.hi)};jspb.BinaryWriter=function(){this.blocks_=[];this.totalLength_=0;this.encoder_=new jspb.BinaryEncoder;this.bookmarks_=[]};jspb.BinaryWriter.prototype.appendUint8Array_=function(a){var b=this.encoder_.end();this.blocks_.push(b);this.blocks_.push(a);this.totalLength_+=b.length+a.length};
jspb.BinaryWriter.prototype.beginDelimited_=function(a){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);a=this.encoder_.end();this.blocks_.push(a);this.totalLength_+=a.length;a.push(this.totalLength_);return a};jspb.BinaryWriter.prototype.endDelimited_=function(a){var b=a.pop();b=this.totalLength_+this.encoder_.length()-b;for(goog.asserts.assert(0<=b);127<b;)a.push(b&127|128),b>>>=7,this.totalLength_++;a.push(b);this.totalLength_++};
jspb.BinaryWriter.prototype.writeSerializedMessage=function(a,b,c){this.appendUint8Array_(a.subarray(b,c))};jspb.BinaryWriter.prototype.maybeWriteSerializedMessage=function(a,b,c){null!=a&&null!=b&&null!=c&&this.writeSerializedMessage(a,b,c)};jspb.BinaryWriter.prototype.reset=function(){this.blocks_=[];this.encoder_.end();this.totalLength_=0;this.bookmarks_=[]};
jspb.BinaryWriter.prototype.getResultBuffer=function(){goog.asserts.assert(0==this.bookmarks_.length);for(var a=new Uint8Array(this.totalLength_+this.encoder_.length()),b=this.blocks_,c=b.length,d=0,e=0;e<c;e++){var f=b[e];a.set(f,d);d+=f.length}b=this.encoder_.end();a.set(b,d);d+=b.length;goog.asserts.assert(d==a.length);this.blocks_=[a];return a};jspb.BinaryWriter.prototype.getResultBase64String=function(a){return goog.crypt.base64.encodeByteArray(this.getResultBuffer(),a)};
jspb.BinaryWriter.prototype.beginSubMessage=function(a){this.bookmarks_.push(this.beginDelimited_(a))};jspb.BinaryWriter.prototype.endSubMessage=function(){goog.asserts.assert(0<=this.bookmarks_.length);this.endDelimited_(this.bookmarks_.pop())};jspb.BinaryWriter.prototype.writeFieldHeader_=function(a,b){goog.asserts.assert(1<=a&&a==Math.floor(a));this.encoder_.writeUnsignedVarint32(8*a+b)};
jspb.BinaryWriter.prototype.writeAny=function(a,b,c){var d=jspb.BinaryConstants.FieldType;switch(a){case d.DOUBLE:this.writeDouble(b,c);break;case d.FLOAT:this.writeFloat(b,c);break;case d.INT64:this.writeInt64(b,c);break;case d.UINT64:this.writeUint64(b,c);break;case d.INT32:this.writeInt32(b,c);break;case d.FIXED64:this.writeFixed64(b,c);break;case d.FIXED32:this.writeFixed32(b,c);break;case d.BOOL:this.writeBool(b,c);break;case d.STRING:this.writeString(b,c);break;case d.GROUP:goog.asserts.fail("Group field type not supported in writeAny()");
break;case d.MESSAGE:goog.asserts.fail("Message field type not supported in writeAny()");break;case d.BYTES:this.writeBytes(b,c);break;case d.UINT32:this.writeUint32(b,c);break;case d.ENUM:this.writeEnum(b,c);break;case d.SFIXED32:this.writeSfixed32(b,c);break;case d.SFIXED64:this.writeSfixed64(b,c);break;case d.SINT32:this.writeSint32(b,c);break;case d.SINT64:this.writeSint64(b,c);break;case d.FHASH64:this.writeFixedHash64(b,c);break;case d.VHASH64:this.writeVarintHash64(b,c);break;default:goog.asserts.fail("Invalid field type in writeAny()")}};
jspb.BinaryWriter.prototype.writeUnsignedVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeUnsignedVarint32(b))};jspb.BinaryWriter.prototype.writeSignedVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(b))};jspb.BinaryWriter.prototype.writeUnsignedVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeUnsignedVarint64(b))};
jspb.BinaryWriter.prototype.writeSignedVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint64(b))};jspb.BinaryWriter.prototype.writeZigzagVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint32(b))};jspb.BinaryWriter.prototype.writeZigzagVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint64(b))};
jspb.BinaryWriter.prototype.writeZigzagVarint64String_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint64String(b))};jspb.BinaryWriter.prototype.writeZigzagVarintHash64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarintHash64(b))};
jspb.BinaryWriter.prototype.writeInt32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeSignedVarint32_(a,b))};jspb.BinaryWriter.prototype.writeInt32String=function(a,b){null!=b&&(b=parseInt(b,10),goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeSignedVarint32_(a,b))};
jspb.BinaryWriter.prototype.writeInt64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeSignedVarint64_(a,b))};jspb.BinaryWriter.prototype.writeInt64String=function(a,b){null!=b&&(b=jspb.arith.Int64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSplitVarint64(b.lo,b.hi))};
jspb.BinaryWriter.prototype.writeUint32=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeUnsignedVarint32_(a,b))};jspb.BinaryWriter.prototype.writeUint32String=function(a,b){null!=b&&(b=parseInt(b,10),goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeUnsignedVarint32_(a,b))};jspb.BinaryWriter.prototype.writeUint64=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_64),this.writeUnsignedVarint64_(a,b))};
jspb.BinaryWriter.prototype.writeUint64String=function(a,b){null!=b&&(b=jspb.arith.UInt64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSplitVarint64(b.lo,b.hi))};jspb.BinaryWriter.prototype.writeSint32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeZigzagVarint32_(a,b))};
jspb.BinaryWriter.prototype.writeSint64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeZigzagVarint64_(a,b))};jspb.BinaryWriter.prototype.writeSintHash64=function(a,b){null!=b&&this.writeZigzagVarintHash64_(a,b)};jspb.BinaryWriter.prototype.writeSint64String=function(a,b){null!=b&&this.writeZigzagVarint64String_(a,b)};
jspb.BinaryWriter.prototype.writeFixed32=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeUint32(b))};jspb.BinaryWriter.prototype.writeFixed64=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_64),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeUint64(b))};
jspb.BinaryWriter.prototype.writeFixed64String=function(a,b){null!=b&&(b=jspb.arith.UInt64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeSplitFixed64(b.lo,b.hi))};jspb.BinaryWriter.prototype.writeSfixed32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeInt32(b))};
jspb.BinaryWriter.prototype.writeSfixed64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeInt64(b))};jspb.BinaryWriter.prototype.writeSfixed64String=function(a,b){null!=b&&(b=jspb.arith.Int64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeSplitFixed64(b.lo,b.hi))};
jspb.BinaryWriter.prototype.writeFloat=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeFloat(b))};jspb.BinaryWriter.prototype.writeDouble=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeDouble(b))};
jspb.BinaryWriter.prototype.writeBool=function(a,b){null!=b&&(goog.asserts.assert("boolean"===typeof b||"number"===typeof b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeBool(b))};jspb.BinaryWriter.prototype.writeEnum=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(b))};
jspb.BinaryWriter.prototype.writeString=function(a,b){null!=b&&(a=this.beginDelimited_(a),this.encoder_.writeString(b),this.endDelimited_(a))};jspb.BinaryWriter.prototype.writeBytes=function(a,b){null!=b&&(b=jspb.utils.byteSourceToUint8Array(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(b.length),this.appendUint8Array_(b))};jspb.BinaryWriter.prototype.writeMessage=function(a,b,c){null!=b&&(a=this.beginDelimited_(a),c(b,this),this.endDelimited_(a))};
jspb.BinaryWriter.prototype.writeMessageSet=function(a,b,c){null!=b&&(this.writeFieldHeader_(1,jspb.BinaryConstants.WireType.START_GROUP),this.writeFieldHeader_(2,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(a),a=this.beginDelimited_(3),c(b,this),this.endDelimited_(a),this.writeFieldHeader_(1,jspb.BinaryConstants.WireType.END_GROUP))};
jspb.BinaryWriter.prototype.writeGroup=function(a,b,c){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.START_GROUP),c(b,this),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.END_GROUP))};jspb.BinaryWriter.prototype.writeFixedHash64=function(a,b){null!=b&&(goog.asserts.assert(8==b.length),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeFixedHash64(b))};
jspb.BinaryWriter.prototype.writeVarintHash64=function(a,b){null!=b&&(goog.asserts.assert(8==b.length),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeVarintHash64(b))};jspb.BinaryWriter.prototype.writeSplitFixed64=function(a,b,c){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64);this.encoder_.writeSplitFixed64(b,c)};
jspb.BinaryWriter.prototype.writeSplitVarint64=function(a,b,c){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT);this.encoder_.writeSplitVarint64(b,c)};jspb.BinaryWriter.prototype.writeSplitZigzagVarint64=function(a,b,c){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT);var d=this.encoder_;jspb.utils.toZigzag64(b,c,function(a,b){d.writeSplitVarint64(a>>>0,b>>>0)})};
jspb.BinaryWriter.prototype.writeRepeatedInt32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSignedVarint32_(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedInt32String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeInt32String(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedInt64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSignedVarint64_(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedSplitFixed64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitFixed64(a,c(b[e]),d(b[e]))};jspb.BinaryWriter.prototype.writeRepeatedSplitVarint64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitVarint64(a,c(b[e]),d(b[e]))};jspb.BinaryWriter.prototype.writeRepeatedSplitZigzagVarint64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitZigzagVarint64(a,c(b[e]),d(b[e]))};
jspb.BinaryWriter.prototype.writeRepeatedInt64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeInt64String(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedUint32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUnsignedVarint32_(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedUint32String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUint32String(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedUint64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUnsignedVarint64_(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedUint64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUint64String(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedSint32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint32_(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedSint64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint64_(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedSint64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint64String_(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedSintHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarintHash64_(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedFixed32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed32(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedFixed64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed64(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedFixed64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed64String(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedSfixed32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed32(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedSfixed64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed64(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedSfixed64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed64String(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedFloat=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFloat(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedDouble=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeDouble(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedBool=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeBool(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedEnum=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeEnum(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedString=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeString(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedBytes=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeBytes(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedMessage=function(a,b,c){if(null!=b)for(var d=0;d<b.length;d++){var e=this.beginDelimited_(a);c(b[d],this);this.endDelimited_(e)}};
jspb.BinaryWriter.prototype.writeRepeatedGroup=function(a,b,c){if(null!=b)for(var d=0;d<b.length;d++)this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.START_GROUP),c(b[d],this),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.END_GROUP)};jspb.BinaryWriter.prototype.writeRepeatedFixedHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixedHash64(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedVarintHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeVarintHash64(a,b[c])};jspb.BinaryWriter.prototype.writePackedInt32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint32(b[c]);this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedInt32String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint32(parseInt(b[c],10));this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedInt64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint64(b[c]);this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedSplitFixed64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=0;e<b.length;e++)this.encoder_.writeSplitFixed64(c(b[e]),d(b[e]));this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedSplitVarint64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=0;e<b.length;e++)this.encoder_.writeSplitVarint64(c(b[e]),d(b[e]));this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedSplitZigzagVarint64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=this.encoder_,f=0;f<b.length;f++)jspb.utils.toZigzag64(c(b[f]),d(b[f]),function(a,b){e.writeSplitVarint64(a>>>0,b>>>0)});this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedInt64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++){var d=jspb.arith.Int64.fromString(b[c]);this.encoder_.writeSplitVarint64(d.lo,d.hi)}this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedUint32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint32(b[c]);this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedUint32String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint32(parseInt(b[c],10));this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedUint64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint64(b[c]);this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedUint64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++){var d=jspb.arith.UInt64.fromString(b[c]);this.encoder_.writeSplitVarint64(d.lo,d.hi)}this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedSint32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarint32(b[c]);this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedSint64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarint64(b[c]);this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedSint64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(b[c]));this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedSintHash64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarintHash64(b[c]);this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedFixed32=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeUint32(b[a])};jspb.BinaryWriter.prototype.writePackedFixed64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeUint64(b[a])};
jspb.BinaryWriter.prototype.writePackedFixed64String=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++){var c=jspb.arith.UInt64.fromString(b[a]);this.encoder_.writeSplitFixed64(c.lo,c.hi)}};
jspb.BinaryWriter.prototype.writePackedSfixed32=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeInt32(b[a])};jspb.BinaryWriter.prototype.writePackedSfixed64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeInt64(b[a])};
jspb.BinaryWriter.prototype.writePackedSfixed64String=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeInt64String(b[a])};jspb.BinaryWriter.prototype.writePackedFloat=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeFloat(b[a])};
jspb.BinaryWriter.prototype.writePackedDouble=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeDouble(b[a])};jspb.BinaryWriter.prototype.writePackedBool=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(b.length),a=0;a<b.length;a++)this.encoder_.writeBool(b[a])};
jspb.BinaryWriter.prototype.writePackedEnum=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeEnum(b[c]);this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedFixedHash64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeFixedHash64(b[a])};
jspb.BinaryWriter.prototype.writePackedVarintHash64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeVarintHash64(b[c]);this.endDelimited_(a)}};jspb.Map=function(a,b){this.arr_=a;this.valueCtor_=b;this.map_={};this.arrClean=!0;0<this.arr_.length&&this.loadFromArray_()};jspb.Map.prototype.loadFromArray_=function(){for(var a=0;a<this.arr_.length;a++){var b=this.arr_[a],c=b[0];this.map_[c.toString()]=new jspb.Map.Entry_(c,b[1])}this.arrClean=!0};
jspb.Map.prototype.toArray=function(){if(this.arrClean){if(this.valueCtor_){var a=this.map_,b;for(b in a)if(Object.prototype.hasOwnProperty.call(a,b)){var c=a[b].valueWrapper;c&&c.toArray()}}}else{this.arr_.length=0;a=this.stringKeys_();a.sort();for(b=0;b<a.length;b++){var d=this.map_[a[b]];(c=d.valueWrapper)&&c.toArray();this.arr_.push([d.key,d.value])}this.arrClean=!0}return this.arr_};
jspb.Map.prototype.toObject=function(a,b){for(var c=this.toArray(),d=[],e=0;e<c.length;e++){var f=this.map_[c[e][0].toString()];this.wrapEntry_(f);var g=f.valueWrapper;g?(goog.asserts.assert(b),d.push([f.key,b(a,g)])):d.push([f.key,f.value])}return d};jspb.Map.fromObject=function(a,b,c){b=new jspb.Map([],b);for(var d=0;d<a.length;d++){var e=a[d][0],f=c(a[d][1]);b.set(e,f)}return b};jspb.Map.ArrayIteratorIterable_=function(a){this.idx_=0;this.arr_=a};
jspb.Map.ArrayIteratorIterable_.prototype.next=function(){return this.idx_<this.arr_.length?{done:!1,value:this.arr_[this.idx_++]}:{done:!0,value:void 0}};"undefined"!=typeof Symbol&&(jspb.Map.ArrayIteratorIterable_.prototype[Symbol.iterator]=function(){return this});jspb.Map.prototype.getLength=function(){return this.stringKeys_().length};jspb.Map.prototype.clear=function(){this.map_={};this.arrClean=!1};
jspb.Map.prototype.del=function(a){a=a.toString();var b=this.map_.hasOwnProperty(a);delete this.map_[a];this.arrClean=!1;return b};jspb.Map.prototype.getEntryList=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++){var d=this.map_[b[c]];a.push([d.key,d.value])}return a};jspb.Map.prototype.entries=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++){var d=this.map_[b[c]];a.push([d.key,this.wrapEntry_(d)])}return new jspb.Map.ArrayIteratorIterable_(a)};
jspb.Map.prototype.keys=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++)a.push(this.map_[b[c]].key);return new jspb.Map.ArrayIteratorIterable_(a)};jspb.Map.prototype.values=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++)a.push(this.wrapEntry_(this.map_[b[c]]));return new jspb.Map.ArrayIteratorIterable_(a)};
jspb.Map.prototype.forEach=function(a,b){var c=this.stringKeys_();c.sort();for(var d=0;d<c.length;d++){var e=this.map_[c[d]];a.call(b,this.wrapEntry_(e),e.key,this)}};jspb.Map.prototype.set=function(a,b){var c=new jspb.Map.Entry_(a);this.valueCtor_?(c.valueWrapper=b,c.value=b.toArray()):c.value=b;this.map_[a.toString()]=c;this.arrClean=!1;return this};jspb.Map.prototype.wrapEntry_=function(a){return this.valueCtor_?(a.valueWrapper||(a.valueWrapper=new this.valueCtor_(a.value)),a.valueWrapper):a.value};
jspb.Map.prototype.get=function(a){if(a=this.map_[a.toString()])return this.wrapEntry_(a)};jspb.Map.prototype.has=function(a){return a.toString()in this.map_};jspb.Map.prototype.serializeBinary=function(a,b,c,d,e){var f=this.stringKeys_();f.sort();for(var g=0;g<f.length;g++){var h=this.map_[f[g]];b.beginSubMessage(a);c.call(b,1,h.key);this.valueCtor_?d.call(b,2,this.wrapEntry_(h),e):d.call(b,2,h.value);b.endSubMessage()}};
jspb.Map.deserializeBinary=function(a,b,c,d,e,f,g){for(;b.nextField()&&!b.isEndGroup();){var h=b.getFieldNumber();1==h?f=c.call(b):2==h&&(a.valueCtor_?(goog.asserts.assert(e),g||(g=new a.valueCtor_),d.call(b,g,e)):g=d.call(b))}goog.asserts.assert(void 0!=f);goog.asserts.assert(void 0!=g);a.set(f,g)};jspb.Map.prototype.stringKeys_=function(){var a=this.map_,b=[],c;for(c in a)Object.prototype.hasOwnProperty.call(a,c)&&b.push(c);return b};
jspb.Map.Entry_=function(a,b){this.key=a;this.value=b;this.valueWrapper=void 0};jspb.ExtensionFieldInfo=function(a,b,c,d,e){this.fieldIndex=a;this.fieldName=b;this.ctor=c;this.toObjectFn=d;this.isRepeated=e};jspb.ExtensionFieldBinaryInfo=function(a,b,c,d,e,f){this.fieldInfo=a;this.binaryReaderFn=b;this.binaryWriterFn=c;this.binaryMessageSerializeFn=d;this.binaryMessageDeserializeFn=e;this.isPacked=f};jspb.ExtensionFieldInfo.prototype.isMessageType=function(){return!!this.ctor};jspb.Message=function(){};jspb.Message.GENERATE_TO_OBJECT=!0;jspb.Message.GENERATE_FROM_OBJECT=!goog.DISALLOW_TEST_ONLY_CODE;
jspb.Message.GENERATE_TO_STRING=!0;jspb.Message.ASSUME_LOCAL_ARRAYS=!1;jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS=!0;jspb.Message.SUPPORTS_UINT8ARRAY_="function"==typeof Uint8Array;jspb.Message.prototype.getJsPbMessageId=function(){return this.messageId_};jspb.Message.getIndex_=function(a,b){return b+a.arrayIndexOffset_};jspb.Message.hiddenES6Property_=function(){};jspb.Message.getFieldNumber_=function(a,b){return b-a.arrayIndexOffset_};
jspb.Message.initialize=function(a,b,c,d,e,f){a.wrappers_=null;b||(b=c?[c]:[]);a.messageId_=c?String(c):void 0;a.arrayIndexOffset_=0===c?-1:0;a.array=b;jspb.Message.initPivotAndExtensionObject_(a,d);a.convertedPrimitiveFields_={};jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS||(a.repeatedFields=e);if(e)for(b=0;b<e.length;b++)c=e[b],c<a.pivot_?(c=jspb.Message.getIndex_(a,c),a.array[c]=a.array[c]||jspb.Message.EMPTY_LIST_SENTINEL_):(jspb.Message.maybeInitEmptyExtensionObject_(a),a.extensionObject_[c]=
a.extensionObject_[c]||jspb.Message.EMPTY_LIST_SENTINEL_);if(f&&f.length)for(b=0;b<f.length;b++)jspb.Message.computeOneofCase(a,f[b])};jspb.Message.EMPTY_LIST_SENTINEL_=goog.DEBUG&&Object.freeze?Object.freeze([]):[];jspb.Message.isArray_=function(a){return jspb.Message.ASSUME_LOCAL_ARRAYS?a instanceof Array:Array.isArray(a)};jspb.Message.isExtensionObject_=function(a){return null!==a&&"object"==typeof a&&!jspb.Message.isArray_(a)&&!(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)};
jspb.Message.initPivotAndExtensionObject_=function(a,b){var c=a.array.length,d=-1;if(c&&(d=c-1,c=a.array[d],jspb.Message.isExtensionObject_(c))){a.pivot_=jspb.Message.getFieldNumber_(a,d);a.extensionObject_=c;return}-1<b?(a.pivot_=Math.max(b,jspb.Message.getFieldNumber_(a,d+1)),a.extensionObject_=null):a.pivot_=Number.MAX_VALUE};jspb.Message.maybeInitEmptyExtensionObject_=function(a){var b=jspb.Message.getIndex_(a,a.pivot_);a.array[b]||(a.extensionObject_=a.array[b]={})};
jspb.Message.toObjectList=function(a,b,c){for(var d=[],e=0;e<a.length;e++)d[e]=b.call(a[e],c,a[e]);return d};jspb.Message.toObjectExtension=function(a,b,c,d,e){for(var f in c){var g=c[f],h=d.call(a,g);if(null!=h){for(var k in g.fieldName)if(g.fieldName.hasOwnProperty(k))break;b[k]=g.toObjectFn?g.isRepeated?jspb.Message.toObjectList(h,g.toObjectFn,e):g.toObjectFn(e,h):h}}};
jspb.Message.serializeBinaryExtensions=function(a,b,c,d){for(var e in c){var f=c[e],g=f.fieldInfo;if(!f.binaryWriterFn)throw Error("Message extension present that was generated without binary serialization support");var h=d.call(a,g);if(null!=h)if(g.isMessageType())if(f.binaryMessageSerializeFn)f.binaryWriterFn.call(b,g.fieldIndex,h,f.binaryMessageSerializeFn);else throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
else f.binaryWriterFn.call(b,g.fieldIndex,h)}};jspb.Message.readBinaryExtension=function(a,b,c,d,e){var f=c[b.getFieldNumber()];if(f){c=f.fieldInfo;if(!f.binaryReaderFn)throw Error("Deserializing extension whose generated code does not support binary format");if(c.isMessageType()){var g=new c.ctor;f.binaryReaderFn.call(b,g,f.binaryMessageDeserializeFn)}else g=f.binaryReaderFn.call(b);c.isRepeated&&!f.isPacked?(b=d.call(a,c))?b.push(g):e.call(a,c,[g]):e.call(a,c,g)}else b.skipField()};
jspb.Message.getField=function(a,b){if(b<a.pivot_){b=jspb.Message.getIndex_(a,b);var c=a.array[b];return c===jspb.Message.EMPTY_LIST_SENTINEL_?a.array[b]=[]:c}if(a.extensionObject_)return c=a.extensionObject_[b],c===jspb.Message.EMPTY_LIST_SENTINEL_?a.extensionObject_[b]=[]:c};jspb.Message.getRepeatedField=function(a,b){return jspb.Message.getField(a,b)};jspb.Message.getOptionalFloatingPointField=function(a,b){a=jspb.Message.getField(a,b);return null==a?a:+a};
jspb.Message.getBooleanField=function(a,b){a=jspb.Message.getField(a,b);return null==a?a:!!a};jspb.Message.getRepeatedFloatingPointField=function(a,b){var c=jspb.Message.getRepeatedField(a,b);a.convertedPrimitiveFields_||(a.convertedPrimitiveFields_={});if(!a.convertedPrimitiveFields_[b]){for(var d=0;d<c.length;d++)c[d]=+c[d];a.convertedPrimitiveFields_[b]=!0}return c};
jspb.Message.getRepeatedBooleanField=function(a,b){var c=jspb.Message.getRepeatedField(a,b);a.convertedPrimitiveFields_||(a.convertedPrimitiveFields_={});if(!a.convertedPrimitiveFields_[b]){for(var d=0;d<c.length;d++)c[d]=!!c[d];a.convertedPrimitiveFields_[b]=!0}return c};
jspb.Message.bytesAsB64=function(a){if(null==a||"string"===typeof a)return a;if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)return goog.crypt.base64.encodeByteArray(a);goog.asserts.fail("Cannot coerce to b64 string: "+goog.typeOf(a));return null};jspb.Message.bytesAsU8=function(a){if(null==a||a instanceof Uint8Array)return a;if("string"===typeof a)return goog.crypt.base64.decodeStringToUint8Array(a);goog.asserts.fail("Cannot coerce to Uint8Array: "+goog.typeOf(a));return null};
jspb.Message.bytesListAsB64=function(a){jspb.Message.assertConsistentTypes_(a);return a.length&&"string"!==typeof a[0]?goog.array.map(a,jspb.Message.bytesAsB64):a};jspb.Message.bytesListAsU8=function(a){jspb.Message.assertConsistentTypes_(a);return!a.length||a[0]instanceof Uint8Array?a:goog.array.map(a,jspb.Message.bytesAsU8)};
jspb.Message.assertConsistentTypes_=function(a){if(goog.DEBUG&&a&&1<a.length){var b=goog.typeOf(a[0]);goog.array.forEach(a,function(a){goog.typeOf(a)!=b&&goog.asserts.fail("Inconsistent type in JSPB repeated field array. Got "+goog.typeOf(a)+" expected "+b)})}};jspb.Message.getFieldWithDefault=function(a,b,c){a=jspb.Message.getField(a,b);return null==a?c:a};jspb.Message.getBooleanFieldWithDefault=function(a,b,c){a=jspb.Message.getBooleanField(a,b);return null==a?c:a};
jspb.Message.getFloatingPointFieldWithDefault=function(a,b,c){a=jspb.Message.getOptionalFloatingPointField(a,b);return null==a?c:a};jspb.Message.getFieldProto3=jspb.Message.getFieldWithDefault;jspb.Message.getMapField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});if(b in a.wrappers_)return a.wrappers_[b];var e=jspb.Message.getField(a,b);if(!e){if(c)return;e=[];jspb.Message.setField(a,b,e)}return a.wrappers_[b]=new jspb.Map(e,d)};
jspb.Message.setField=function(a,b,c){goog.asserts.assertInstanceof(a,jspb.Message);b<a.pivot_?a.array[jspb.Message.getIndex_(a,b)]=c:(jspb.Message.maybeInitEmptyExtensionObject_(a),a.extensionObject_[b]=c);return a};jspb.Message.setProto3IntField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,0)};jspb.Message.setProto3FloatField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,0)};
jspb.Message.setProto3BooleanField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,!1)};jspb.Message.setProto3StringField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,"")};jspb.Message.setProto3BytesField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,"")};jspb.Message.setProto3EnumField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,0)};
jspb.Message.setProto3StringIntField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,"0")};jspb.Message.setFieldIgnoringDefault_=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);c!==d?jspb.Message.setField(a,b,c):b<a.pivot_?a.array[jspb.Message.getIndex_(a,b)]=null:(jspb.Message.maybeInitEmptyExtensionObject_(a),delete a.extensionObject_[b]);return a};
jspb.Message.addToRepeatedField=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);b=jspb.Message.getRepeatedField(a,b);void 0!=d?b.splice(d,0,c):b.push(c);return a};jspb.Message.setOneofField=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);(c=jspb.Message.computeOneofCase(a,c))&&c!==b&&void 0!==d&&(a.wrappers_&&c in a.wrappers_&&(a.wrappers_[c]=void 0),jspb.Message.setField(a,c,void 0));return jspb.Message.setField(a,b,d)};
jspb.Message.computeOneofCase=function(a,b){for(var c,d,e=0;e<b.length;e++){var f=b[e],g=jspb.Message.getField(a,f);null!=g&&(c=f,d=g,jspb.Message.setField(a,f,void 0))}return c?(jspb.Message.setField(a,c,d),c):0};jspb.Message.getWrapperField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});if(!a.wrappers_[c]){var e=jspb.Message.getField(a,c);if(d||e)a.wrappers_[c]=new b(e)}return a.wrappers_[c]};
jspb.Message.getRepeatedWrapperField=function(a,b,c){jspb.Message.wrapRepeatedField_(a,b,c);b=a.wrappers_[c];b==jspb.Message.EMPTY_LIST_SENTINEL_&&(b=a.wrappers_[c]=[]);return b};jspb.Message.wrapRepeatedField_=function(a,b,c){a.wrappers_||(a.wrappers_={});if(!a.wrappers_[c]){for(var d=jspb.Message.getRepeatedField(a,c),e=[],f=0;f<d.length;f++)e[f]=new b(d[f]);a.wrappers_[c]=e}};
jspb.Message.setWrapperField=function(a,b,c){goog.asserts.assertInstanceof(a,jspb.Message);a.wrappers_||(a.wrappers_={});var d=c?c.toArray():c;a.wrappers_[b]=c;return jspb.Message.setField(a,b,d)};jspb.Message.setOneofWrapperField=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);a.wrappers_||(a.wrappers_={});var e=d?d.toArray():d;a.wrappers_[b]=d;return jspb.Message.setOneofField(a,b,c,e)};
jspb.Message.setRepeatedWrapperField=function(a,b,c){goog.asserts.assertInstanceof(a,jspb.Message);a.wrappers_||(a.wrappers_={});c=c||[];for(var d=[],e=0;e<c.length;e++)d[e]=c[e].toArray();a.wrappers_[b]=c;return jspb.Message.setField(a,b,d)};
jspb.Message.addToRepeatedWrapperField=function(a,b,c,d,e){jspb.Message.wrapRepeatedField_(a,d,b);var f=a.wrappers_[b];f||(f=a.wrappers_[b]=[]);c=c?c:new d;a=jspb.Message.getRepeatedField(a,b);void 0!=e?(f.splice(e,0,c),a.splice(e,0,c.toArray())):(f.push(c),a.push(c.toArray()));return c};jspb.Message.toMap=function(a,b,c,d){for(var e={},f=0;f<a.length;f++)e[b.call(a[f])]=c?c.call(a[f],d,a[f]):a[f];return e};
jspb.Message.prototype.syncMapFields_=function(){if(this.wrappers_)for(var a in this.wrappers_){var b=this.wrappers_[a];if(Array.isArray(b))for(var c=0;c<b.length;c++)b[c]&&b[c].toArray();else b&&b.toArray()}};jspb.Message.prototype.toArray=function(){this.syncMapFields_();return this.array};jspb.Message.GENERATE_TO_STRING&&(jspb.Message.prototype.toString=function(){this.syncMapFields_();return this.array.toString()});
jspb.Message.prototype.getExtension=function(a){if(this.extensionObject_){this.wrappers_||(this.wrappers_={});var b=a.fieldIndex;if(a.isRepeated){if(a.isMessageType())return this.wrappers_[b]||(this.wrappers_[b]=goog.array.map(this.extensionObject_[b]||[],function(b){return new a.ctor(b)})),this.wrappers_[b]}else if(a.isMessageType())return!this.wrappers_[b]&&this.extensionObject_[b]&&(this.wrappers_[b]=new a.ctor(this.extensionObject_[b])),this.wrappers_[b];return this.extensionObject_[b]}};
jspb.Message.prototype.setExtension=function(a,b){this.wrappers_||(this.wrappers_={});jspb.Message.maybeInitEmptyExtensionObject_(this);var c=a.fieldIndex;a.isRepeated?(b=b||[],a.isMessageType()?(this.wrappers_[c]=b,this.extensionObject_[c]=goog.array.map(b,function(a){return a.toArray()})):this.extensionObject_[c]=b):a.isMessageType()?(this.wrappers_[c]=b,this.extensionObject_[c]=b?b.toArray():b):this.extensionObject_[c]=b;return this};
jspb.Message.difference=function(a,b){if(!(a instanceof b.constructor))throw Error("Messages have different types.");var c=a.toArray();b=b.toArray();var d=[],e=0,f=c.length>b.length?c.length:b.length;a.getJsPbMessageId()&&(d[0]=a.getJsPbMessageId(),e=1);for(;e<f;e++)jspb.Message.compareFields(c[e],b[e])||(d[e]=b[e]);return new a.constructor(d)};jspb.Message.equals=function(a,b){return a==b||!(!a||!b)&&a instanceof b.constructor&&jspb.Message.compareFields(a.toArray(),b.toArray())};
jspb.Message.compareExtensions=function(a,b){a=a||{};b=b||{};var c={},d;for(d in a)c[d]=0;for(d in b)c[d]=0;for(d in c)if(!jspb.Message.compareFields(a[d],b[d]))return!1;return!0};
jspb.Message.compareFields=function(a,b){if(a==b)return!0;if(!goog.isObject(a)||!goog.isObject(b))return"number"===typeof a&&isNaN(a)||"number"===typeof b&&isNaN(b)?String(a)==String(b):!1;if(a.constructor!=b.constructor)return!1;if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a.constructor===Uint8Array){if(a.length!=b.length)return!1;for(var c=0;c<a.length;c++)if(a[c]!=b[c])return!1;return!0}if(a.constructor===Array){var d=void 0,e=void 0,f=Math.max(a.length,b.length);for(c=0;c<f;c++){var g=a[c],h=b[c];g&&
g.constructor==Object&&(goog.asserts.assert(void 0===d),goog.asserts.assert(c===a.length-1),d=g,g=void 0);h&&h.constructor==Object&&(goog.asserts.assert(void 0===e),goog.asserts.assert(c===b.length-1),e=h,h=void 0);if(!jspb.Message.compareFields(g,h))return!1}return d||e?(d=d||{},e=e||{},jspb.Message.compareExtensions(d,e)):!0}if(a.constructor===Object)return jspb.Message.compareExtensions(a,b);throw Error("Invalid type in JSPB array");};jspb.Message.prototype.cloneMessage=function(){return jspb.Message.cloneMessage(this)};
jspb.Message.prototype.clone=function(){return jspb.Message.cloneMessage(this)};jspb.Message.clone=function(a){return jspb.Message.cloneMessage(a)};jspb.Message.cloneMessage=function(a){return new a.constructor(jspb.Message.clone_(a.toArray()))};
jspb.Message.copyInto=function(a,b){goog.asserts.assertInstanceof(a,jspb.Message);goog.asserts.assertInstanceof(b,jspb.Message);goog.asserts.assert(a.constructor==b.constructor,"Copy source and target message should have the same type.");a=jspb.Message.clone(a);for(var c=b.toArray(),d=a.toArray(),e=c.length=0;e<d.length;e++)c[e]=d[e];b.wrappers_=a.wrappers_;b.extensionObject_=a.extensionObject_};
jspb.Message.clone_=function(a){if(Array.isArray(a)){for(var b=Array(a.length),c=0;c<a.length;c++){var d=a[c];null!=d&&(b[c]="object"==typeof d?jspb.Message.clone_(goog.asserts.assert(d)):d)}return b}if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)return new Uint8Array(a);b={};for(c in a)d=a[c],null!=d&&(b[c]="object"==typeof d?jspb.Message.clone_(goog.asserts.assert(d)):d);return b};jspb.Message.registerMessageType=function(a,b){b.messageId=a};jspb.Message.messageSetExtensions={};
jspb.Message.messageSetExtensionsBinary={};jspb.Export={}; true&&(exports.Map=jspb.Map,exports.Message=jspb.Message,exports.BinaryReader=jspb.BinaryReader,exports.BinaryWriter=jspb.BinaryWriter,exports.ExtensionFieldInfo=jspb.ExtensionFieldInfo,exports.ExtensionFieldBinaryInfo=jspb.ExtensionFieldBinaryInfo,exports.exportSymbol=goog.exportSymbol,exports.inherits=goog.inherits,exports.object={extend:goog.object.extend},exports.typeOf=goog.typeOf);


/***/ }),

/***/ 134:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// source: google/protobuf/timestamp.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = __webpack_require__(19);
var goog = jspb;
var global = (function() {
  if (this) { return this; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  if (typeof self !== 'undefined') { return self; }
  return Function('return this')();
}.call(null));

goog.exportSymbol('proto.google.protobuf.Timestamp', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.google.protobuf.Timestamp = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.google.protobuf.Timestamp, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.google.protobuf.Timestamp.displayName = 'proto.google.protobuf.Timestamp';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.google.protobuf.Timestamp.prototype.toObject = function(opt_includeInstance) {
  return proto.google.protobuf.Timestamp.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.google.protobuf.Timestamp} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.Timestamp.toObject = function(includeInstance, msg) {
  var f, obj = {
    seconds: jspb.Message.getFieldWithDefault(msg, 1, 0),
    nanos: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.google.protobuf.Timestamp}
 */
proto.google.protobuf.Timestamp.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.google.protobuf.Timestamp;
  return proto.google.protobuf.Timestamp.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.google.protobuf.Timestamp} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.google.protobuf.Timestamp}
 */
proto.google.protobuf.Timestamp.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setSeconds(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setNanos(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.google.protobuf.Timestamp.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.google.protobuf.Timestamp.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.google.protobuf.Timestamp} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.Timestamp.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSeconds();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = message.getNanos();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * optional int64 seconds = 1;
 * @return {number}
 */
proto.google.protobuf.Timestamp.prototype.getSeconds = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.google.protobuf.Timestamp} returns this
 */
proto.google.protobuf.Timestamp.prototype.setSeconds = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional int32 nanos = 2;
 * @return {number}
 */
proto.google.protobuf.Timestamp.prototype.getNanos = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.google.protobuf.Timestamp} returns this
 */
proto.google.protobuf.Timestamp.prototype.setNanos = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


goog.object.extend(exports, proto.google.protobuf);
/* This code will be inserted into generated code for
 * google/protobuf/timestamp.proto. */

/**
 * Returns a JavaScript 'Date' object corresponding to this Timestamp.
 * @return {!Date}
 */
proto.google.protobuf.Timestamp.prototype.toDate = function() {
  var seconds = this.getSeconds();
  var nanos = this.getNanos();

  return new Date((seconds * 1000) + (nanos / 1000000));
};


/**
 * Sets the value of this Timestamp object to be the given Date.
 * @param {!Date} value The value to set.
 */
proto.google.protobuf.Timestamp.prototype.fromDate = function(value) {
  this.setSeconds(Math.floor(value.getTime() / 1000));
  this.setNanos(value.getMilliseconds() * 1000000);
};


/**
 * Factory method that returns a Timestamp object with value equal to
 * the given Date.
 * @param {!Date} value The value to set.
 * @return {!proto.google.protobuf.Timestamp}
 */
proto.google.protobuf.Timestamp.fromDate = function(value) {
  var timestamp = new proto.google.protobuf.Timestamp();
  timestamp.fromDate(value);
  return timestamp;
};


/***/ }),

/***/ 469:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// source: google/protobuf/wrappers.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = __webpack_require__(19);
var goog = jspb;
var global = (function() {
  if (this) { return this; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  if (typeof self !== 'undefined') { return self; }
  return Function('return this')();
}.call(null));

goog.exportSymbol('proto.google.protobuf.BoolValue', null, global);
goog.exportSymbol('proto.google.protobuf.BytesValue', null, global);
goog.exportSymbol('proto.google.protobuf.DoubleValue', null, global);
goog.exportSymbol('proto.google.protobuf.FloatValue', null, global);
goog.exportSymbol('proto.google.protobuf.Int32Value', null, global);
goog.exportSymbol('proto.google.protobuf.Int64Value', null, global);
goog.exportSymbol('proto.google.protobuf.StringValue', null, global);
goog.exportSymbol('proto.google.protobuf.UInt32Value', null, global);
goog.exportSymbol('proto.google.protobuf.UInt64Value', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.google.protobuf.DoubleValue = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.google.protobuf.DoubleValue, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.google.protobuf.DoubleValue.displayName = 'proto.google.protobuf.DoubleValue';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.google.protobuf.FloatValue = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.google.protobuf.FloatValue, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.google.protobuf.FloatValue.displayName = 'proto.google.protobuf.FloatValue';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.google.protobuf.Int64Value = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.google.protobuf.Int64Value, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.google.protobuf.Int64Value.displayName = 'proto.google.protobuf.Int64Value';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.google.protobuf.UInt64Value = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.google.protobuf.UInt64Value, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.google.protobuf.UInt64Value.displayName = 'proto.google.protobuf.UInt64Value';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.google.protobuf.Int32Value = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.google.protobuf.Int32Value, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.google.protobuf.Int32Value.displayName = 'proto.google.protobuf.Int32Value';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.google.protobuf.UInt32Value = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.google.protobuf.UInt32Value, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.google.protobuf.UInt32Value.displayName = 'proto.google.protobuf.UInt32Value';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.google.protobuf.BoolValue = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.google.protobuf.BoolValue, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.google.protobuf.BoolValue.displayName = 'proto.google.protobuf.BoolValue';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.google.protobuf.StringValue = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.google.protobuf.StringValue, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.google.protobuf.StringValue.displayName = 'proto.google.protobuf.StringValue';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.google.protobuf.BytesValue = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.google.protobuf.BytesValue, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.google.protobuf.BytesValue.displayName = 'proto.google.protobuf.BytesValue';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.google.protobuf.DoubleValue.prototype.toObject = function(opt_includeInstance) {
  return proto.google.protobuf.DoubleValue.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.google.protobuf.DoubleValue} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.DoubleValue.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFloatingPointFieldWithDefault(msg, 1, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.google.protobuf.DoubleValue}
 */
proto.google.protobuf.DoubleValue.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.google.protobuf.DoubleValue;
  return proto.google.protobuf.DoubleValue.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.google.protobuf.DoubleValue} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.google.protobuf.DoubleValue}
 */
proto.google.protobuf.DoubleValue.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.google.protobuf.DoubleValue.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.google.protobuf.DoubleValue.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.google.protobuf.DoubleValue} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.DoubleValue.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f !== 0.0) {
    writer.writeDouble(
      1,
      f
    );
  }
};


/**
 * optional double value = 1;
 * @return {number}
 */
proto.google.protobuf.DoubleValue.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 1, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.google.protobuf.DoubleValue} returns this
 */
proto.google.protobuf.DoubleValue.prototype.setValue = function(value) {
  return jspb.Message.setProto3FloatField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.google.protobuf.FloatValue.prototype.toObject = function(opt_includeInstance) {
  return proto.google.protobuf.FloatValue.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.google.protobuf.FloatValue} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.FloatValue.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFloatingPointFieldWithDefault(msg, 1, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.google.protobuf.FloatValue}
 */
proto.google.protobuf.FloatValue.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.google.protobuf.FloatValue;
  return proto.google.protobuf.FloatValue.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.google.protobuf.FloatValue} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.google.protobuf.FloatValue}
 */
proto.google.protobuf.FloatValue.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.google.protobuf.FloatValue.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.google.protobuf.FloatValue.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.google.protobuf.FloatValue} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.FloatValue.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f !== 0.0) {
    writer.writeFloat(
      1,
      f
    );
  }
};


/**
 * optional float value = 1;
 * @return {number}
 */
proto.google.protobuf.FloatValue.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 1, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.google.protobuf.FloatValue} returns this
 */
proto.google.protobuf.FloatValue.prototype.setValue = function(value) {
  return jspb.Message.setProto3FloatField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.google.protobuf.Int64Value.prototype.toObject = function(opt_includeInstance) {
  return proto.google.protobuf.Int64Value.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.google.protobuf.Int64Value} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.Int64Value.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.google.protobuf.Int64Value}
 */
proto.google.protobuf.Int64Value.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.google.protobuf.Int64Value;
  return proto.google.protobuf.Int64Value.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.google.protobuf.Int64Value} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.google.protobuf.Int64Value}
 */
proto.google.protobuf.Int64Value.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.google.protobuf.Int64Value.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.google.protobuf.Int64Value.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.google.protobuf.Int64Value} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.Int64Value.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
};


/**
 * optional int64 value = 1;
 * @return {number}
 */
proto.google.protobuf.Int64Value.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.google.protobuf.Int64Value} returns this
 */
proto.google.protobuf.Int64Value.prototype.setValue = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.google.protobuf.UInt64Value.prototype.toObject = function(opt_includeInstance) {
  return proto.google.protobuf.UInt64Value.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.google.protobuf.UInt64Value} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.UInt64Value.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.google.protobuf.UInt64Value}
 */
proto.google.protobuf.UInt64Value.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.google.protobuf.UInt64Value;
  return proto.google.protobuf.UInt64Value.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.google.protobuf.UInt64Value} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.google.protobuf.UInt64Value}
 */
proto.google.protobuf.UInt64Value.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.google.protobuf.UInt64Value.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.google.protobuf.UInt64Value.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.google.protobuf.UInt64Value} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.UInt64Value.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
};


/**
 * optional uint64 value = 1;
 * @return {number}
 */
proto.google.protobuf.UInt64Value.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.google.protobuf.UInt64Value} returns this
 */
proto.google.protobuf.UInt64Value.prototype.setValue = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.google.protobuf.Int32Value.prototype.toObject = function(opt_includeInstance) {
  return proto.google.protobuf.Int32Value.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.google.protobuf.Int32Value} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.Int32Value.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.google.protobuf.Int32Value}
 */
proto.google.protobuf.Int32Value.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.google.protobuf.Int32Value;
  return proto.google.protobuf.Int32Value.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.google.protobuf.Int32Value} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.google.protobuf.Int32Value}
 */
proto.google.protobuf.Int32Value.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.google.protobuf.Int32Value.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.google.protobuf.Int32Value.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.google.protobuf.Int32Value} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.Int32Value.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
};


/**
 * optional int32 value = 1;
 * @return {number}
 */
proto.google.protobuf.Int32Value.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.google.protobuf.Int32Value} returns this
 */
proto.google.protobuf.Int32Value.prototype.setValue = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.google.protobuf.UInt32Value.prototype.toObject = function(opt_includeInstance) {
  return proto.google.protobuf.UInt32Value.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.google.protobuf.UInt32Value} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.UInt32Value.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.google.protobuf.UInt32Value}
 */
proto.google.protobuf.UInt32Value.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.google.protobuf.UInt32Value;
  return proto.google.protobuf.UInt32Value.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.google.protobuf.UInt32Value} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.google.protobuf.UInt32Value}
 */
proto.google.protobuf.UInt32Value.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.google.protobuf.UInt32Value.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.google.protobuf.UInt32Value.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.google.protobuf.UInt32Value} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.UInt32Value.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 value = 1;
 * @return {number}
 */
proto.google.protobuf.UInt32Value.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.google.protobuf.UInt32Value} returns this
 */
proto.google.protobuf.UInt32Value.prototype.setValue = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.google.protobuf.BoolValue.prototype.toObject = function(opt_includeInstance) {
  return proto.google.protobuf.BoolValue.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.google.protobuf.BoolValue} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.BoolValue.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getBooleanFieldWithDefault(msg, 1, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.google.protobuf.BoolValue}
 */
proto.google.protobuf.BoolValue.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.google.protobuf.BoolValue;
  return proto.google.protobuf.BoolValue.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.google.protobuf.BoolValue} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.google.protobuf.BoolValue}
 */
proto.google.protobuf.BoolValue.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.google.protobuf.BoolValue.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.google.protobuf.BoolValue.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.google.protobuf.BoolValue} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.BoolValue.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
};


/**
 * optional bool value = 1;
 * @return {boolean}
 */
proto.google.protobuf.BoolValue.prototype.getValue = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 1, false));
};


/**
 * @param {boolean} value
 * @return {!proto.google.protobuf.BoolValue} returns this
 */
proto.google.protobuf.BoolValue.prototype.setValue = function(value) {
  return jspb.Message.setProto3BooleanField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.google.protobuf.StringValue.prototype.toObject = function(opt_includeInstance) {
  return proto.google.protobuf.StringValue.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.google.protobuf.StringValue} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.StringValue.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.google.protobuf.StringValue}
 */
proto.google.protobuf.StringValue.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.google.protobuf.StringValue;
  return proto.google.protobuf.StringValue.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.google.protobuf.StringValue} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.google.protobuf.StringValue}
 */
proto.google.protobuf.StringValue.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.google.protobuf.StringValue.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.google.protobuf.StringValue.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.google.protobuf.StringValue} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.StringValue.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string value = 1;
 * @return {string}
 */
proto.google.protobuf.StringValue.prototype.getValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.google.protobuf.StringValue} returns this
 */
proto.google.protobuf.StringValue.prototype.setValue = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.google.protobuf.BytesValue.prototype.toObject = function(opt_includeInstance) {
  return proto.google.protobuf.BytesValue.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.google.protobuf.BytesValue} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.BytesValue.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: msg.getValue_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.google.protobuf.BytesValue}
 */
proto.google.protobuf.BytesValue.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.google.protobuf.BytesValue;
  return proto.google.protobuf.BytesValue.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.google.protobuf.BytesValue} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.google.protobuf.BytesValue}
 */
proto.google.protobuf.BytesValue.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.google.protobuf.BytesValue.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.google.protobuf.BytesValue.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.google.protobuf.BytesValue} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.google.protobuf.BytesValue.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes value = 1;
 * @return {!(string|Uint8Array)}
 */
proto.google.protobuf.BytesValue.prototype.getValue = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes value = 1;
 * This is a type-conversion wrapper around `getValue()`
 * @return {string}
 */
proto.google.protobuf.BytesValue.prototype.getValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getValue()));
};


/**
 * optional bytes value = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValue()`
 * @return {!Uint8Array}
 */
proto.google.protobuf.BytesValue.prototype.getValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getValue()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.google.protobuf.BytesValue} returns this
 */
proto.google.protobuf.BytesValue.prototype.setValue = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


goog.object.extend(exports, proto.google.protobuf);


/***/ }),

/***/ 40:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*

 Copyright The Closure Library Authors.
 SPDX-License-Identifier: Apache-2.0
*/
var n;function aa(a){var b=0;return function(){return b<a.length?{done:!1,value:a[b++]}:{done:!0}}}var ba="function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value)};function ca(a){a=["object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof __webpack_require__.g&&__webpack_require__.g,a];for(var b=0;b<a.length;++b){var c=a[b];if(c&&c.Math==Math)return c}throw Error("Cannot find global object");}var r=ca(this);
function t(){t=function(){};r.Symbol||(r.Symbol=da)}function ea(a,b){this.a=a;ba(this,"description",{configurable:!0,writable:!0,value:b})}ea.prototype.toString=function(){return this.a};var da=function(){function a(c){if(this instanceof a)throw new TypeError("Symbol is not a constructor");return new ea("jscomp_symbol_"+(c||"")+"_"+b++,c)}var b=0;return a}();
function u(){t();var a=r.Symbol.iterator;a||(a=r.Symbol.iterator=r.Symbol("Symbol.iterator"));"function"!=typeof Array.prototype[a]&&ba(Array.prototype,a,{configurable:!0,writable:!0,value:function(){return fa(aa(this))}});u=function(){}}function fa(a){u();a={next:a};a[r.Symbol.iterator]=function(){return this};return a}function ha(a){var b="undefined"!=typeof Symbol&&Symbol.iterator&&a[Symbol.iterator];return b?b.call(a):{next:aa(a)}}
var ia="function"==typeof Object.create?Object.create:function(a){function b(){}b.prototype=a;return new b},ja;if("function"==typeof Object.setPrototypeOf)ja=Object.setPrototypeOf;else{var ka;a:{var la={V:!0},ma={};try{ma.__proto__=la;ka=ma.V;break a}catch(a){}ka=!1}ja=ka?function(a,b){a.__proto__=b;if(a.__proto__!==b)throw new TypeError(a+" is not extensible");return a}:null}var na=ja;
function oa(a,b){a.prototype=ia(b.prototype);a.prototype.constructor=a;if(na)na(a,b);else for(var c in b)if("prototype"!=c)if(Object.defineProperties){var d=Object.getOwnPropertyDescriptor(b,c);d&&Object.defineProperty(a,c,d)}else a[c]=b[c];a.O=b.prototype}
function pa(a,b){u();a instanceof String&&(a+="");var c=0,d={next:function(){if(c<a.length){var f=c++;return{value:b(f,a[f]),done:!1}}d.next=function(){return{done:!0,value:void 0}};return d.next()}};d[Symbol.iterator]=function(){return d};return d}function v(a,b){if(b){var c=r;a=a.split(".");for(var d=0;d<a.length-1;d++){var f=a[d];f in c||(c[f]={});c=c[f]}a=a[a.length-1];d=c[a];b=b(d);b!=d&&null!=b&&ba(c,a,{configurable:!0,writable:!0,value:b})}}
v("Array.prototype.keys",function(a){return a?a:function(){return pa(this,function(b){return b})}});v("Array.prototype.find",function(a){return a?a:function(b,c){a:{var d=this;d instanceof String&&(d=String(d));for(var f=d.length,g=0;g<f;g++){var e=d[g];if(b.call(c,e,g,d)){b=e;break a}}b=void 0}return b}});v("Object.is",function(a){return a?a:function(b,c){return b===c?0!==b||1/b===1/c:b!==b&&c!==c}});
v("Array.prototype.includes",function(a){return a?a:function(b,c){var d=this;d instanceof String&&(d=String(d));var f=d.length;c=c||0;for(0>c&&(c=Math.max(c+f,0));c<f;c++){var g=d[c];if(g===b||Object.is(g,b))return!0}return!1}});
v("Promise",function(a){function b(e){this.b=0;this.c=void 0;this.a=[];var h=this.f();try{e(h.resolve,h.reject)}catch(k){h.reject(k)}}function c(){this.a=null}function d(e){return e instanceof b?e:new b(function(h){h(e)})}if(a)return a;c.prototype.b=function(e){if(null==this.a){this.a=[];var h=this;this.c(function(){h.g()})}this.a.push(e)};var f=r.setTimeout;c.prototype.c=function(e){f(e,0)};c.prototype.g=function(){for(;this.a&&this.a.length;){var e=this.a;this.a=[];for(var h=0;h<e.length;++h){var k=
e[h];e[h]=null;try{k()}catch(l){this.f(l)}}}this.a=null};c.prototype.f=function(e){this.c(function(){throw e;})};b.prototype.f=function(){function e(l){return function(m){k||(k=!0,l.call(h,m))}}var h=this,k=!1;return{resolve:e(this.s),reject:e(this.g)}};b.prototype.s=function(e){if(e===this)this.g(new TypeError("A Promise cannot resolve to itself"));else if(e instanceof b)this.v(e);else{a:switch(typeof e){case "object":var h=null!=e;break a;case "function":h=!0;break a;default:h=!1}h?this.m(e):this.h(e)}};
b.prototype.m=function(e){var h=void 0;try{h=e.then}catch(k){this.g(k);return}"function"==typeof h?this.w(h,e):this.h(e)};b.prototype.g=function(e){this.i(2,e)};b.prototype.h=function(e){this.i(1,e)};b.prototype.i=function(e,h){if(0!=this.b)throw Error("Cannot settle("+e+", "+h+"): Promise already settled in state"+this.b);this.b=e;this.c=h;this.l()};b.prototype.l=function(){if(null!=this.a){for(var e=0;e<this.a.length;++e)g.b(this.a[e]);this.a=null}};var g=new c;b.prototype.v=function(e){var h=this.f();
e.F(h.resolve,h.reject)};b.prototype.w=function(e,h){var k=this.f();try{e.call(h,k.resolve,k.reject)}catch(l){k.reject(l)}};b.prototype.then=function(e,h){function k(q,x){return"function"==typeof q?function(z){try{l(q(z))}catch(N){m(N)}}:x}var l,m,p=new b(function(q,x){l=q;m=x});this.F(k(e,l),k(h,m));return p};b.prototype.catch=function(e){return this.then(void 0,e)};b.prototype.F=function(e,h){function k(){switch(l.b){case 1:e(l.c);break;case 2:h(l.c);break;default:throw Error("Unexpected state: "+
l.b);}}var l=this;null==this.a?g.b(k):this.a.push(k)};b.resolve=d;b.reject=function(e){return new b(function(h,k){k(e)})};b.race=function(e){return new b(function(h,k){for(var l=ha(e),m=l.next();!m.done;m=l.next())d(m.value).F(h,k)})};b.all=function(e){var h=ha(e),k=h.next();return k.done?d([]):new b(function(l,m){function p(z){return function(N){q[z]=N;x--;0==x&&l(q)}}var q=[],x=0;do q.push(void 0),x++,d(k.value).F(p(q.length-1),m),k=h.next();while(!k.done)})};return b});var qa=qa||{},w=this||self;
function y(a,b){a=a.split(".");b=b||w;for(var c=0;c<a.length;c++)if(b=b[a[c]],null==b)return null;return b}function ra(){}function sa(a){var b=typeof a;return"object"==b&&null!=a||"function"==b}var ta="closure_uid_"+(1E9*Math.random()>>>0),ua=0;function va(a,b,c){return a.call.apply(a.bind,arguments)}
function wa(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var f=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(f,d);return a.apply(b,f)}}return function(){return a.apply(b,arguments)}}function A(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?A=va:A=wa;return A.apply(null,arguments)}
function B(a,b){function c(){}c.prototype=b.prototype;a.O=b.prototype;a.prototype=new c;a.prototype.constructor=a};function xa(a){this.a=a||{}}xa.prototype.get=function(a){return this.a[a]};xa.prototype.G=function(){return Object.keys(this.a)};function C(a,b,c,d){this.f=a;this.c=b;this.b=c;this.a=d}C.prototype.getRequestMessage=function(){return this.f};C.prototype.getMethodDescriptor=function(){return this.c};C.prototype.getMetadata=function(){return this.b};C.prototype.getCallOptions=function(){return this.a};function D(a,b,c,d){c=void 0===c?{}:c;this.c=a;this.a=c;this.b=b;this.f=void 0===d?null:d}D.prototype.getResponseMessage=function(){return this.c};D.prototype.getMetadata=function(){return this.a};D.prototype.getMethodDescriptor=function(){return this.b};D.prototype.getStatus=function(){return this.f};function E(a,b,c,d,f,g){this.name=a;this.a=b;this.f=c;this.b=d;this.c=f;this.g=g}function ya(a,b,c){c=void 0===c?{}:c;var d=void 0===d?new xa:d;return new C(b,a,c,d)}n=E.prototype;n.getName=function(){return this.name};n.getMethodType=function(){return this.a};n.getResponseMessageCtor=function(){return this.b};n.getRequestMessageCtor=function(){return this.f};n.getResponseDeserializeFn=function(){return this.g};n.getRequestSerializeFn=function(){return this.c};E.prototype.getRequestSerializeFn=E.prototype.getRequestSerializeFn;
E.prototype.getResponseDeserializeFn=E.prototype.getResponseDeserializeFn;E.prototype.getRequestMessageCtor=E.prototype.getRequestMessageCtor;E.prototype.getResponseMessageCtor=E.prototype.getResponseMessageCtor;E.prototype.getMethodType=E.prototype.getMethodType;E.prototype.getName=E.prototype.getName;function za(a){switch(a){case 200:return 0;case 400:return 3;case 401:return 16;case 403:return 7;case 404:return 5;case 409:return 10;case 412:return 9;case 429:return 8;case 499:return 1;case 500:return 2;case 501:return 12;case 503:return 14;case 504:return 4;default:return 2}};function F(a,b,c){c=void 0===c?{}:c;b=Error.call(this,b);this.message=b.message;"stack"in b&&(this.stack=b.stack);this.code=a;this.metadata=c}oa(F,Error);F.prototype.name="RpcError";function Aa(a){this.a=a}Aa.prototype.on=function(a,b){return"data"==a||"error"==a?this:this.a.on(a,b)};Aa.prototype.removeListener=function(a,b){return this.a.removeListener(a,b)};Aa.prototype.cancel=function(){this.a.cancel()};function Ba(a){switch(a){case 0:return"No Error";case 1:return"Access denied to content document";case 2:return"File not found";case 3:return"Firefox silently errored";case 4:return"Application custom error";case 5:return"An exception occurred";case 6:return"Http response at 400 or 500 level";case 7:return"Request was aborted";case 8:return"Request timed out";case 9:return"The resource is not available offline";default:return"Unrecognized error code"}};function G(a){if(Error.captureStackTrace)Error.captureStackTrace(this,G);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a))}B(G,Error);G.prototype.name="CustomError";function Ca(a,b){a=a.split("%s");for(var c="",d=a.length-1,f=0;f<d;f++)c+=a[f]+(f<b.length?b[f]:"%s");G.call(this,c+a[d])}B(Ca,G);Ca.prototype.name="AssertionError";function Da(a,b){throw new Ca("Failure"+(a?": "+a:""),Array.prototype.slice.call(arguments,1));};function Ea(){this.l=null;this.i=[];this.m=0;this.b=Fa;this.f=this.a=this.h=0;this.c=null;this.g=0}
function Ga(a,b){function c(l){l==Ha?e.h=l:l==H?e.h=l:Ia(e,h,k,"invalid frame byte");e.b=Ja;e.a=0;e.f=0}function d(l){e.f++;e.a=(e.a<<8)+l;4==e.f&&(e.b=Ka,e.g=0,"undefined"!==typeof Uint8Array?e.c=new Uint8Array(e.a):e.c=Array(e.a),0==e.a&&g())}function f(l){e.c[e.g++]=l;e.g==e.a&&g()}function g(){var l={};l[e.h]=e.c;e.i.push(l);e.b=Fa}var e=a,h,k=0;for(b instanceof Uint8Array||b instanceof Array?h=b:h=new Uint8Array(b);k<h.length;){switch(e.b){case La:Ia(e,h,k,"stream already broken");break;case Fa:c(h[k]);
break;case Ja:d(h[k]);break;case Ka:f(h[k]);break;default:throw Error("unexpected parser state: "+e.b);}e.m++;k++}a=e.i;e.i=[];return 0<a.length?a:null}var Fa=0,Ja=1,Ka=2,La=3,Ha=0,H=128;function Ia(a,b,c,d){a.b=La;a.l="The stream is broken @"+a.m+"/"+c+". Error: "+d+". With input:\n"+b;throw Error(a.l);};var Ma=Array.prototype.indexOf?function(a,b){return Array.prototype.indexOf.call(a,b,void 0)}:function(a,b){if("string"===typeof a)return"string"!==typeof b||1!=b.length?-1:a.indexOf(b,0);for(var c=0;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1};var Na=String.prototype.trim?function(a){return a.trim()}:function(a){return/^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1]};function I(a,b){return-1!=a.indexOf(b)}function Oa(a,b){return a<b?-1:a>b?1:0};var J;a:{var Pa=w.navigator;if(Pa){var Qa=Pa.userAgent;if(Qa){J=Qa;break a}}J=""};function Ra(a,b){for(var c in a)b.call(void 0,a[c],c,a)}function Sa(a,b){var c={},d;for(d in a)c[d]=b.call(void 0,a[d],d,a);return c}var Ta="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");function Ua(a,b){for(var c,d,f=1;f<arguments.length;f++){d=arguments[f];for(c in d)a[c]=d[c];for(var g=0;g<Ta.length;g++)c=Ta[g],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};function Va(a){var b=1;a=a.split(":");for(var c=[];0<b&&a.length;)c.push(a.shift()),b--;a.length&&c.push(a.join(":"));return c};function Wa(a){Wa[" "](a);return a}Wa[" "]=ra;function Xa(a){var b=Ya;return Object.prototype.hasOwnProperty.call(b,9)?b[9]:b[9]=a(9)};var Za=I(J,"Opera"),$a=I(J,"Trident")||I(J,"MSIE"),ab=I(J,"Edge"),bb=I(J,"Gecko")&&!(I(J.toLowerCase(),"webkit")&&!I(J,"Edge"))&&!(I(J,"Trident")||I(J,"MSIE"))&&!I(J,"Edge"),cb=I(J.toLowerCase(),"webkit")&&!I(J,"Edge"),db;
a:{var eb="",fb=function(){var a=J;if(bb)return/rv:([^\);]+)(\)|;)/.exec(a);if(ab)return/Edge\/([\d\.]+)/.exec(a);if($a)return/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(cb)return/WebKit\/(\S+)/.exec(a);if(Za)return/(?:Version)[ \/]?(\S+)/.exec(a)}();fb&&(eb=fb?fb[1]:"");if($a){var gb,hb=w.document;gb=hb?hb.documentMode:void 0;if(null!=gb&&gb>parseFloat(eb)){db=String(gb);break a}}db=eb}var Ya={};
function ib(){return Xa(function(){for(var a=0,b=Na(String(db)).split("."),c=Na("9").split("."),d=Math.max(b.length,c.length),f=0;0==a&&f<d;f++){var g=b[f]||"",e=c[f]||"";do{g=/(\d*)(\D*)(.*)/.exec(g)||["","","",""];e=/(\d*)(\D*)(.*)/.exec(e)||["","","",""];if(0==g[0].length&&0==e[0].length)break;a=Oa(0==g[1].length?0:parseInt(g[1],10),0==e[1].length?0:parseInt(e[1],10))||Oa(0==g[2].length,0==e[2].length)||Oa(g[2],e[2]);g=g[3];e=e[3]}while(0==a)}return 0<=a})};function jb(){0!=kb&&(Object.prototype.hasOwnProperty.call(this,ta)&&this[ta]||(this[ta]=++ua));this.K=this.K}var kb=0;jb.prototype.K=!1;var lb=Object.freeze||function(a){return a};function K(a,b){this.type=a;this.a=this.target=b;this.defaultPrevented=!1}K.prototype.b=function(){this.defaultPrevented=!0};var mb=function(){if(!w.addEventListener||!Object.defineProperty)return!1;var a=!1,b=Object.defineProperty({},"passive",{get:function(){a=!0}});try{w.addEventListener("test",ra,b),w.removeEventListener("test",ra,b)}catch(c){}return a}();function L(a,b){K.call(this,a?a.type:"");this.relatedTarget=this.a=this.target=null;this.button=this.screenY=this.screenX=this.clientY=this.clientX=0;this.key="";this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1;this.pointerId=0;this.pointerType="";this.c=null;if(a){var c=this.type=a.type,d=a.changedTouches&&a.changedTouches.length?a.changedTouches[0]:null;this.target=a.target||a.srcElement;this.a=b;if(b=a.relatedTarget){if(bb){a:{try{Wa(b.nodeName);var f=!0;break a}catch(g){}f=!1}f||(b=null)}}else"mouseover"==
c?b=a.fromElement:"mouseout"==c&&(b=a.toElement);this.relatedTarget=b;d?(this.clientX=void 0!==d.clientX?d.clientX:d.pageX,this.clientY=void 0!==d.clientY?d.clientY:d.pageY,this.screenX=d.screenX||0,this.screenY=d.screenY||0):(this.clientX=void 0!==a.clientX?a.clientX:a.pageX,this.clientY=void 0!==a.clientY?a.clientY:a.pageY,this.screenX=a.screenX||0,this.screenY=a.screenY||0);this.button=a.button;this.key=a.key||"";this.ctrlKey=a.ctrlKey;this.altKey=a.altKey;this.shiftKey=a.shiftKey;this.metaKey=
a.metaKey;this.pointerId=a.pointerId||0;this.pointerType="string"===typeof a.pointerType?a.pointerType:nb[a.pointerType]||"";this.c=a;a.defaultPrevented&&L.O.b.call(this)}}B(L,K);var nb=lb({2:"touch",3:"pen",4:"mouse"});L.prototype.b=function(){L.O.b.call(this);var a=this.c;a.preventDefault?a.preventDefault():a.returnValue=!1};var ob="closure_listenable_"+(1E6*Math.random()|0);var pb=0;function qb(a,b,c,d,f){this.listener=a;this.proxy=null;this.src=b;this.type=c;this.capture=!!d;this.H=f;this.key=++pb;this.A=this.D=!1}function rb(a){a.A=!0;a.listener=null;a.proxy=null;a.src=null;a.H=null};function sb(a){this.src=a;this.a={};this.b=0}sb.prototype.add=function(a,b,c,d,f){var g=a.toString();a=this.a[g];a||(a=this.a[g]=[],this.b++);var e=tb(a,b,d,f);-1<e?(b=a[e],c||(b.D=!1)):(b=new qb(b,this.src,g,!!d,f),b.D=c,a.push(b));return b};sb.prototype.remove=function(a,b,c,d){a=a.toString();if(!(a in this.a))return!1;var f=this.a[a];b=tb(f,b,c,d);return-1<b?(rb(f[b]),Array.prototype.splice.call(f,b,1),0==f.length&&(delete this.a[a],this.b--),!0):!1};
function ub(a,b){var c=b.type;if(c in a.a){var d=a.a[c],f=Ma(d,b),g;(g=0<=f)&&Array.prototype.splice.call(d,f,1);g&&(rb(b),0==a.a[c].length&&(delete a.a[c],a.b--))}}function tb(a,b,c,d){for(var f=0;f<a.length;++f){var g=a[f];if(!g.A&&g.listener==b&&g.capture==!!c&&g.H==d)return f}return-1};var vb="closure_lm_"+(1E6*Math.random()|0),wb={},xb=0;function yb(a,b,c,d,f){if(d&&d.once)zb(a,b,c,d,f);else if(Array.isArray(b))for(var g=0;g<b.length;g++)yb(a,b[g],c,d,f);else c=Ab(c),a&&a[ob]?a.f.add(String(b),c,!1,sa(d)?!!d.capture:!!d,f):Bb(a,b,c,!1,d,f)}
function Bb(a,b,c,d,f,g){if(!b)throw Error("Invalid event type");var e=sa(f)?!!f.capture:!!f,h=Cb(a);h||(a[vb]=h=new sb(a));c=h.add(b,c,d,e,g);if(!c.proxy){d=Db();c.proxy=d;d.src=a;d.listener=c;if(a.addEventListener)mb||(f=e),void 0===f&&(f=!1),a.addEventListener(b.toString(),d,f);else if(a.attachEvent)a.attachEvent(Eb(b.toString()),d);else if(a.addListener&&a.removeListener)a.addListener(d);else throw Error("addEventListener and attachEvent are unavailable.");xb++}}
function Db(){function a(c){return b.call(a.src,a.listener,c)}var b=Fb;return a}function zb(a,b,c,d,f){if(Array.isArray(b))for(var g=0;g<b.length;g++)zb(a,b[g],c,d,f);else c=Ab(c),a&&a[ob]?a.f.add(String(b),c,!0,sa(d)?!!d.capture:!!d,f):Bb(a,b,c,!0,d,f)}
function Gb(a,b,c,d,f){if(Array.isArray(b))for(var g=0;g<b.length;g++)Gb(a,b[g],c,d,f);else(d=sa(d)?!!d.capture:!!d,c=Ab(c),a&&a[ob])?a.f.remove(String(b),c,d,f):a&&(a=Cb(a))&&(b=a.a[b.toString()],a=-1,b&&(a=tb(b,c,d,f)),(c=-1<a?b[a]:null)&&Hb(c))}
function Hb(a){if("number"!==typeof a&&a&&!a.A){var b=a.src;if(b&&b[ob])ub(b.f,a);else{var c=a.type,d=a.proxy;b.removeEventListener?b.removeEventListener(c,d,a.capture):b.detachEvent?b.detachEvent(Eb(c),d):b.addListener&&b.removeListener&&b.removeListener(d);xb--;(c=Cb(b))?(ub(c,a),0==c.b&&(c.src=null,b[vb]=null)):rb(a)}}}function Eb(a){return a in wb?wb[a]:wb[a]="on"+a}function Fb(a,b){if(a.A)a=!0;else{b=new L(b,this);var c=a.listener,d=a.H||a.src;a.D&&Hb(a);a=c.call(d,b)}return a}
function Cb(a){a=a[vb];return a instanceof sb?a:null}var Ib="__closure_events_fn_"+(1E9*Math.random()>>>0);function Ab(a){if("function"===typeof a)return a;a[Ib]||(a[Ib]=function(b){return a.handleEvent(b)});return a[Ib]};function M(){jb.call(this);this.f=new sb(this);this.U=this}B(M,jb);M.prototype[ob]=!0;M.prototype.addEventListener=function(a,b,c,d){yb(this,a,b,c,d)};M.prototype.removeEventListener=function(a,b,c,d){Gb(this,a,b,c,d)};function O(a,b){a=a.U;var c=b.type||b;if("string"===typeof b)b=new K(b,a);else if(b instanceof K)b.target=b.target||a;else{var d=b;b=new K(c,a);Ua(b,d)}a=b.a=a;Jb(a,c,!0,b);Jb(a,c,!1,b)}
function Jb(a,b,c,d){if(b=a.f.a[String(b)]){b=b.concat();for(var f=!0,g=0;g<b.length;++g){var e=b[g];if(e&&!e.A&&e.capture==c){var h=e.listener,k=e.H||e.src;e.D&&ub(a.f,e);f=!1!==h.call(k,d)&&f}}}};var Kb=w;function Lb(a,b,c){if("function"===typeof a)c&&(a=A(a,c));else if(a&&"function"==typeof a.handleEvent)a=A(a.handleEvent,a);else throw Error("Invalid listener argument");return 2147483647<Number(b)?-1:Kb.setTimeout(a,b||0)};function Mb(a,b){this.name=a;this.value=b}Mb.prototype.toString=function(){return this.name};var Nb=new Mb("OFF",Infinity),Ob=new Mb("SEVERE",1E3),Pb=new Mb("CONFIG",700),Qb=new Mb("FINE",500);function Rb(){this.clear()}var Sb;Rb.prototype.clear=function(){};function Ub(a,b,c){this.reset(a||Nb,b,c,void 0,void 0)}Ub.prototype.reset=function(){};function Vb(a,b){this.a=null;this.f=[];this.b=(void 0===b?null:b)||null;this.c=[];this.g={getName:function(){return a}}}
function Wb(a){if(a.a)return a.a;if(a.b)return Wb(a.b);Da("Root logger has no level set.");return Nb}function Xb(a,b){for(;a;)a.f.forEach(function(c){c(b)}),a=a.b}function Yb(){this.entries={};var a=new Vb("");a.a=Pb;this.entries[""]=a}var Zb;function $b(a,b,c){var d=a.entries[b];if(d)return void 0!==c&&(d.a=c),d;d=$b(a,b.substr(0,b.lastIndexOf(".")));var f=new Vb(b,d);a.entries[b]=f;d.c.push(f);void 0!==c&&(f.a=c);return f}function ac(){Zb||(Zb=new Yb);return Zb}
function bc(a,b,c){var d;if(d=a)if(d=a&&b){d=b.value;var f=a?Wb($b(ac(),a.getName())):Nb;d=d>=f.value}d&&(b=b||Nb,d=$b(ac(),a.getName()),"function"===typeof c&&(c=c()),Sb||(Sb=new Rb),a=a.getName(),a=new Ub(b,c,a),Xb(d,a))}function P(a,b){a&&bc(a,Qb,b)};function cc(){}cc.prototype.a=null;function dc(a){var b;(b=a.a)||(b={},ec(a)&&(b[0]=!0,b[1]=!0),b=a.a=b);return b};var fc;function gc(){}B(gc,cc);function hc(a){return(a=ec(a))?new ActiveXObject(a):new XMLHttpRequest}function ec(a){if(!a.b&&"undefined"==typeof XMLHttpRequest&&"undefined"!=typeof ActiveXObject){for(var b=["MSXML2.XMLHTTP.6.0","MSXML2.XMLHTTP.3.0","MSXML2.XMLHTTP","Microsoft.XMLHTTP"],c=0;c<b.length;c++){var d=b[c];try{return new ActiveXObject(d),a.b=d}catch(f){}}throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");}return a.b}fc=new gc;t();u();function ic(a,b){this.b=a[w.Symbol.iterator]();this.c=b;this.f=0}ic.prototype[Symbol.iterator]=function(){return this};ic.prototype.next=function(){var a=this.b.next();return{value:a.done?void 0:this.c.call(void 0,a.value,this.f++),done:a.done}};function jc(a,b){return new ic(a,b)}t();u();t();u();var kc="StopIteration"in w?w.StopIteration:{message:"StopIteration",stack:""};function Q(){}Q.prototype.next=function(){return Q.prototype.a.call(this)};Q.prototype.a=function(){throw kc;};Q.prototype.u=function(){return this};function lc(a){if(a instanceof R||a instanceof S||a instanceof T)return a;if("function"==typeof a.next)return new R(function(){return mc(a)});t();u();if("function"==typeof a[Symbol.iterator])return t(),u(),new R(function(){return a[Symbol.iterator]()});if("function"==typeof a.u)return new R(function(){return mc(a.u())});throw Error("Not an iterator or iterable.");}
function mc(a){if(!(a instanceof Q))return a;var b=!1;return{next:function(){for(var c;!b;)try{c=a.a();break}catch(d){if(d!==kc)throw d;b=!0}return{value:c,done:b}}}}t();u();function R(a){this.b=a}R.prototype.u=function(){return new S(this.b())};R.prototype[Symbol.iterator]=function(){return new T(this.b())};R.prototype.c=function(){return new T(this.b())};t();u();function S(a){this.b=a}oa(S,Q);S.prototype.a=function(){var a=this.b.next();if(a.done)throw kc;return a.value};S.prototype.next=function(){return S.prototype.a.call(this)};
S.prototype[Symbol.iterator]=function(){return new T(this.b)};S.prototype.c=function(){return new T(this.b)};function T(a){R.call(this,function(){return a});this.f=a}oa(T,R);T.prototype.next=function(){return this.f.next()};function nc(a,b){this.o={};this.j=[];this.B=this.size=0;var c=arguments.length;if(1<c){if(c%2)throw Error("Uneven number of arguments");for(var d=0;d<c;d+=2)this.set(arguments[d],arguments[d+1])}else a&&this.addAll(a)}n=nc.prototype;n.G=function(){oc(this);return this.j.concat()};n.has=function(a){return U(this.o,a)};n.clear=function(){this.o={};this.B=this.size=this.j.length=0};n.remove=function(a){return this.delete(a)};
n.delete=function(a){return U(this.o,a)?(delete this.o[a],--this.size,this.B++,this.j.length>2*this.size&&oc(this),!0):!1};function oc(a){if(a.size!=a.j.length){for(var b=0,c=0;b<a.j.length;){var d=a.j[b];U(a.o,d)&&(a.j[c++]=d);b++}a.j.length=c}if(a.size!=a.j.length){var f={};for(c=b=0;b<a.j.length;)d=a.j[b],U(f,d)||(a.j[c++]=d,f[d]=1),b++;a.j.length=c}}n.get=function(a,b){return U(this.o,a)?this.o[a]:b};n.set=function(a,b){U(this.o,a)||(this.size+=1,this.j.push(a),this.B++);this.o[a]=b};
n.addAll=function(a){if(a instanceof nc)for(var b=a.G(),c=0;c<b.length;c++)this.set(b[c],a.get(b[c]));else for(b in a)this.set(b,a[b])};n.forEach=function(a,b){for(var c=this.G(),d=0;d<c.length;d++){var f=c[d],g=this.get(f);a.call(b,g,f,this)}};n.clone=function(){return new nc(this)};n.keys=function(){return lc(this.u(!0)).c()};n.values=function(){return lc(this.u(!1)).c()};n.entries=function(){var a=this;return jc(this.keys(),function(b){return[b,a.get(b)]})};
n.u=function(a){oc(this);var b=0,c=this.B,d=this,f=new Q;f.a=function(){if(c!=d.B)throw Error("The map has changed since the iterator was created");if(b>=d.j.length)throw kc;var g=d.j[b++];return a?g:d.o[g]};f.next=f.a.bind(f);return f};function U(a,b){return Object.prototype.hasOwnProperty.call(a,b)};var pc=/^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;function qc(a){M.call(this);this.headers=new nc;this.C=a||null;this.c=!1;this.J=this.a=null;this.P=this.v="";this.g=0;this.l="";this.i=this.N=this.s=this.L=!1;this.h=0;this.w=null;this.m=rc;this.I=this.M=!1}B(qc,M);var rc="";qc.prototype.b=$b(ac(),"goog.net.XhrIo",void 0).g;var sc=/^https?$/i,tc=["POST","PUT"];
function uc(a,b,c){if(a.a)throw Error("[goog.net.XhrIo] Object is active with another request="+a.v+"; newUri="+b);a.v=b;a.l="";a.g=0;a.P="POST";a.L=!1;a.c=!0;a.a=a.C?hc(a.C):hc(fc);a.J=a.C?dc(a.C):dc(fc);a.a.onreadystatechange=A(a.R,a);try{P(a.b,V(a,"Opening Xhr")),a.N=!0,a.a.open("POST",String(b),!0),a.N=!1}catch(g){P(a.b,V(a,"Error opening Xhr: "+g.message));vc(a,g);return}b=c||"";c=a.headers.clone();var d=c.G().find(function(g){return"content-type"==g.toLowerCase()}),f=w.FormData&&b instanceof
w.FormData;!(0<=Ma(tc,"POST"))||d||f||c.set("Content-Type","application/x-www-form-urlencoded;charset=utf-8");c.forEach(function(g,e){this.a.setRequestHeader(e,g)},a);a.m&&(a.a.responseType=a.m);"withCredentials"in a.a&&a.a.withCredentials!==a.M&&(a.a.withCredentials=a.M);try{wc(a),0<a.h&&(a.I=xc(a.a),P(a.b,V(a,"Will abort after "+a.h+"ms if incomplete, xhr2 "+a.I)),a.I?(a.a.timeout=a.h,a.a.ontimeout=A(a.T,a)):a.w=Lb(a.T,a.h,a)),P(a.b,V(a,"Sending request")),a.s=!0,a.a.send(b),a.s=!1}catch(g){P(a.b,
V(a,"Send error: "+g.message)),vc(a,g)}}function xc(a){return $a&&ib()&&"number"===typeof a.timeout&&void 0!==a.ontimeout}n=qc.prototype;n.T=function(){"undefined"!=typeof qa&&this.a&&(this.l="Timed out after "+this.h+"ms, aborting",this.g=8,P(this.b,V(this,this.l)),O(this,"timeout"),this.abort(8))};function vc(a,b){a.c=!1;a.a&&(a.i=!0,a.a.abort(),a.i=!1);a.l=b;a.g=5;yc(a);zc(a)}function yc(a){a.L||(a.L=!0,O(a,"complete"),O(a,"error"))}
n.abort=function(a){this.a&&this.c&&(P(this.b,V(this,"Aborting")),this.c=!1,this.i=!0,this.a.abort(),this.i=!1,this.g=a||7,O(this,"complete"),O(this,"abort"),zc(this))};n.R=function(){this.K||(this.N||this.s||this.i?Ac(this):this.W())};n.W=function(){Ac(this)};
function Ac(a){if(a.c&&"undefined"!=typeof qa)if(a.J[1]&&4==W(a)&&2==a.getStatus())P(a.b,V(a,"Local request error detected and ignored"));else if(a.s&&4==W(a))Lb(a.R,0,a);else if(O(a,"readystatechange"),4==W(a)){P(a.b,V(a,"Request complete"));a.c=!1;try{var b=a.getStatus();a:switch(b){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var c=!0;break a;default:c=!1}var d;if(!(d=c)){var f;if(f=0===b){var g=String(a.v).match(pc)[1]||null;if(!g&&w.self&&w.self.location){var e=w.self.location.protocol;
g=e.substr(0,e.length-1)}f=!sc.test(g?g.toLowerCase():"")}d=f}if(d)O(a,"complete"),O(a,"success");else{a.g=6;try{var h=2<W(a)?a.a.statusText:""}catch(k){P(a.b,"Can not get status: "+k.message),h=""}a.l=h+" ["+a.getStatus()+"]";yc(a)}}finally{zc(a)}}}function zc(a){if(a.a){wc(a);var b=a.a,c=a.J[0]?ra:null;a.a=null;a.J=null;O(a,"ready");try{b.onreadystatechange=c}catch(d){(a=a.b)&&bc(a,Ob,"Problem encountered resetting onreadystatechange: "+d.message)}}}
function wc(a){a.a&&a.I&&(a.a.ontimeout=null);a.w&&(Kb.clearTimeout(a.w),a.w=null)}function W(a){return a.a?a.a.readyState:0}n.getStatus=function(){try{return 2<W(this)?this.a.status:-1}catch(a){return-1}};
function Bc(a){try{if(!a.a)return null;if("response"in a.a)return a.a.response;switch(a.m){case rc:case "text":return a.a.responseText;case "arraybuffer":if("mozResponseArrayBuffer"in a.a)return a.a.mozResponseArrayBuffer}var b=a.b;b&&bc(b,Ob,"Response type "+a.m+" is not supported on this browser");return null}catch(c){return P(a.b,"Can not get response: "+c.message),null}}function Cc(a,b){if(a.a&&4==W(a))return a=a.a.getResponseHeader(b),null===a?void 0:a}
function Dc(a){var b={};a=(a.a&&4==W(a)?a.a.getAllResponseHeaders()||"":"").split("\r\n");for(var c=0;c<a.length;c++)if(!/^[\s\xa0]*$/.test(a[c])){var d=Va(a[c]),f=d[0];d=d[1];if("string"===typeof d){d=d.trim();var g=b[f]||[];b[f]=g;g.push(d)}}return Sa(b,function(e){return e.join(", ")})}function V(a,b){return b+" ["+a.P+" "+a.v+" "+a.getStatus()+"]"};var Ec={},Fc=null;function Gc(a){var b=a.length,c=3*b/4;c%3?c=Math.floor(c):I("=.",a[b-1])&&(c=I("=.",a[b-2])?c-2:c-1);var d=new Uint8Array(c),f=0;Hc(a,function(g){d[f++]=g});return d.subarray(0,f)}
function Hc(a,b){function c(k){for(;d<a.length;){var l=a.charAt(d++),m=Fc[l];if(null!=m)return m;if(!/^[\s\xa0]*$/.test(l))throw Error("Unknown base64 encoding at char: "+l);}return k}Ic();for(var d=0;;){var f=c(-1),g=c(0),e=c(64),h=c(64);if(64===h&&-1===f)break;b(f<<2|g>>4);64!=e&&(b(g<<4&240|e>>2),64!=h&&b(e<<6&192|h))}}
function Ic(){if(!Fc){Fc={};for(var a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),b=["+/=","+/","-_=","-_.","-_"],c=0;5>c;c++){var d=a.concat(b[c].split(""));Ec[c]=d;for(var f=0;f<d.length;f++){var g=d[f];void 0===Fc[g]&&(Fc[g]=f)}}}};var Jc=["content-type","grpc-status","grpc-message"];
function X(a){this.a=a.Z;this.m=null;this.b=[];this.h=[];this.g=[];this.f=[];this.c=[];this.l=!1;this.i=0;this.s=new Ea;var b=this;yb(this.a,"readystatechange",function(){var c=b.a;if(c=c.a?c.a.getResponseHeader("Content-Type"):null){c=c.toLowerCase();if(0==c.lastIndexOf("application/grpc-web-text",0)){c=b.a;try{var d=c.a?c.a.responseText:""}catch(k){P(c.b,"Can not get responseText: "+k.message),d=""}c=d||"";d=c.length-c.length%4;c=c.substr(b.i,d-b.i);if(0==c.length)return;b.i=d;c=Gc(c)}else if(0==
c.lastIndexOf("application/grpc",0))c=new Uint8Array(Bc(b.a));else{Y(b,new F(2,"Unknown Content-type received."));return}d=null;try{d=Ga(b.s,c)}catch(k){Y(b,new F(2,"Error in parsing response body"))}if(d)for(c=0;c<d.length;c++){if(Ha in d[c]){var f=d[c][Ha];if(f){var g=void 0;try{g=b.m(f)}catch(k){Y(b,new F(13,"Error when deserializing response data; error: "+k+(", response: "+g)))}if(g){f=b;for(var e=0;e<f.b.length;e++)f.b[e](g)}}}if(H in d[c]&&0<d[c][H].length){f="";for(g=0;g<d[c][H].length;g++)f+=
String.fromCharCode(d[c][H][g]);f=f.trim().split("\r\n");g={};for(e=0;e<f.length;e++){var h=f[e].indexOf(":");g[f[e].substring(0,h).trim()]=f[e].substring(h+1).trim()}f=g;g=0;e="";"grpc-status"in f&&(g=Number(f["grpc-status"]),delete f["grpc-status"]);"grpc-message"in f&&(e=f["grpc-message"],delete f["grpc-message"]);Y(b,new F(g,e,f))}}}});yb(this.a,"complete",function(){var c=b.a.g,d=2,f="",g={},e=Dc(b.a);Object.keys(e).forEach(function(h){Jc.includes(h)||(g[h]=e[h])});Kc(b,g);if(0!=c){switch(c){case 7:d=
10;break;case 8:d=4;break;case 6:d=za(b.a.getStatus());break;default:d=14}10==d&&b.l||Y(b,new F(d,Ba(c)))}else c=!1,"grpc-status"in e&&(d=Number(Cc(b.a,"grpc-status")),"grpc-message"in e&&(f=Cc(b.a,"grpc-message")),0!=d&&(Y(b,new F(d,f||"",e)),c=!0)),c||Lc(b)})}X.prototype.on=function(a,b){"data"==a?this.b.push(b):"status"==a?this.h.push(b):"metadata"==a?this.g.push(b):"end"==a?this.c.push(b):"error"==a&&this.f.push(b);return this};function Mc(a,b){b=a.indexOf(b);-1<b&&a.splice(b,1)}
X.prototype.removeListener=function(a,b){"data"==a?Mc(this.b,b):"status"==a?Mc(this.h,b):"metadata"==a?Mc(this.g,b):"end"==a?Mc(this.c,b):"error"==a&&Mc(this.f,b);return this};X.prototype.cancel=function(){this.l=!0;this.a.abort()};function Y(a,b){if(0!=b.code)for(var c=new F(b.code,decodeURIComponent(b.message||""),b.metadata),d=0;d<a.f.length;d++)a.f[d](c);b={code:b.code,details:decodeURIComponent(b.message||""),metadata:b.metadata};for(c=0;c<a.h.length;c++)a.h[c](b)}
function Kc(a,b){for(var c=0;c<a.g.length;c++)a.g[c](b)}function Lc(a){for(var b=0;b<a.c.length;b++)a.c[b]()}X.prototype.cancel=X.prototype.cancel;X.prototype.removeListener=X.prototype.removeListener;X.prototype.on=X.prototype.on;function Nc(a){var b="";Ra(a,function(c,d){b+=d;b+=":";b+=c;b+="\r\n"});return b};function Z(a,b){a=void 0===a?{}:a;this.a=a.format||y("format",a)||"text";this.g=a.aa||y("suppressCorsPreflight",a)||!1;this.f=a.withCredentials||y("withCredentials",a)||!1;this.b=a.$||y("streamInterceptors",a)||[];this.h=a.ba||y("unaryInterceptors",a)||[];this.c=b||null}Z.prototype.X=function(a,b,c,d,f){var g=this,e=a.substr(0,a.length-d.name.length);a=Oc(function(h){return Pc(g,h,e)},this.b).call(this,ya(d,b,c));Qc(a,f,!1);return new Aa(a)};
Z.prototype.S=function(a,b,c,d){var f=this,g=a.substr(0,a.length-d.name.length);return Oc(function(e){return new Promise(function(h,k){var l=Pc(f,e,g),m,p,q;Qc(l,function(x,z,N,Tb){x?k(x):z?q=z:N?p=N:Tb?m=Tb:(x=e.getMethodDescriptor(),z=m,z=void 0===z?{}:z,h(new D(q,x,z,void 0===p?null:p)))},!0)})},this.h).call(this,ya(d,b,c)).then(function(e){return e.getResponseMessage()})};Z.prototype.unaryCall=function(a,b,c,d){return this.S(a,b,c,d)};
Z.prototype.Y=function(a,b,c,d){var f=this,g=a.substr(0,a.length-d.name.length);return Oc(function(e){return Pc(f,e,g)},this.b).call(this,ya(d,b,c))};
function Pc(a,b,c){var d=b.getMethodDescriptor(),f=c+d.getName();c=a.c?a.c:new qc;c.M=a.f;var g=new X({Z:c}),e=d.getResponseDeserializeFn();g.m=e;e=b.getMetadata();for(var h in e)c.headers.set(h,e[h]);"text"==a.a?(c.headers.set("Content-Type","application/grpc-web-text"),c.headers.set("Accept","application/grpc-web-text")):c.headers.set("Content-Type","application/grpc-web+proto");c.headers.set("X-User-Agent","grpc-web-javascript/0.1");c.headers.set("X-Grpc-Web","1");c.headers.has("deadline")&&(h=
Number(c.headers.get("deadline")),h=Math.ceil(h-(new Date).getTime()),c.headers.delete("deadline"),Infinity===h&&(h=0),0<h&&(c.headers.set("grpc-timeout",h+"m"),c.h=Math.max(0,Math.max(1E3,Math.ceil(1.1*h)))));if(a.g){e=c.headers;h={};for(var k=ha(e.keys()),l=k.next();!l.done;l=k.next())l=l.value,h[l]=e.get(l);c.headers.clear();b:{for(m in h){var m=!1;break b}m=!0}if(!m)if(h=Nc(h),"string"===typeof f){if(m=encodeURIComponent("$httpHeaders"),h=null!=h?"="+encodeURIComponent(String(h)):"",m+=h)h=f.indexOf("#"),
0>h&&(h=f.length),e=f.indexOf("?"),0>e||e>h?(e=h,k=""):k=f.substring(e+1,h),f=[f.substr(0,e),k,f.substr(h)],h=f[1],f[1]=m?h?h+"&"+m:m:h,f=f[0]+(f[1]?"?"+f[1]:"")+f[2]}else f.a("$httpHeaders",h)}b=d.getRequestSerializeFn()(b.getRequestMessage());d=b.length;m=[0,0,0,0];h=new Uint8Array(5+d);for(e=3;0<=e;e--)m[e]=d%256,d>>>=8;h.set(new Uint8Array(m),1);h.set(b,5);b=h;if("text"==a.a){a=b;var p;void 0===p&&(p=0);Ic();p=Ec[p];b=Array(Math.floor(a.length/3));d=p[64]||"";for(m=h=0;h<a.length-2;h+=3){l=a[h];
var q=a[h+1];k=a[h+2];e=p[l>>2];l=p[(l&3)<<4|q>>4];q=p[(q&15)<<2|k>>6];k=p[k&63];b[m++]=e+l+q+k}e=0;k=d;switch(a.length-h){case 2:e=a[h+1],k=p[(e&15)<<2]||d;case 1:a=a[h],b[m]=p[a>>2]+p[(a&3)<<4|e>>4]+k+d}b=b.join("")}else"binary"==a.a&&(c.m="arraybuffer");uc(c,f,b);return g}
function Qc(a,b,c){var d=!1,f=null,g=!1;a.on("data",function(e){d=!0;f=e});a.on("error",function(e){0==e.code||g||(g=!0,b(e,null))});a.on("status",function(e){0==e.code||g?c&&b(null,null,e):(g=!0,b({code:e.code,message:e.details,metadata:e.metadata},null))});if(c)a.on("metadata",function(e){b(null,null,null,e)});a.on("end",function(){g||(d?b(null,f):b({code:2,message:"Incomplete response"}));c&&b(null,null)})}
function Oc(a,b){var c=a;b.forEach(function(d){var f=c;c=function(g){return d.intercept(g,f)}});return c}Z.prototype.serverStreaming=Z.prototype.Y;Z.prototype.unaryCall=Z.prototype.unaryCall;Z.prototype.thenableCall=Z.prototype.S;Z.prototype.rpcCall=Z.prototype.X;module.exports.CallOptions=xa;module.exports.MethodDescriptor=E;module.exports.GrpcWebClientBase=Z;module.exports.RpcError=F;module.exports.StatusCode={OK:0,CANCELLED:1,UNKNOWN:2,INVALID_ARGUMENT:3,DEADLINE_EXCEEDED:4,NOT_FOUND:5,ALREADY_EXISTS:6,PERMISSION_DENIED:7,UNAUTHENTICATED:16,RESOURCE_EXHAUSTED:8,FAILED_PRECONDITION:9,ABORTED:10,OUT_OF_RANGE:11,UNIMPLEMENTED:12,INTERNAL:13,UNAVAILABLE:14,DATA_LOSS:15};module.exports.MethodType={UNARY:"unary",SERVER_STREAMING:"server_streaming",BIDI_STREAMING:"bidi_streaming"};
Kb="undefined"!==typeof globalThis&&globalThis||self;


/***/ }),

/***/ 646:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// source: yorkie/v1/resources.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = __webpack_require__(19);
var goog = jspb;
var global = (function() { return this || window || global || self || Function('return this')(); }).call(null);

var google_protobuf_timestamp_pb = __webpack_require__(134);
goog.object.extend(proto, google_protobuf_timestamp_pb);
var google_protobuf_wrappers_pb = __webpack_require__(469);
goog.object.extend(proto, google_protobuf_wrappers_pb);
goog.exportSymbol('proto.yorkie.v1.Change', null, global);
goog.exportSymbol('proto.yorkie.v1.ChangeID', null, global);
goog.exportSymbol('proto.yorkie.v1.ChangePack', null, global);
goog.exportSymbol('proto.yorkie.v1.Checkpoint', null, global);
goog.exportSymbol('proto.yorkie.v1.DocEvent', null, global);
goog.exportSymbol('proto.yorkie.v1.DocEventType', null, global);
goog.exportSymbol('proto.yorkie.v1.DocumentSummary', null, global);
goog.exportSymbol('proto.yorkie.v1.JSONElement', null, global);
goog.exportSymbol('proto.yorkie.v1.JSONElement.BodyCase', null, global);
goog.exportSymbol('proto.yorkie.v1.JSONElement.Counter', null, global);
goog.exportSymbol('proto.yorkie.v1.JSONElement.JSONArray', null, global);
goog.exportSymbol('proto.yorkie.v1.JSONElement.JSONObject', null, global);
goog.exportSymbol('proto.yorkie.v1.JSONElement.Primitive', null, global);
goog.exportSymbol('proto.yorkie.v1.JSONElement.Text', null, global);
goog.exportSymbol('proto.yorkie.v1.JSONElement.Tree', null, global);
goog.exportSymbol('proto.yorkie.v1.JSONElementSimple', null, global);
goog.exportSymbol('proto.yorkie.v1.NodeAttr', null, global);
goog.exportSymbol('proto.yorkie.v1.Operation', null, global);
goog.exportSymbol('proto.yorkie.v1.Operation.Add', null, global);
goog.exportSymbol('proto.yorkie.v1.Operation.BodyCase', null, global);
goog.exportSymbol('proto.yorkie.v1.Operation.Edit', null, global);
goog.exportSymbol('proto.yorkie.v1.Operation.Increase', null, global);
goog.exportSymbol('proto.yorkie.v1.Operation.Move', null, global);
goog.exportSymbol('proto.yorkie.v1.Operation.Remove', null, global);
goog.exportSymbol('proto.yorkie.v1.Operation.Select', null, global);
goog.exportSymbol('proto.yorkie.v1.Operation.Set', null, global);
goog.exportSymbol('proto.yorkie.v1.Operation.Style', null, global);
goog.exportSymbol('proto.yorkie.v1.Operation.TreeEdit', null, global);
goog.exportSymbol('proto.yorkie.v1.Operation.TreeStyle', null, global);
goog.exportSymbol('proto.yorkie.v1.Presence', null, global);
goog.exportSymbol('proto.yorkie.v1.PresenceChange', null, global);
goog.exportSymbol('proto.yorkie.v1.PresenceChange.ChangeType', null, global);
goog.exportSymbol('proto.yorkie.v1.Project', null, global);
goog.exportSymbol('proto.yorkie.v1.RGANode', null, global);
goog.exportSymbol('proto.yorkie.v1.RHTNode', null, global);
goog.exportSymbol('proto.yorkie.v1.Snapshot', null, global);
goog.exportSymbol('proto.yorkie.v1.TextNode', null, global);
goog.exportSymbol('proto.yorkie.v1.TextNodeID', null, global);
goog.exportSymbol('proto.yorkie.v1.TextNodePos', null, global);
goog.exportSymbol('proto.yorkie.v1.TimeTicket', null, global);
goog.exportSymbol('proto.yorkie.v1.TreeNode', null, global);
goog.exportSymbol('proto.yorkie.v1.TreeNodeID', null, global);
goog.exportSymbol('proto.yorkie.v1.TreeNodes', null, global);
goog.exportSymbol('proto.yorkie.v1.TreePos', null, global);
goog.exportSymbol('proto.yorkie.v1.UpdatableProjectFields', null, global);
goog.exportSymbol('proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods', null, global);
goog.exportSymbol('proto.yorkie.v1.User', null, global);
goog.exportSymbol('proto.yorkie.v1.ValueType', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.Snapshot = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.Snapshot, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.Snapshot.displayName = 'proto.yorkie.v1.Snapshot';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.ChangePack = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.yorkie.v1.ChangePack.repeatedFields_, null);
};
goog.inherits(proto.yorkie.v1.ChangePack, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.ChangePack.displayName = 'proto.yorkie.v1.ChangePack';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.Change = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.yorkie.v1.Change.repeatedFields_, null);
};
goog.inherits(proto.yorkie.v1.Change, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.Change.displayName = 'proto.yorkie.v1.Change';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.ChangeID = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.ChangeID, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.ChangeID.displayName = 'proto.yorkie.v1.ChangeID';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.Operation = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.yorkie.v1.Operation.oneofGroups_);
};
goog.inherits(proto.yorkie.v1.Operation, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.Operation.displayName = 'proto.yorkie.v1.Operation';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.Operation.Set = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.Operation.Set, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.Operation.Set.displayName = 'proto.yorkie.v1.Operation.Set';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.Operation.Add = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.Operation.Add, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.Operation.Add.displayName = 'proto.yorkie.v1.Operation.Add';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.Operation.Move = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.Operation.Move, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.Operation.Move.displayName = 'proto.yorkie.v1.Operation.Move';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.Operation.Remove = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.Operation.Remove, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.Operation.Remove.displayName = 'proto.yorkie.v1.Operation.Remove';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.Operation.Edit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.Operation.Edit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.Operation.Edit.displayName = 'proto.yorkie.v1.Operation.Edit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.Operation.Select = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.Operation.Select, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.Operation.Select.displayName = 'proto.yorkie.v1.Operation.Select';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.Operation.Style = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.Operation.Style, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.Operation.Style.displayName = 'proto.yorkie.v1.Operation.Style';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.Operation.Increase = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.Operation.Increase, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.Operation.Increase.displayName = 'proto.yorkie.v1.Operation.Increase';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.Operation.TreeEdit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.yorkie.v1.Operation.TreeEdit.repeatedFields_, null);
};
goog.inherits(proto.yorkie.v1.Operation.TreeEdit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.Operation.TreeEdit.displayName = 'proto.yorkie.v1.Operation.TreeEdit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.Operation.TreeStyle = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.Operation.TreeStyle, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.Operation.TreeStyle.displayName = 'proto.yorkie.v1.Operation.TreeStyle';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.JSONElementSimple = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.JSONElementSimple, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.JSONElementSimple.displayName = 'proto.yorkie.v1.JSONElementSimple';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.JSONElement = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.yorkie.v1.JSONElement.oneofGroups_);
};
goog.inherits(proto.yorkie.v1.JSONElement, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.JSONElement.displayName = 'proto.yorkie.v1.JSONElement';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.JSONElement.JSONObject = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.yorkie.v1.JSONElement.JSONObject.repeatedFields_, null);
};
goog.inherits(proto.yorkie.v1.JSONElement.JSONObject, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.JSONElement.JSONObject.displayName = 'proto.yorkie.v1.JSONElement.JSONObject';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.JSONElement.JSONArray = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.yorkie.v1.JSONElement.JSONArray.repeatedFields_, null);
};
goog.inherits(proto.yorkie.v1.JSONElement.JSONArray, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.JSONElement.JSONArray.displayName = 'proto.yorkie.v1.JSONElement.JSONArray';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.JSONElement.Primitive = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.JSONElement.Primitive, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.JSONElement.Primitive.displayName = 'proto.yorkie.v1.JSONElement.Primitive';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.JSONElement.Text = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.yorkie.v1.JSONElement.Text.repeatedFields_, null);
};
goog.inherits(proto.yorkie.v1.JSONElement.Text, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.JSONElement.Text.displayName = 'proto.yorkie.v1.JSONElement.Text';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.JSONElement.Counter = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.JSONElement.Counter, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.JSONElement.Counter.displayName = 'proto.yorkie.v1.JSONElement.Counter';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.JSONElement.Tree = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.yorkie.v1.JSONElement.Tree.repeatedFields_, null);
};
goog.inherits(proto.yorkie.v1.JSONElement.Tree, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.JSONElement.Tree.displayName = 'proto.yorkie.v1.JSONElement.Tree';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.RHTNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.RHTNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.RHTNode.displayName = 'proto.yorkie.v1.RHTNode';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.RGANode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.RGANode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.RGANode.displayName = 'proto.yorkie.v1.RGANode';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.NodeAttr = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.NodeAttr, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.NodeAttr.displayName = 'proto.yorkie.v1.NodeAttr';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.TextNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.TextNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.TextNode.displayName = 'proto.yorkie.v1.TextNode';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.TextNodeID = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.TextNodeID, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.TextNodeID.displayName = 'proto.yorkie.v1.TextNodeID';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.TreeNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.TreeNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.TreeNode.displayName = 'proto.yorkie.v1.TreeNode';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.TreeNodes = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.yorkie.v1.TreeNodes.repeatedFields_, null);
};
goog.inherits(proto.yorkie.v1.TreeNodes, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.TreeNodes.displayName = 'proto.yorkie.v1.TreeNodes';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.TreeNodeID = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.TreeNodeID, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.TreeNodeID.displayName = 'proto.yorkie.v1.TreeNodeID';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.TreePos = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.TreePos, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.TreePos.displayName = 'proto.yorkie.v1.TreePos';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.User = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.User, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.User.displayName = 'proto.yorkie.v1.User';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.Project = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.yorkie.v1.Project.repeatedFields_, null);
};
goog.inherits(proto.yorkie.v1.Project, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.Project.displayName = 'proto.yorkie.v1.Project';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.UpdatableProjectFields = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.UpdatableProjectFields, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.UpdatableProjectFields.displayName = 'proto.yorkie.v1.UpdatableProjectFields';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.repeatedFields_, null);
};
goog.inherits(proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.displayName = 'proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.DocumentSummary = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.DocumentSummary, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.DocumentSummary.displayName = 'proto.yorkie.v1.DocumentSummary';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.PresenceChange = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.PresenceChange, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.PresenceChange.displayName = 'proto.yorkie.v1.PresenceChange';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.Presence = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.Presence, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.Presence.displayName = 'proto.yorkie.v1.Presence';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.Checkpoint = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.Checkpoint, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.Checkpoint.displayName = 'proto.yorkie.v1.Checkpoint';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.TextNodePos = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.TextNodePos, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.TextNodePos.displayName = 'proto.yorkie.v1.TextNodePos';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.TimeTicket = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.TimeTicket, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.TimeTicket.displayName = 'proto.yorkie.v1.TimeTicket';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.DocEvent = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.DocEvent, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.DocEvent.displayName = 'proto.yorkie.v1.DocEvent';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.Snapshot.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.Snapshot.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.Snapshot} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Snapshot.toObject = function(includeInstance, msg) {
  var f, obj = {
    root: (f = msg.getRoot()) && proto.yorkie.v1.JSONElement.toObject(includeInstance, f),
    presencesMap: (f = msg.getPresencesMap()) ? f.toObject(includeInstance, proto.yorkie.v1.Presence.toObject) : []
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.Snapshot}
 */
proto.yorkie.v1.Snapshot.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.Snapshot;
  return proto.yorkie.v1.Snapshot.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.Snapshot} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.Snapshot}
 */
proto.yorkie.v1.Snapshot.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.JSONElement;
      reader.readMessage(value,proto.yorkie.v1.JSONElement.deserializeBinaryFromReader);
      msg.setRoot(value);
      break;
    case 2:
      var value = msg.getPresencesMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, proto.yorkie.v1.Presence.deserializeBinaryFromReader, "", new proto.yorkie.v1.Presence());
         });
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.Snapshot.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.Snapshot.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.Snapshot} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Snapshot.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.JSONElement.serializeBinaryToWriter
    );
  }
  f = message.getPresencesMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(2, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, proto.yorkie.v1.Presence.serializeBinaryToWriter);
  }
};


/**
 * optional JSONElement root = 1;
 * @return {?proto.yorkie.v1.JSONElement}
 */
proto.yorkie.v1.Snapshot.prototype.getRoot = function() {
  return /** @type{?proto.yorkie.v1.JSONElement} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.JSONElement, 1));
};


/**
 * @param {?proto.yorkie.v1.JSONElement|undefined} value
 * @return {!proto.yorkie.v1.Snapshot} returns this
*/
proto.yorkie.v1.Snapshot.prototype.setRoot = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Snapshot} returns this
 */
proto.yorkie.v1.Snapshot.prototype.clearRoot = function() {
  return this.setRoot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Snapshot.prototype.hasRoot = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * map<string, Presence> presences = 2;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.yorkie.v1.Presence>}
 */
proto.yorkie.v1.Snapshot.prototype.getPresencesMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,!proto.yorkie.v1.Presence>} */ (
      jspb.Message.getMapField(this, 2, opt_noLazyCreate,
      proto.yorkie.v1.Presence));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.yorkie.v1.Snapshot} returns this
 */
proto.yorkie.v1.Snapshot.prototype.clearPresencesMap = function() {
  this.getPresencesMap().clear();
  return this;};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.yorkie.v1.ChangePack.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.ChangePack.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.ChangePack.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.ChangePack} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.ChangePack.toObject = function(includeInstance, msg) {
  var f, obj = {
    documentKey: jspb.Message.getFieldWithDefault(msg, 1, ""),
    checkpoint: (f = msg.getCheckpoint()) && proto.yorkie.v1.Checkpoint.toObject(includeInstance, f),
    snapshot: msg.getSnapshot_asB64(),
    changesList: jspb.Message.toObjectList(msg.getChangesList(),
    proto.yorkie.v1.Change.toObject, includeInstance),
    minSyncedTicket: (f = msg.getMinSyncedTicket()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    isRemoved: jspb.Message.getBooleanFieldWithDefault(msg, 6, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.ChangePack}
 */
proto.yorkie.v1.ChangePack.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.ChangePack;
  return proto.yorkie.v1.ChangePack.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.ChangePack} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.ChangePack}
 */
proto.yorkie.v1.ChangePack.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setDocumentKey(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.Checkpoint;
      reader.readMessage(value,proto.yorkie.v1.Checkpoint.deserializeBinaryFromReader);
      msg.setCheckpoint(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSnapshot(value);
      break;
    case 4:
      var value = new proto.yorkie.v1.Change;
      reader.readMessage(value,proto.yorkie.v1.Change.deserializeBinaryFromReader);
      msg.addChanges(value);
      break;
    case 5:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setMinSyncedTicket(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsRemoved(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.ChangePack.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.ChangePack.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.ChangePack} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.ChangePack.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDocumentKey();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getCheckpoint();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.Checkpoint.serializeBinaryToWriter
    );
  }
  f = message.getSnapshot_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getChangesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.yorkie.v1.Change.serializeBinaryToWriter
    );
  }
  f = message.getMinSyncedTicket();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getIsRemoved();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
};


/**
 * optional string document_key = 1;
 * @return {string}
 */
proto.yorkie.v1.ChangePack.prototype.getDocumentKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.ChangePack} returns this
 */
proto.yorkie.v1.ChangePack.prototype.setDocumentKey = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional Checkpoint checkpoint = 2;
 * @return {?proto.yorkie.v1.Checkpoint}
 */
proto.yorkie.v1.ChangePack.prototype.getCheckpoint = function() {
  return /** @type{?proto.yorkie.v1.Checkpoint} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.Checkpoint, 2));
};


/**
 * @param {?proto.yorkie.v1.Checkpoint|undefined} value
 * @return {!proto.yorkie.v1.ChangePack} returns this
*/
proto.yorkie.v1.ChangePack.prototype.setCheckpoint = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.ChangePack} returns this
 */
proto.yorkie.v1.ChangePack.prototype.clearCheckpoint = function() {
  return this.setCheckpoint(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.ChangePack.prototype.hasCheckpoint = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes snapshot = 3;
 * @return {string}
 */
proto.yorkie.v1.ChangePack.prototype.getSnapshot = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes snapshot = 3;
 * This is a type-conversion wrapper around `getSnapshot()`
 * @return {string}
 */
proto.yorkie.v1.ChangePack.prototype.getSnapshot_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSnapshot()));
};


/**
 * optional bytes snapshot = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSnapshot()`
 * @return {!Uint8Array}
 */
proto.yorkie.v1.ChangePack.prototype.getSnapshot_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSnapshot()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.yorkie.v1.ChangePack} returns this
 */
proto.yorkie.v1.ChangePack.prototype.setSnapshot = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * repeated Change changes = 4;
 * @return {!Array<!proto.yorkie.v1.Change>}
 */
proto.yorkie.v1.ChangePack.prototype.getChangesList = function() {
  return /** @type{!Array<!proto.yorkie.v1.Change>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.yorkie.v1.Change, 4));
};


/**
 * @param {!Array<!proto.yorkie.v1.Change>} value
 * @return {!proto.yorkie.v1.ChangePack} returns this
*/
proto.yorkie.v1.ChangePack.prototype.setChangesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.yorkie.v1.Change=} opt_value
 * @param {number=} opt_index
 * @return {!proto.yorkie.v1.Change}
 */
proto.yorkie.v1.ChangePack.prototype.addChanges = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.yorkie.v1.Change, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.yorkie.v1.ChangePack} returns this
 */
proto.yorkie.v1.ChangePack.prototype.clearChangesList = function() {
  return this.setChangesList([]);
};


/**
 * optional TimeTicket min_synced_ticket = 5;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.ChangePack.prototype.getMinSyncedTicket = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 5));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.ChangePack} returns this
*/
proto.yorkie.v1.ChangePack.prototype.setMinSyncedTicket = function(value) {
  return jspb.Message.setWrapperField(this, 5, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.ChangePack} returns this
 */
proto.yorkie.v1.ChangePack.prototype.clearMinSyncedTicket = function() {
  return this.setMinSyncedTicket(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.ChangePack.prototype.hasMinSyncedTicket = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional bool is_removed = 6;
 * @return {boolean}
 */
proto.yorkie.v1.ChangePack.prototype.getIsRemoved = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 6, false));
};


/**
 * @param {boolean} value
 * @return {!proto.yorkie.v1.ChangePack} returns this
 */
proto.yorkie.v1.ChangePack.prototype.setIsRemoved = function(value) {
  return jspb.Message.setProto3BooleanField(this, 6, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.yorkie.v1.Change.repeatedFields_ = [3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.Change.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.Change.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.Change} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Change.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: (f = msg.getId()) && proto.yorkie.v1.ChangeID.toObject(includeInstance, f),
    message: jspb.Message.getFieldWithDefault(msg, 2, ""),
    operationsList: jspb.Message.toObjectList(msg.getOperationsList(),
    proto.yorkie.v1.Operation.toObject, includeInstance),
    presenceChange: (f = msg.getPresenceChange()) && proto.yorkie.v1.PresenceChange.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.Change}
 */
proto.yorkie.v1.Change.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.Change;
  return proto.yorkie.v1.Change.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.Change} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.Change}
 */
proto.yorkie.v1.Change.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.ChangeID;
      reader.readMessage(value,proto.yorkie.v1.ChangeID.deserializeBinaryFromReader);
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.Operation;
      reader.readMessage(value,proto.yorkie.v1.Operation.deserializeBinaryFromReader);
      msg.addOperations(value);
      break;
    case 4:
      var value = new proto.yorkie.v1.PresenceChange;
      reader.readMessage(value,proto.yorkie.v1.PresenceChange.deserializeBinaryFromReader);
      msg.setPresenceChange(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.Change.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.Change.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.Change} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Change.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.ChangeID.serializeBinaryToWriter
    );
  }
  f = message.getMessage();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getOperationsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.yorkie.v1.Operation.serializeBinaryToWriter
    );
  }
  f = message.getPresenceChange();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.yorkie.v1.PresenceChange.serializeBinaryToWriter
    );
  }
};


/**
 * optional ChangeID id = 1;
 * @return {?proto.yorkie.v1.ChangeID}
 */
proto.yorkie.v1.Change.prototype.getId = function() {
  return /** @type{?proto.yorkie.v1.ChangeID} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.ChangeID, 1));
};


/**
 * @param {?proto.yorkie.v1.ChangeID|undefined} value
 * @return {!proto.yorkie.v1.Change} returns this
*/
proto.yorkie.v1.Change.prototype.setId = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Change} returns this
 */
proto.yorkie.v1.Change.prototype.clearId = function() {
  return this.setId(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Change.prototype.hasId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string message = 2;
 * @return {string}
 */
proto.yorkie.v1.Change.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.Change} returns this
 */
proto.yorkie.v1.Change.prototype.setMessage = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * repeated Operation operations = 3;
 * @return {!Array<!proto.yorkie.v1.Operation>}
 */
proto.yorkie.v1.Change.prototype.getOperationsList = function() {
  return /** @type{!Array<!proto.yorkie.v1.Operation>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.yorkie.v1.Operation, 3));
};


/**
 * @param {!Array<!proto.yorkie.v1.Operation>} value
 * @return {!proto.yorkie.v1.Change} returns this
*/
proto.yorkie.v1.Change.prototype.setOperationsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.yorkie.v1.Operation=} opt_value
 * @param {number=} opt_index
 * @return {!proto.yorkie.v1.Operation}
 */
proto.yorkie.v1.Change.prototype.addOperations = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.yorkie.v1.Operation, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.yorkie.v1.Change} returns this
 */
proto.yorkie.v1.Change.prototype.clearOperationsList = function() {
  return this.setOperationsList([]);
};


/**
 * optional PresenceChange presence_change = 4;
 * @return {?proto.yorkie.v1.PresenceChange}
 */
proto.yorkie.v1.Change.prototype.getPresenceChange = function() {
  return /** @type{?proto.yorkie.v1.PresenceChange} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.PresenceChange, 4));
};


/**
 * @param {?proto.yorkie.v1.PresenceChange|undefined} value
 * @return {!proto.yorkie.v1.Change} returns this
*/
proto.yorkie.v1.Change.prototype.setPresenceChange = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Change} returns this
 */
proto.yorkie.v1.Change.prototype.clearPresenceChange = function() {
  return this.setPresenceChange(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Change.prototype.hasPresenceChange = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.ChangeID.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.ChangeID.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.ChangeID} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.ChangeID.toObject = function(includeInstance, msg) {
  var f, obj = {
    clientSeq: jspb.Message.getFieldWithDefault(msg, 1, 0),
    serverSeq: jspb.Message.getFieldWithDefault(msg, 2, "0"),
    lamport: jspb.Message.getFieldWithDefault(msg, 3, "0"),
    actorId: msg.getActorId_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.ChangeID}
 */
proto.yorkie.v1.ChangeID.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.ChangeID;
  return proto.yorkie.v1.ChangeID.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.ChangeID} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.ChangeID}
 */
proto.yorkie.v1.ChangeID.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setClientSeq(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readInt64String());
      msg.setServerSeq(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readInt64String());
      msg.setLamport(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setActorId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.ChangeID.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.ChangeID.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.ChangeID} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.ChangeID.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getClientSeq();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getServerSeq();
  if (parseInt(f, 10) !== 0) {
    writer.writeInt64String(
      2,
      f
    );
  }
  f = message.getLamport();
  if (parseInt(f, 10) !== 0) {
    writer.writeInt64String(
      3,
      f
    );
  }
  f = message.getActorId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * optional uint32 client_seq = 1;
 * @return {number}
 */
proto.yorkie.v1.ChangeID.prototype.getClientSeq = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.yorkie.v1.ChangeID} returns this
 */
proto.yorkie.v1.ChangeID.prototype.setClientSeq = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional int64 server_seq = 2;
 * @return {string}
 */
proto.yorkie.v1.ChangeID.prototype.getServerSeq = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, "0"));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.ChangeID} returns this
 */
proto.yorkie.v1.ChangeID.prototype.setServerSeq = function(value) {
  return jspb.Message.setProto3StringIntField(this, 2, value);
};


/**
 * optional int64 lamport = 3;
 * @return {string}
 */
proto.yorkie.v1.ChangeID.prototype.getLamport = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, "0"));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.ChangeID} returns this
 */
proto.yorkie.v1.ChangeID.prototype.setLamport = function(value) {
  return jspb.Message.setProto3StringIntField(this, 3, value);
};


/**
 * optional bytes actor_id = 4;
 * @return {string}
 */
proto.yorkie.v1.ChangeID.prototype.getActorId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes actor_id = 4;
 * This is a type-conversion wrapper around `getActorId()`
 * @return {string}
 */
proto.yorkie.v1.ChangeID.prototype.getActorId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getActorId()));
};


/**
 * optional bytes actor_id = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getActorId()`
 * @return {!Uint8Array}
 */
proto.yorkie.v1.ChangeID.prototype.getActorId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getActorId()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.yorkie.v1.ChangeID} returns this
 */
proto.yorkie.v1.ChangeID.prototype.setActorId = function(value) {
  return jspb.Message.setProto3BytesField(this, 4, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.yorkie.v1.Operation.oneofGroups_ = [[1,2,3,4,5,6,7,8,9,10]];

/**
 * @enum {number}
 */
proto.yorkie.v1.Operation.BodyCase = {
  BODY_NOT_SET: 0,
  SET: 1,
  ADD: 2,
  MOVE: 3,
  REMOVE: 4,
  EDIT: 5,
  SELECT: 6,
  STYLE: 7,
  INCREASE: 8,
  TREE_EDIT: 9,
  TREE_STYLE: 10
};

/**
 * @return {proto.yorkie.v1.Operation.BodyCase}
 */
proto.yorkie.v1.Operation.prototype.getBodyCase = function() {
  return /** @type {proto.yorkie.v1.Operation.BodyCase} */(jspb.Message.computeOneofCase(this, proto.yorkie.v1.Operation.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.Operation.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.Operation.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.Operation} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.toObject = function(includeInstance, msg) {
  var f, obj = {
    set: (f = msg.getSet()) && proto.yorkie.v1.Operation.Set.toObject(includeInstance, f),
    add: (f = msg.getAdd()) && proto.yorkie.v1.Operation.Add.toObject(includeInstance, f),
    move: (f = msg.getMove()) && proto.yorkie.v1.Operation.Move.toObject(includeInstance, f),
    remove: (f = msg.getRemove()) && proto.yorkie.v1.Operation.Remove.toObject(includeInstance, f),
    edit: (f = msg.getEdit()) && proto.yorkie.v1.Operation.Edit.toObject(includeInstance, f),
    select: (f = msg.getSelect()) && proto.yorkie.v1.Operation.Select.toObject(includeInstance, f),
    style: (f = msg.getStyle()) && proto.yorkie.v1.Operation.Style.toObject(includeInstance, f),
    increase: (f = msg.getIncrease()) && proto.yorkie.v1.Operation.Increase.toObject(includeInstance, f),
    treeEdit: (f = msg.getTreeEdit()) && proto.yorkie.v1.Operation.TreeEdit.toObject(includeInstance, f),
    treeStyle: (f = msg.getTreeStyle()) && proto.yorkie.v1.Operation.TreeStyle.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.Operation}
 */
proto.yorkie.v1.Operation.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.Operation;
  return proto.yorkie.v1.Operation.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.Operation} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.Operation}
 */
proto.yorkie.v1.Operation.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.Operation.Set;
      reader.readMessage(value,proto.yorkie.v1.Operation.Set.deserializeBinaryFromReader);
      msg.setSet(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.Operation.Add;
      reader.readMessage(value,proto.yorkie.v1.Operation.Add.deserializeBinaryFromReader);
      msg.setAdd(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.Operation.Move;
      reader.readMessage(value,proto.yorkie.v1.Operation.Move.deserializeBinaryFromReader);
      msg.setMove(value);
      break;
    case 4:
      var value = new proto.yorkie.v1.Operation.Remove;
      reader.readMessage(value,proto.yorkie.v1.Operation.Remove.deserializeBinaryFromReader);
      msg.setRemove(value);
      break;
    case 5:
      var value = new proto.yorkie.v1.Operation.Edit;
      reader.readMessage(value,proto.yorkie.v1.Operation.Edit.deserializeBinaryFromReader);
      msg.setEdit(value);
      break;
    case 6:
      var value = new proto.yorkie.v1.Operation.Select;
      reader.readMessage(value,proto.yorkie.v1.Operation.Select.deserializeBinaryFromReader);
      msg.setSelect(value);
      break;
    case 7:
      var value = new proto.yorkie.v1.Operation.Style;
      reader.readMessage(value,proto.yorkie.v1.Operation.Style.deserializeBinaryFromReader);
      msg.setStyle(value);
      break;
    case 8:
      var value = new proto.yorkie.v1.Operation.Increase;
      reader.readMessage(value,proto.yorkie.v1.Operation.Increase.deserializeBinaryFromReader);
      msg.setIncrease(value);
      break;
    case 9:
      var value = new proto.yorkie.v1.Operation.TreeEdit;
      reader.readMessage(value,proto.yorkie.v1.Operation.TreeEdit.deserializeBinaryFromReader);
      msg.setTreeEdit(value);
      break;
    case 10:
      var value = new proto.yorkie.v1.Operation.TreeStyle;
      reader.readMessage(value,proto.yorkie.v1.Operation.TreeStyle.deserializeBinaryFromReader);
      msg.setTreeStyle(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.Operation.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.Operation.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.Operation} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSet();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.Operation.Set.serializeBinaryToWriter
    );
  }
  f = message.getAdd();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.Operation.Add.serializeBinaryToWriter
    );
  }
  f = message.getMove();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.Operation.Move.serializeBinaryToWriter
    );
  }
  f = message.getRemove();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.yorkie.v1.Operation.Remove.serializeBinaryToWriter
    );
  }
  f = message.getEdit();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.yorkie.v1.Operation.Edit.serializeBinaryToWriter
    );
  }
  f = message.getSelect();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.yorkie.v1.Operation.Select.serializeBinaryToWriter
    );
  }
  f = message.getStyle();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.yorkie.v1.Operation.Style.serializeBinaryToWriter
    );
  }
  f = message.getIncrease();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.yorkie.v1.Operation.Increase.serializeBinaryToWriter
    );
  }
  f = message.getTreeEdit();
  if (f != null) {
    writer.writeMessage(
      9,
      f,
      proto.yorkie.v1.Operation.TreeEdit.serializeBinaryToWriter
    );
  }
  f = message.getTreeStyle();
  if (f != null) {
    writer.writeMessage(
      10,
      f,
      proto.yorkie.v1.Operation.TreeStyle.serializeBinaryToWriter
    );
  }
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.Operation.Set.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.Operation.Set.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.Operation.Set} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.Set.toObject = function(includeInstance, msg) {
  var f, obj = {
    parentCreatedAt: (f = msg.getParentCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    key: jspb.Message.getFieldWithDefault(msg, 2, ""),
    value: (f = msg.getValue()) && proto.yorkie.v1.JSONElementSimple.toObject(includeInstance, f),
    executedAt: (f = msg.getExecutedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.Operation.Set}
 */
proto.yorkie.v1.Operation.Set.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.Operation.Set;
  return proto.yorkie.v1.Operation.Set.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.Operation.Set} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.Operation.Set}
 */
proto.yorkie.v1.Operation.Set.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setParentCreatedAt(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setKey(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.JSONElementSimple;
      reader.readMessage(value,proto.yorkie.v1.JSONElementSimple.deserializeBinaryFromReader);
      msg.setValue(value);
      break;
    case 4:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setExecutedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.Operation.Set.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.Operation.Set.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.Operation.Set} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.Set.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getParentCreatedAt();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getKey();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getValue();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.JSONElementSimple.serializeBinaryToWriter
    );
  }
  f = message.getExecutedAt();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
};


/**
 * optional TimeTicket parent_created_at = 1;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Set.prototype.getParentCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 1));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Set} returns this
*/
proto.yorkie.v1.Operation.Set.prototype.setParentCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Set} returns this
 */
proto.yorkie.v1.Operation.Set.prototype.clearParentCreatedAt = function() {
  return this.setParentCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Set.prototype.hasParentCreatedAt = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string key = 2;
 * @return {string}
 */
proto.yorkie.v1.Operation.Set.prototype.getKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.Operation.Set} returns this
 */
proto.yorkie.v1.Operation.Set.prototype.setKey = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional JSONElementSimple value = 3;
 * @return {?proto.yorkie.v1.JSONElementSimple}
 */
proto.yorkie.v1.Operation.Set.prototype.getValue = function() {
  return /** @type{?proto.yorkie.v1.JSONElementSimple} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.JSONElementSimple, 3));
};


/**
 * @param {?proto.yorkie.v1.JSONElementSimple|undefined} value
 * @return {!proto.yorkie.v1.Operation.Set} returns this
*/
proto.yorkie.v1.Operation.Set.prototype.setValue = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Set} returns this
 */
proto.yorkie.v1.Operation.Set.prototype.clearValue = function() {
  return this.setValue(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Set.prototype.hasValue = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional TimeTicket executed_at = 4;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Set.prototype.getExecutedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 4));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Set} returns this
*/
proto.yorkie.v1.Operation.Set.prototype.setExecutedAt = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Set} returns this
 */
proto.yorkie.v1.Operation.Set.prototype.clearExecutedAt = function() {
  return this.setExecutedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Set.prototype.hasExecutedAt = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.Operation.Add.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.Operation.Add.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.Operation.Add} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.Add.toObject = function(includeInstance, msg) {
  var f, obj = {
    parentCreatedAt: (f = msg.getParentCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    prevCreatedAt: (f = msg.getPrevCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    value: (f = msg.getValue()) && proto.yorkie.v1.JSONElementSimple.toObject(includeInstance, f),
    executedAt: (f = msg.getExecutedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.Operation.Add}
 */
proto.yorkie.v1.Operation.Add.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.Operation.Add;
  return proto.yorkie.v1.Operation.Add.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.Operation.Add} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.Operation.Add}
 */
proto.yorkie.v1.Operation.Add.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setParentCreatedAt(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setPrevCreatedAt(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.JSONElementSimple;
      reader.readMessage(value,proto.yorkie.v1.JSONElementSimple.deserializeBinaryFromReader);
      msg.setValue(value);
      break;
    case 4:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setExecutedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.Operation.Add.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.Operation.Add.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.Operation.Add} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.Add.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getParentCreatedAt();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getPrevCreatedAt();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getValue();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.JSONElementSimple.serializeBinaryToWriter
    );
  }
  f = message.getExecutedAt();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
};


/**
 * optional TimeTicket parent_created_at = 1;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Add.prototype.getParentCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 1));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Add} returns this
*/
proto.yorkie.v1.Operation.Add.prototype.setParentCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Add} returns this
 */
proto.yorkie.v1.Operation.Add.prototype.clearParentCreatedAt = function() {
  return this.setParentCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Add.prototype.hasParentCreatedAt = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TimeTicket prev_created_at = 2;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Add.prototype.getPrevCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 2));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Add} returns this
*/
proto.yorkie.v1.Operation.Add.prototype.setPrevCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Add} returns this
 */
proto.yorkie.v1.Operation.Add.prototype.clearPrevCreatedAt = function() {
  return this.setPrevCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Add.prototype.hasPrevCreatedAt = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional JSONElementSimple value = 3;
 * @return {?proto.yorkie.v1.JSONElementSimple}
 */
proto.yorkie.v1.Operation.Add.prototype.getValue = function() {
  return /** @type{?proto.yorkie.v1.JSONElementSimple} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.JSONElementSimple, 3));
};


/**
 * @param {?proto.yorkie.v1.JSONElementSimple|undefined} value
 * @return {!proto.yorkie.v1.Operation.Add} returns this
*/
proto.yorkie.v1.Operation.Add.prototype.setValue = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Add} returns this
 */
proto.yorkie.v1.Operation.Add.prototype.clearValue = function() {
  return this.setValue(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Add.prototype.hasValue = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional TimeTicket executed_at = 4;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Add.prototype.getExecutedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 4));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Add} returns this
*/
proto.yorkie.v1.Operation.Add.prototype.setExecutedAt = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Add} returns this
 */
proto.yorkie.v1.Operation.Add.prototype.clearExecutedAt = function() {
  return this.setExecutedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Add.prototype.hasExecutedAt = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.Operation.Move.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.Operation.Move.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.Operation.Move} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.Move.toObject = function(includeInstance, msg) {
  var f, obj = {
    parentCreatedAt: (f = msg.getParentCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    prevCreatedAt: (f = msg.getPrevCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    createdAt: (f = msg.getCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    executedAt: (f = msg.getExecutedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.Operation.Move}
 */
proto.yorkie.v1.Operation.Move.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.Operation.Move;
  return proto.yorkie.v1.Operation.Move.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.Operation.Move} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.Operation.Move}
 */
proto.yorkie.v1.Operation.Move.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setParentCreatedAt(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setPrevCreatedAt(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setCreatedAt(value);
      break;
    case 4:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setExecutedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.Operation.Move.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.Operation.Move.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.Operation.Move} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.Move.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getParentCreatedAt();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getPrevCreatedAt();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getCreatedAt();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getExecutedAt();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
};


/**
 * optional TimeTicket parent_created_at = 1;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Move.prototype.getParentCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 1));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Move} returns this
*/
proto.yorkie.v1.Operation.Move.prototype.setParentCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Move} returns this
 */
proto.yorkie.v1.Operation.Move.prototype.clearParentCreatedAt = function() {
  return this.setParentCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Move.prototype.hasParentCreatedAt = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TimeTicket prev_created_at = 2;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Move.prototype.getPrevCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 2));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Move} returns this
*/
proto.yorkie.v1.Operation.Move.prototype.setPrevCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Move} returns this
 */
proto.yorkie.v1.Operation.Move.prototype.clearPrevCreatedAt = function() {
  return this.setPrevCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Move.prototype.hasPrevCreatedAt = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TimeTicket created_at = 3;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Move.prototype.getCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 3));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Move} returns this
*/
proto.yorkie.v1.Operation.Move.prototype.setCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Move} returns this
 */
proto.yorkie.v1.Operation.Move.prototype.clearCreatedAt = function() {
  return this.setCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Move.prototype.hasCreatedAt = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional TimeTicket executed_at = 4;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Move.prototype.getExecutedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 4));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Move} returns this
*/
proto.yorkie.v1.Operation.Move.prototype.setExecutedAt = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Move} returns this
 */
proto.yorkie.v1.Operation.Move.prototype.clearExecutedAt = function() {
  return this.setExecutedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Move.prototype.hasExecutedAt = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.Operation.Remove.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.Operation.Remove.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.Operation.Remove} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.Remove.toObject = function(includeInstance, msg) {
  var f, obj = {
    parentCreatedAt: (f = msg.getParentCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    createdAt: (f = msg.getCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    executedAt: (f = msg.getExecutedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.Operation.Remove}
 */
proto.yorkie.v1.Operation.Remove.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.Operation.Remove;
  return proto.yorkie.v1.Operation.Remove.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.Operation.Remove} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.Operation.Remove}
 */
proto.yorkie.v1.Operation.Remove.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setParentCreatedAt(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setCreatedAt(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setExecutedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.Operation.Remove.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.Operation.Remove.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.Operation.Remove} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.Remove.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getParentCreatedAt();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getCreatedAt();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getExecutedAt();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
};


/**
 * optional TimeTicket parent_created_at = 1;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Remove.prototype.getParentCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 1));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Remove} returns this
*/
proto.yorkie.v1.Operation.Remove.prototype.setParentCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Remove} returns this
 */
proto.yorkie.v1.Operation.Remove.prototype.clearParentCreatedAt = function() {
  return this.setParentCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Remove.prototype.hasParentCreatedAt = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TimeTicket created_at = 2;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Remove.prototype.getCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 2));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Remove} returns this
*/
proto.yorkie.v1.Operation.Remove.prototype.setCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Remove} returns this
 */
proto.yorkie.v1.Operation.Remove.prototype.clearCreatedAt = function() {
  return this.setCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Remove.prototype.hasCreatedAt = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TimeTicket executed_at = 3;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Remove.prototype.getExecutedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 3));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Remove} returns this
*/
proto.yorkie.v1.Operation.Remove.prototype.setExecutedAt = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Remove} returns this
 */
proto.yorkie.v1.Operation.Remove.prototype.clearExecutedAt = function() {
  return this.setExecutedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Remove.prototype.hasExecutedAt = function() {
  return jspb.Message.getField(this, 3) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.Operation.Edit.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.Operation.Edit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.Operation.Edit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.Edit.toObject = function(includeInstance, msg) {
  var f, obj = {
    parentCreatedAt: (f = msg.getParentCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    from: (f = msg.getFrom()) && proto.yorkie.v1.TextNodePos.toObject(includeInstance, f),
    to: (f = msg.getTo()) && proto.yorkie.v1.TextNodePos.toObject(includeInstance, f),
    createdAtMapByActorMap: (f = msg.getCreatedAtMapByActorMap()) ? f.toObject(includeInstance, proto.yorkie.v1.TimeTicket.toObject) : [],
    content: jspb.Message.getFieldWithDefault(msg, 5, ""),
    executedAt: (f = msg.getExecutedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    attributesMap: (f = msg.getAttributesMap()) ? f.toObject(includeInstance, undefined) : []
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.Operation.Edit}
 */
proto.yorkie.v1.Operation.Edit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.Operation.Edit;
  return proto.yorkie.v1.Operation.Edit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.Operation.Edit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.Operation.Edit}
 */
proto.yorkie.v1.Operation.Edit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setParentCreatedAt(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.TextNodePos;
      reader.readMessage(value,proto.yorkie.v1.TextNodePos.deserializeBinaryFromReader);
      msg.setFrom(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.TextNodePos;
      reader.readMessage(value,proto.yorkie.v1.TextNodePos.deserializeBinaryFromReader);
      msg.setTo(value);
      break;
    case 4:
      var value = msg.getCreatedAtMapByActorMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader, "", new proto.yorkie.v1.TimeTicket());
         });
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setContent(value);
      break;
    case 6:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setExecutedAt(value);
      break;
    case 7:
      var value = msg.getAttributesMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readString, null, "", "");
         });
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.Operation.Edit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.Operation.Edit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.Operation.Edit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.Edit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getParentCreatedAt();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getFrom();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.TextNodePos.serializeBinaryToWriter
    );
  }
  f = message.getTo();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.TextNodePos.serializeBinaryToWriter
    );
  }
  f = message.getCreatedAtMapByActorMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(4, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, proto.yorkie.v1.TimeTicket.serializeBinaryToWriter);
  }
  f = message.getContent();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getExecutedAt();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getAttributesMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(7, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeString);
  }
};


/**
 * optional TimeTicket parent_created_at = 1;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Edit.prototype.getParentCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 1));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Edit} returns this
*/
proto.yorkie.v1.Operation.Edit.prototype.setParentCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Edit} returns this
 */
proto.yorkie.v1.Operation.Edit.prototype.clearParentCreatedAt = function() {
  return this.setParentCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Edit.prototype.hasParentCreatedAt = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TextNodePos from = 2;
 * @return {?proto.yorkie.v1.TextNodePos}
 */
proto.yorkie.v1.Operation.Edit.prototype.getFrom = function() {
  return /** @type{?proto.yorkie.v1.TextNodePos} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TextNodePos, 2));
};


/**
 * @param {?proto.yorkie.v1.TextNodePos|undefined} value
 * @return {!proto.yorkie.v1.Operation.Edit} returns this
*/
proto.yorkie.v1.Operation.Edit.prototype.setFrom = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Edit} returns this
 */
proto.yorkie.v1.Operation.Edit.prototype.clearFrom = function() {
  return this.setFrom(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Edit.prototype.hasFrom = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TextNodePos to = 3;
 * @return {?proto.yorkie.v1.TextNodePos}
 */
proto.yorkie.v1.Operation.Edit.prototype.getTo = function() {
  return /** @type{?proto.yorkie.v1.TextNodePos} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TextNodePos, 3));
};


/**
 * @param {?proto.yorkie.v1.TextNodePos|undefined} value
 * @return {!proto.yorkie.v1.Operation.Edit} returns this
*/
proto.yorkie.v1.Operation.Edit.prototype.setTo = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Edit} returns this
 */
proto.yorkie.v1.Operation.Edit.prototype.clearTo = function() {
  return this.setTo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Edit.prototype.hasTo = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * map<string, TimeTicket> created_at_map_by_actor = 4;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.yorkie.v1.TimeTicket>}
 */
proto.yorkie.v1.Operation.Edit.prototype.getCreatedAtMapByActorMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,!proto.yorkie.v1.TimeTicket>} */ (
      jspb.Message.getMapField(this, 4, opt_noLazyCreate,
      proto.yorkie.v1.TimeTicket));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.yorkie.v1.Operation.Edit} returns this
 */
proto.yorkie.v1.Operation.Edit.prototype.clearCreatedAtMapByActorMap = function() {
  this.getCreatedAtMapByActorMap().clear();
  return this;};


/**
 * optional string content = 5;
 * @return {string}
 */
proto.yorkie.v1.Operation.Edit.prototype.getContent = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.Operation.Edit} returns this
 */
proto.yorkie.v1.Operation.Edit.prototype.setContent = function(value) {
  return jspb.Message.setProto3StringField(this, 5, value);
};


/**
 * optional TimeTicket executed_at = 6;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Edit.prototype.getExecutedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 6));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Edit} returns this
*/
proto.yorkie.v1.Operation.Edit.prototype.setExecutedAt = function(value) {
  return jspb.Message.setWrapperField(this, 6, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Edit} returns this
 */
proto.yorkie.v1.Operation.Edit.prototype.clearExecutedAt = function() {
  return this.setExecutedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Edit.prototype.hasExecutedAt = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * map<string, string> attributes = 7;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,string>}
 */
proto.yorkie.v1.Operation.Edit.prototype.getAttributesMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,string>} */ (
      jspb.Message.getMapField(this, 7, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.yorkie.v1.Operation.Edit} returns this
 */
proto.yorkie.v1.Operation.Edit.prototype.clearAttributesMap = function() {
  this.getAttributesMap().clear();
  return this;};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.Operation.Select.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.Operation.Select.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.Operation.Select} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.Select.toObject = function(includeInstance, msg) {
  var f, obj = {
    parentCreatedAt: (f = msg.getParentCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    from: (f = msg.getFrom()) && proto.yorkie.v1.TextNodePos.toObject(includeInstance, f),
    to: (f = msg.getTo()) && proto.yorkie.v1.TextNodePos.toObject(includeInstance, f),
    executedAt: (f = msg.getExecutedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.Operation.Select}
 */
proto.yorkie.v1.Operation.Select.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.Operation.Select;
  return proto.yorkie.v1.Operation.Select.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.Operation.Select} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.Operation.Select}
 */
proto.yorkie.v1.Operation.Select.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setParentCreatedAt(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.TextNodePos;
      reader.readMessage(value,proto.yorkie.v1.TextNodePos.deserializeBinaryFromReader);
      msg.setFrom(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.TextNodePos;
      reader.readMessage(value,proto.yorkie.v1.TextNodePos.deserializeBinaryFromReader);
      msg.setTo(value);
      break;
    case 4:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setExecutedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.Operation.Select.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.Operation.Select.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.Operation.Select} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.Select.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getParentCreatedAt();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getFrom();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.TextNodePos.serializeBinaryToWriter
    );
  }
  f = message.getTo();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.TextNodePos.serializeBinaryToWriter
    );
  }
  f = message.getExecutedAt();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
};


/**
 * optional TimeTicket parent_created_at = 1;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Select.prototype.getParentCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 1));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Select} returns this
*/
proto.yorkie.v1.Operation.Select.prototype.setParentCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Select} returns this
 */
proto.yorkie.v1.Operation.Select.prototype.clearParentCreatedAt = function() {
  return this.setParentCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Select.prototype.hasParentCreatedAt = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TextNodePos from = 2;
 * @return {?proto.yorkie.v1.TextNodePos}
 */
proto.yorkie.v1.Operation.Select.prototype.getFrom = function() {
  return /** @type{?proto.yorkie.v1.TextNodePos} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TextNodePos, 2));
};


/**
 * @param {?proto.yorkie.v1.TextNodePos|undefined} value
 * @return {!proto.yorkie.v1.Operation.Select} returns this
*/
proto.yorkie.v1.Operation.Select.prototype.setFrom = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Select} returns this
 */
proto.yorkie.v1.Operation.Select.prototype.clearFrom = function() {
  return this.setFrom(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Select.prototype.hasFrom = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TextNodePos to = 3;
 * @return {?proto.yorkie.v1.TextNodePos}
 */
proto.yorkie.v1.Operation.Select.prototype.getTo = function() {
  return /** @type{?proto.yorkie.v1.TextNodePos} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TextNodePos, 3));
};


/**
 * @param {?proto.yorkie.v1.TextNodePos|undefined} value
 * @return {!proto.yorkie.v1.Operation.Select} returns this
*/
proto.yorkie.v1.Operation.Select.prototype.setTo = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Select} returns this
 */
proto.yorkie.v1.Operation.Select.prototype.clearTo = function() {
  return this.setTo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Select.prototype.hasTo = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional TimeTicket executed_at = 4;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Select.prototype.getExecutedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 4));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Select} returns this
*/
proto.yorkie.v1.Operation.Select.prototype.setExecutedAt = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Select} returns this
 */
proto.yorkie.v1.Operation.Select.prototype.clearExecutedAt = function() {
  return this.setExecutedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Select.prototype.hasExecutedAt = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.Operation.Style.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.Operation.Style.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.Operation.Style} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.Style.toObject = function(includeInstance, msg) {
  var f, obj = {
    parentCreatedAt: (f = msg.getParentCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    from: (f = msg.getFrom()) && proto.yorkie.v1.TextNodePos.toObject(includeInstance, f),
    to: (f = msg.getTo()) && proto.yorkie.v1.TextNodePos.toObject(includeInstance, f),
    attributesMap: (f = msg.getAttributesMap()) ? f.toObject(includeInstance, undefined) : [],
    executedAt: (f = msg.getExecutedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    createdAtMapByActorMap: (f = msg.getCreatedAtMapByActorMap()) ? f.toObject(includeInstance, proto.yorkie.v1.TimeTicket.toObject) : []
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.Operation.Style}
 */
proto.yorkie.v1.Operation.Style.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.Operation.Style;
  return proto.yorkie.v1.Operation.Style.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.Operation.Style} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.Operation.Style}
 */
proto.yorkie.v1.Operation.Style.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setParentCreatedAt(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.TextNodePos;
      reader.readMessage(value,proto.yorkie.v1.TextNodePos.deserializeBinaryFromReader);
      msg.setFrom(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.TextNodePos;
      reader.readMessage(value,proto.yorkie.v1.TextNodePos.deserializeBinaryFromReader);
      msg.setTo(value);
      break;
    case 4:
      var value = msg.getAttributesMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readString, null, "", "");
         });
      break;
    case 5:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setExecutedAt(value);
      break;
    case 6:
      var value = msg.getCreatedAtMapByActorMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader, "", new proto.yorkie.v1.TimeTicket());
         });
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.Operation.Style.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.Operation.Style.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.Operation.Style} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.Style.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getParentCreatedAt();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getFrom();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.TextNodePos.serializeBinaryToWriter
    );
  }
  f = message.getTo();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.TextNodePos.serializeBinaryToWriter
    );
  }
  f = message.getAttributesMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(4, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeString);
  }
  f = message.getExecutedAt();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getCreatedAtMapByActorMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(6, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, proto.yorkie.v1.TimeTicket.serializeBinaryToWriter);
  }
};


/**
 * optional TimeTicket parent_created_at = 1;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Style.prototype.getParentCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 1));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Style} returns this
*/
proto.yorkie.v1.Operation.Style.prototype.setParentCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Style} returns this
 */
proto.yorkie.v1.Operation.Style.prototype.clearParentCreatedAt = function() {
  return this.setParentCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Style.prototype.hasParentCreatedAt = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TextNodePos from = 2;
 * @return {?proto.yorkie.v1.TextNodePos}
 */
proto.yorkie.v1.Operation.Style.prototype.getFrom = function() {
  return /** @type{?proto.yorkie.v1.TextNodePos} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TextNodePos, 2));
};


/**
 * @param {?proto.yorkie.v1.TextNodePos|undefined} value
 * @return {!proto.yorkie.v1.Operation.Style} returns this
*/
proto.yorkie.v1.Operation.Style.prototype.setFrom = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Style} returns this
 */
proto.yorkie.v1.Operation.Style.prototype.clearFrom = function() {
  return this.setFrom(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Style.prototype.hasFrom = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TextNodePos to = 3;
 * @return {?proto.yorkie.v1.TextNodePos}
 */
proto.yorkie.v1.Operation.Style.prototype.getTo = function() {
  return /** @type{?proto.yorkie.v1.TextNodePos} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TextNodePos, 3));
};


/**
 * @param {?proto.yorkie.v1.TextNodePos|undefined} value
 * @return {!proto.yorkie.v1.Operation.Style} returns this
*/
proto.yorkie.v1.Operation.Style.prototype.setTo = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Style} returns this
 */
proto.yorkie.v1.Operation.Style.prototype.clearTo = function() {
  return this.setTo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Style.prototype.hasTo = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * map<string, string> attributes = 4;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,string>}
 */
proto.yorkie.v1.Operation.Style.prototype.getAttributesMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,string>} */ (
      jspb.Message.getMapField(this, 4, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.yorkie.v1.Operation.Style} returns this
 */
proto.yorkie.v1.Operation.Style.prototype.clearAttributesMap = function() {
  this.getAttributesMap().clear();
  return this;};


/**
 * optional TimeTicket executed_at = 5;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Style.prototype.getExecutedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 5));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Style} returns this
*/
proto.yorkie.v1.Operation.Style.prototype.setExecutedAt = function(value) {
  return jspb.Message.setWrapperField(this, 5, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Style} returns this
 */
proto.yorkie.v1.Operation.Style.prototype.clearExecutedAt = function() {
  return this.setExecutedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Style.prototype.hasExecutedAt = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * map<string, TimeTicket> created_at_map_by_actor = 6;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.yorkie.v1.TimeTicket>}
 */
proto.yorkie.v1.Operation.Style.prototype.getCreatedAtMapByActorMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,!proto.yorkie.v1.TimeTicket>} */ (
      jspb.Message.getMapField(this, 6, opt_noLazyCreate,
      proto.yorkie.v1.TimeTicket));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.yorkie.v1.Operation.Style} returns this
 */
proto.yorkie.v1.Operation.Style.prototype.clearCreatedAtMapByActorMap = function() {
  this.getCreatedAtMapByActorMap().clear();
  return this;};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.Operation.Increase.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.Operation.Increase.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.Operation.Increase} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.Increase.toObject = function(includeInstance, msg) {
  var f, obj = {
    parentCreatedAt: (f = msg.getParentCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    value: (f = msg.getValue()) && proto.yorkie.v1.JSONElementSimple.toObject(includeInstance, f),
    executedAt: (f = msg.getExecutedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.Operation.Increase}
 */
proto.yorkie.v1.Operation.Increase.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.Operation.Increase;
  return proto.yorkie.v1.Operation.Increase.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.Operation.Increase} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.Operation.Increase}
 */
proto.yorkie.v1.Operation.Increase.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setParentCreatedAt(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.JSONElementSimple;
      reader.readMessage(value,proto.yorkie.v1.JSONElementSimple.deserializeBinaryFromReader);
      msg.setValue(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setExecutedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.Operation.Increase.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.Operation.Increase.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.Operation.Increase} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.Increase.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getParentCreatedAt();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getValue();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.JSONElementSimple.serializeBinaryToWriter
    );
  }
  f = message.getExecutedAt();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
};


/**
 * optional TimeTicket parent_created_at = 1;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Increase.prototype.getParentCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 1));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Increase} returns this
*/
proto.yorkie.v1.Operation.Increase.prototype.setParentCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Increase} returns this
 */
proto.yorkie.v1.Operation.Increase.prototype.clearParentCreatedAt = function() {
  return this.setParentCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Increase.prototype.hasParentCreatedAt = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional JSONElementSimple value = 2;
 * @return {?proto.yorkie.v1.JSONElementSimple}
 */
proto.yorkie.v1.Operation.Increase.prototype.getValue = function() {
  return /** @type{?proto.yorkie.v1.JSONElementSimple} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.JSONElementSimple, 2));
};


/**
 * @param {?proto.yorkie.v1.JSONElementSimple|undefined} value
 * @return {!proto.yorkie.v1.Operation.Increase} returns this
*/
proto.yorkie.v1.Operation.Increase.prototype.setValue = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Increase} returns this
 */
proto.yorkie.v1.Operation.Increase.prototype.clearValue = function() {
  return this.setValue(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Increase.prototype.hasValue = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TimeTicket executed_at = 3;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.Increase.prototype.getExecutedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 3));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.Increase} returns this
*/
proto.yorkie.v1.Operation.Increase.prototype.setExecutedAt = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.Increase} returns this
 */
proto.yorkie.v1.Operation.Increase.prototype.clearExecutedAt = function() {
  return this.setExecutedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.Increase.prototype.hasExecutedAt = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.yorkie.v1.Operation.TreeEdit.repeatedFields_ = [5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.Operation.TreeEdit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.Operation.TreeEdit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.TreeEdit.toObject = function(includeInstance, msg) {
  var f, obj = {
    parentCreatedAt: (f = msg.getParentCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    from: (f = msg.getFrom()) && proto.yorkie.v1.TreePos.toObject(includeInstance, f),
    to: (f = msg.getTo()) && proto.yorkie.v1.TreePos.toObject(includeInstance, f),
    createdAtMapByActorMap: (f = msg.getCreatedAtMapByActorMap()) ? f.toObject(includeInstance, proto.yorkie.v1.TimeTicket.toObject) : [],
    contentsList: jspb.Message.toObjectList(msg.getContentsList(),
    proto.yorkie.v1.TreeNodes.toObject, includeInstance),
    executedAt: (f = msg.getExecutedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.Operation.TreeEdit}
 */
proto.yorkie.v1.Operation.TreeEdit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.Operation.TreeEdit;
  return proto.yorkie.v1.Operation.TreeEdit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.Operation.TreeEdit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.Operation.TreeEdit}
 */
proto.yorkie.v1.Operation.TreeEdit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setParentCreatedAt(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.TreePos;
      reader.readMessage(value,proto.yorkie.v1.TreePos.deserializeBinaryFromReader);
      msg.setFrom(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.TreePos;
      reader.readMessage(value,proto.yorkie.v1.TreePos.deserializeBinaryFromReader);
      msg.setTo(value);
      break;
    case 4:
      var value = msg.getCreatedAtMapByActorMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader, "", new proto.yorkie.v1.TimeTicket());
         });
      break;
    case 5:
      var value = new proto.yorkie.v1.TreeNodes;
      reader.readMessage(value,proto.yorkie.v1.TreeNodes.deserializeBinaryFromReader);
      msg.addContents(value);
      break;
    case 6:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setExecutedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.Operation.TreeEdit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.Operation.TreeEdit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.TreeEdit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getParentCreatedAt();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getFrom();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.TreePos.serializeBinaryToWriter
    );
  }
  f = message.getTo();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.TreePos.serializeBinaryToWriter
    );
  }
  f = message.getCreatedAtMapByActorMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(4, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, proto.yorkie.v1.TimeTicket.serializeBinaryToWriter);
  }
  f = message.getContentsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      proto.yorkie.v1.TreeNodes.serializeBinaryToWriter
    );
  }
  f = message.getExecutedAt();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
};


/**
 * optional TimeTicket parent_created_at = 1;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.getParentCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 1));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.TreeEdit} returns this
*/
proto.yorkie.v1.Operation.TreeEdit.prototype.setParentCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.TreeEdit} returns this
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.clearParentCreatedAt = function() {
  return this.setParentCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.hasParentCreatedAt = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TreePos from = 2;
 * @return {?proto.yorkie.v1.TreePos}
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.getFrom = function() {
  return /** @type{?proto.yorkie.v1.TreePos} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TreePos, 2));
};


/**
 * @param {?proto.yorkie.v1.TreePos|undefined} value
 * @return {!proto.yorkie.v1.Operation.TreeEdit} returns this
*/
proto.yorkie.v1.Operation.TreeEdit.prototype.setFrom = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.TreeEdit} returns this
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.clearFrom = function() {
  return this.setFrom(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.hasFrom = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TreePos to = 3;
 * @return {?proto.yorkie.v1.TreePos}
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.getTo = function() {
  return /** @type{?proto.yorkie.v1.TreePos} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TreePos, 3));
};


/**
 * @param {?proto.yorkie.v1.TreePos|undefined} value
 * @return {!proto.yorkie.v1.Operation.TreeEdit} returns this
*/
proto.yorkie.v1.Operation.TreeEdit.prototype.setTo = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.TreeEdit} returns this
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.clearTo = function() {
  return this.setTo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.hasTo = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * map<string, TimeTicket> created_at_map_by_actor = 4;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.yorkie.v1.TimeTicket>}
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.getCreatedAtMapByActorMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,!proto.yorkie.v1.TimeTicket>} */ (
      jspb.Message.getMapField(this, 4, opt_noLazyCreate,
      proto.yorkie.v1.TimeTicket));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.yorkie.v1.Operation.TreeEdit} returns this
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.clearCreatedAtMapByActorMap = function() {
  this.getCreatedAtMapByActorMap().clear();
  return this;};


/**
 * repeated TreeNodes contents = 5;
 * @return {!Array<!proto.yorkie.v1.TreeNodes>}
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.getContentsList = function() {
  return /** @type{!Array<!proto.yorkie.v1.TreeNodes>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.yorkie.v1.TreeNodes, 5));
};


/**
 * @param {!Array<!proto.yorkie.v1.TreeNodes>} value
 * @return {!proto.yorkie.v1.Operation.TreeEdit} returns this
*/
proto.yorkie.v1.Operation.TreeEdit.prototype.setContentsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.yorkie.v1.TreeNodes=} opt_value
 * @param {number=} opt_index
 * @return {!proto.yorkie.v1.TreeNodes}
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.addContents = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.yorkie.v1.TreeNodes, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.yorkie.v1.Operation.TreeEdit} returns this
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.clearContentsList = function() {
  return this.setContentsList([]);
};


/**
 * optional TimeTicket executed_at = 6;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.getExecutedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 6));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.TreeEdit} returns this
*/
proto.yorkie.v1.Operation.TreeEdit.prototype.setExecutedAt = function(value) {
  return jspb.Message.setWrapperField(this, 6, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.TreeEdit} returns this
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.clearExecutedAt = function() {
  return this.setExecutedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.TreeEdit.prototype.hasExecutedAt = function() {
  return jspb.Message.getField(this, 6) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.Operation.TreeStyle.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.Operation.TreeStyle.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.Operation.TreeStyle} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.TreeStyle.toObject = function(includeInstance, msg) {
  var f, obj = {
    parentCreatedAt: (f = msg.getParentCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    from: (f = msg.getFrom()) && proto.yorkie.v1.TreePos.toObject(includeInstance, f),
    to: (f = msg.getTo()) && proto.yorkie.v1.TreePos.toObject(includeInstance, f),
    attributesMap: (f = msg.getAttributesMap()) ? f.toObject(includeInstance, undefined) : [],
    executedAt: (f = msg.getExecutedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.Operation.TreeStyle}
 */
proto.yorkie.v1.Operation.TreeStyle.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.Operation.TreeStyle;
  return proto.yorkie.v1.Operation.TreeStyle.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.Operation.TreeStyle} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.Operation.TreeStyle}
 */
proto.yorkie.v1.Operation.TreeStyle.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setParentCreatedAt(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.TreePos;
      reader.readMessage(value,proto.yorkie.v1.TreePos.deserializeBinaryFromReader);
      msg.setFrom(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.TreePos;
      reader.readMessage(value,proto.yorkie.v1.TreePos.deserializeBinaryFromReader);
      msg.setTo(value);
      break;
    case 4:
      var value = msg.getAttributesMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readString, null, "", "");
         });
      break;
    case 5:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setExecutedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.Operation.TreeStyle.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.Operation.TreeStyle.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.Operation.TreeStyle} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Operation.TreeStyle.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getParentCreatedAt();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getFrom();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.TreePos.serializeBinaryToWriter
    );
  }
  f = message.getTo();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.TreePos.serializeBinaryToWriter
    );
  }
  f = message.getAttributesMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(4, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeString);
  }
  f = message.getExecutedAt();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
};


/**
 * optional TimeTicket parent_created_at = 1;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.TreeStyle.prototype.getParentCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 1));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.TreeStyle} returns this
*/
proto.yorkie.v1.Operation.TreeStyle.prototype.setParentCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.TreeStyle} returns this
 */
proto.yorkie.v1.Operation.TreeStyle.prototype.clearParentCreatedAt = function() {
  return this.setParentCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.TreeStyle.prototype.hasParentCreatedAt = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TreePos from = 2;
 * @return {?proto.yorkie.v1.TreePos}
 */
proto.yorkie.v1.Operation.TreeStyle.prototype.getFrom = function() {
  return /** @type{?proto.yorkie.v1.TreePos} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TreePos, 2));
};


/**
 * @param {?proto.yorkie.v1.TreePos|undefined} value
 * @return {!proto.yorkie.v1.Operation.TreeStyle} returns this
*/
proto.yorkie.v1.Operation.TreeStyle.prototype.setFrom = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.TreeStyle} returns this
 */
proto.yorkie.v1.Operation.TreeStyle.prototype.clearFrom = function() {
  return this.setFrom(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.TreeStyle.prototype.hasFrom = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TreePos to = 3;
 * @return {?proto.yorkie.v1.TreePos}
 */
proto.yorkie.v1.Operation.TreeStyle.prototype.getTo = function() {
  return /** @type{?proto.yorkie.v1.TreePos} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TreePos, 3));
};


/**
 * @param {?proto.yorkie.v1.TreePos|undefined} value
 * @return {!proto.yorkie.v1.Operation.TreeStyle} returns this
*/
proto.yorkie.v1.Operation.TreeStyle.prototype.setTo = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.TreeStyle} returns this
 */
proto.yorkie.v1.Operation.TreeStyle.prototype.clearTo = function() {
  return this.setTo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.TreeStyle.prototype.hasTo = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * map<string, string> attributes = 4;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,string>}
 */
proto.yorkie.v1.Operation.TreeStyle.prototype.getAttributesMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,string>} */ (
      jspb.Message.getMapField(this, 4, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.yorkie.v1.Operation.TreeStyle} returns this
 */
proto.yorkie.v1.Operation.TreeStyle.prototype.clearAttributesMap = function() {
  this.getAttributesMap().clear();
  return this;};


/**
 * optional TimeTicket executed_at = 5;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.Operation.TreeStyle.prototype.getExecutedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 5));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.Operation.TreeStyle} returns this
*/
proto.yorkie.v1.Operation.TreeStyle.prototype.setExecutedAt = function(value) {
  return jspb.Message.setWrapperField(this, 5, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation.TreeStyle} returns this
 */
proto.yorkie.v1.Operation.TreeStyle.prototype.clearExecutedAt = function() {
  return this.setExecutedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.TreeStyle.prototype.hasExecutedAt = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional Set set = 1;
 * @return {?proto.yorkie.v1.Operation.Set}
 */
proto.yorkie.v1.Operation.prototype.getSet = function() {
  return /** @type{?proto.yorkie.v1.Operation.Set} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.Operation.Set, 1));
};


/**
 * @param {?proto.yorkie.v1.Operation.Set|undefined} value
 * @return {!proto.yorkie.v1.Operation} returns this
*/
proto.yorkie.v1.Operation.prototype.setSet = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.yorkie.v1.Operation.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation} returns this
 */
proto.yorkie.v1.Operation.prototype.clearSet = function() {
  return this.setSet(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.prototype.hasSet = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Add add = 2;
 * @return {?proto.yorkie.v1.Operation.Add}
 */
proto.yorkie.v1.Operation.prototype.getAdd = function() {
  return /** @type{?proto.yorkie.v1.Operation.Add} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.Operation.Add, 2));
};


/**
 * @param {?proto.yorkie.v1.Operation.Add|undefined} value
 * @return {!proto.yorkie.v1.Operation} returns this
*/
proto.yorkie.v1.Operation.prototype.setAdd = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.yorkie.v1.Operation.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation} returns this
 */
proto.yorkie.v1.Operation.prototype.clearAdd = function() {
  return this.setAdd(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.prototype.hasAdd = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Move move = 3;
 * @return {?proto.yorkie.v1.Operation.Move}
 */
proto.yorkie.v1.Operation.prototype.getMove = function() {
  return /** @type{?proto.yorkie.v1.Operation.Move} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.Operation.Move, 3));
};


/**
 * @param {?proto.yorkie.v1.Operation.Move|undefined} value
 * @return {!proto.yorkie.v1.Operation} returns this
*/
proto.yorkie.v1.Operation.prototype.setMove = function(value) {
  return jspb.Message.setOneofWrapperField(this, 3, proto.yorkie.v1.Operation.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation} returns this
 */
proto.yorkie.v1.Operation.prototype.clearMove = function() {
  return this.setMove(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.prototype.hasMove = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional Remove remove = 4;
 * @return {?proto.yorkie.v1.Operation.Remove}
 */
proto.yorkie.v1.Operation.prototype.getRemove = function() {
  return /** @type{?proto.yorkie.v1.Operation.Remove} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.Operation.Remove, 4));
};


/**
 * @param {?proto.yorkie.v1.Operation.Remove|undefined} value
 * @return {!proto.yorkie.v1.Operation} returns this
*/
proto.yorkie.v1.Operation.prototype.setRemove = function(value) {
  return jspb.Message.setOneofWrapperField(this, 4, proto.yorkie.v1.Operation.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation} returns this
 */
proto.yorkie.v1.Operation.prototype.clearRemove = function() {
  return this.setRemove(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.prototype.hasRemove = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional Edit edit = 5;
 * @return {?proto.yorkie.v1.Operation.Edit}
 */
proto.yorkie.v1.Operation.prototype.getEdit = function() {
  return /** @type{?proto.yorkie.v1.Operation.Edit} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.Operation.Edit, 5));
};


/**
 * @param {?proto.yorkie.v1.Operation.Edit|undefined} value
 * @return {!proto.yorkie.v1.Operation} returns this
*/
proto.yorkie.v1.Operation.prototype.setEdit = function(value) {
  return jspb.Message.setOneofWrapperField(this, 5, proto.yorkie.v1.Operation.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation} returns this
 */
proto.yorkie.v1.Operation.prototype.clearEdit = function() {
  return this.setEdit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.prototype.hasEdit = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional Select select = 6;
 * @return {?proto.yorkie.v1.Operation.Select}
 */
proto.yorkie.v1.Operation.prototype.getSelect = function() {
  return /** @type{?proto.yorkie.v1.Operation.Select} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.Operation.Select, 6));
};


/**
 * @param {?proto.yorkie.v1.Operation.Select|undefined} value
 * @return {!proto.yorkie.v1.Operation} returns this
*/
proto.yorkie.v1.Operation.prototype.setSelect = function(value) {
  return jspb.Message.setOneofWrapperField(this, 6, proto.yorkie.v1.Operation.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation} returns this
 */
proto.yorkie.v1.Operation.prototype.clearSelect = function() {
  return this.setSelect(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.prototype.hasSelect = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional Style style = 7;
 * @return {?proto.yorkie.v1.Operation.Style}
 */
proto.yorkie.v1.Operation.prototype.getStyle = function() {
  return /** @type{?proto.yorkie.v1.Operation.Style} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.Operation.Style, 7));
};


/**
 * @param {?proto.yorkie.v1.Operation.Style|undefined} value
 * @return {!proto.yorkie.v1.Operation} returns this
*/
proto.yorkie.v1.Operation.prototype.setStyle = function(value) {
  return jspb.Message.setOneofWrapperField(this, 7, proto.yorkie.v1.Operation.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation} returns this
 */
proto.yorkie.v1.Operation.prototype.clearStyle = function() {
  return this.setStyle(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.prototype.hasStyle = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional Increase increase = 8;
 * @return {?proto.yorkie.v1.Operation.Increase}
 */
proto.yorkie.v1.Operation.prototype.getIncrease = function() {
  return /** @type{?proto.yorkie.v1.Operation.Increase} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.Operation.Increase, 8));
};


/**
 * @param {?proto.yorkie.v1.Operation.Increase|undefined} value
 * @return {!proto.yorkie.v1.Operation} returns this
*/
proto.yorkie.v1.Operation.prototype.setIncrease = function(value) {
  return jspb.Message.setOneofWrapperField(this, 8, proto.yorkie.v1.Operation.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation} returns this
 */
proto.yorkie.v1.Operation.prototype.clearIncrease = function() {
  return this.setIncrease(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.prototype.hasIncrease = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional TreeEdit tree_edit = 9;
 * @return {?proto.yorkie.v1.Operation.TreeEdit}
 */
proto.yorkie.v1.Operation.prototype.getTreeEdit = function() {
  return /** @type{?proto.yorkie.v1.Operation.TreeEdit} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.Operation.TreeEdit, 9));
};


/**
 * @param {?proto.yorkie.v1.Operation.TreeEdit|undefined} value
 * @return {!proto.yorkie.v1.Operation} returns this
*/
proto.yorkie.v1.Operation.prototype.setTreeEdit = function(value) {
  return jspb.Message.setOneofWrapperField(this, 9, proto.yorkie.v1.Operation.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation} returns this
 */
proto.yorkie.v1.Operation.prototype.clearTreeEdit = function() {
  return this.setTreeEdit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.prototype.hasTreeEdit = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional TreeStyle tree_style = 10;
 * @return {?proto.yorkie.v1.Operation.TreeStyle}
 */
proto.yorkie.v1.Operation.prototype.getTreeStyle = function() {
  return /** @type{?proto.yorkie.v1.Operation.TreeStyle} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.Operation.TreeStyle, 10));
};


/**
 * @param {?proto.yorkie.v1.Operation.TreeStyle|undefined} value
 * @return {!proto.yorkie.v1.Operation} returns this
*/
proto.yorkie.v1.Operation.prototype.setTreeStyle = function(value) {
  return jspb.Message.setOneofWrapperField(this, 10, proto.yorkie.v1.Operation.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Operation} returns this
 */
proto.yorkie.v1.Operation.prototype.clearTreeStyle = function() {
  return this.setTreeStyle(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Operation.prototype.hasTreeStyle = function() {
  return jspb.Message.getField(this, 10) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.JSONElementSimple.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.JSONElementSimple.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.JSONElementSimple} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.JSONElementSimple.toObject = function(includeInstance, msg) {
  var f, obj = {
    createdAt: (f = msg.getCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    movedAt: (f = msg.getMovedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    removedAt: (f = msg.getRemovedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    type: jspb.Message.getFieldWithDefault(msg, 4, 0),
    value: msg.getValue_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.JSONElementSimple}
 */
proto.yorkie.v1.JSONElementSimple.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.JSONElementSimple;
  return proto.yorkie.v1.JSONElementSimple.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.JSONElementSimple} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.JSONElementSimple}
 */
proto.yorkie.v1.JSONElementSimple.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setCreatedAt(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setMovedAt(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setRemovedAt(value);
      break;
    case 4:
      var value = /** @type {!proto.yorkie.v1.ValueType} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.JSONElementSimple.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.JSONElementSimple.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.JSONElementSimple} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.JSONElementSimple.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCreatedAt();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getMovedAt();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getRemovedAt();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      4,
      f
    );
  }
  f = message.getValue_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
};


/**
 * optional TimeTicket created_at = 1;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElementSimple.prototype.getCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 1));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElementSimple} returns this
*/
proto.yorkie.v1.JSONElementSimple.prototype.setCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElementSimple} returns this
 */
proto.yorkie.v1.JSONElementSimple.prototype.clearCreatedAt = function() {
  return this.setCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElementSimple.prototype.hasCreatedAt = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TimeTicket moved_at = 2;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElementSimple.prototype.getMovedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 2));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElementSimple} returns this
*/
proto.yorkie.v1.JSONElementSimple.prototype.setMovedAt = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElementSimple} returns this
 */
proto.yorkie.v1.JSONElementSimple.prototype.clearMovedAt = function() {
  return this.setMovedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElementSimple.prototype.hasMovedAt = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TimeTicket removed_at = 3;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElementSimple.prototype.getRemovedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 3));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElementSimple} returns this
*/
proto.yorkie.v1.JSONElementSimple.prototype.setRemovedAt = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElementSimple} returns this
 */
proto.yorkie.v1.JSONElementSimple.prototype.clearRemovedAt = function() {
  return this.setRemovedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElementSimple.prototype.hasRemovedAt = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional ValueType type = 4;
 * @return {!proto.yorkie.v1.ValueType}
 */
proto.yorkie.v1.JSONElementSimple.prototype.getType = function() {
  return /** @type {!proto.yorkie.v1.ValueType} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {!proto.yorkie.v1.ValueType} value
 * @return {!proto.yorkie.v1.JSONElementSimple} returns this
 */
proto.yorkie.v1.JSONElementSimple.prototype.setType = function(value) {
  return jspb.Message.setProto3EnumField(this, 4, value);
};


/**
 * optional bytes value = 5;
 * @return {string}
 */
proto.yorkie.v1.JSONElementSimple.prototype.getValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes value = 5;
 * This is a type-conversion wrapper around `getValue()`
 * @return {string}
 */
proto.yorkie.v1.JSONElementSimple.prototype.getValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getValue()));
};


/**
 * optional bytes value = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValue()`
 * @return {!Uint8Array}
 */
proto.yorkie.v1.JSONElementSimple.prototype.getValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getValue()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.yorkie.v1.JSONElementSimple} returns this
 */
proto.yorkie.v1.JSONElementSimple.prototype.setValue = function(value) {
  return jspb.Message.setProto3BytesField(this, 5, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.yorkie.v1.JSONElement.oneofGroups_ = [[1,2,3,5,6,7]];

/**
 * @enum {number}
 */
proto.yorkie.v1.JSONElement.BodyCase = {
  BODY_NOT_SET: 0,
  JSON_OBJECT: 1,
  JSON_ARRAY: 2,
  PRIMITIVE: 3,
  TEXT: 5,
  COUNTER: 6,
  TREE: 7
};

/**
 * @return {proto.yorkie.v1.JSONElement.BodyCase}
 */
proto.yorkie.v1.JSONElement.prototype.getBodyCase = function() {
  return /** @type {proto.yorkie.v1.JSONElement.BodyCase} */(jspb.Message.computeOneofCase(this, proto.yorkie.v1.JSONElement.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.JSONElement.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.JSONElement.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.JSONElement} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.JSONElement.toObject = function(includeInstance, msg) {
  var f, obj = {
    jsonObject: (f = msg.getJsonObject()) && proto.yorkie.v1.JSONElement.JSONObject.toObject(includeInstance, f),
    jsonArray: (f = msg.getJsonArray()) && proto.yorkie.v1.JSONElement.JSONArray.toObject(includeInstance, f),
    primitive: (f = msg.getPrimitive()) && proto.yorkie.v1.JSONElement.Primitive.toObject(includeInstance, f),
    text: (f = msg.getText()) && proto.yorkie.v1.JSONElement.Text.toObject(includeInstance, f),
    counter: (f = msg.getCounter()) && proto.yorkie.v1.JSONElement.Counter.toObject(includeInstance, f),
    tree: (f = msg.getTree()) && proto.yorkie.v1.JSONElement.Tree.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.JSONElement}
 */
proto.yorkie.v1.JSONElement.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.JSONElement;
  return proto.yorkie.v1.JSONElement.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.JSONElement} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.JSONElement}
 */
proto.yorkie.v1.JSONElement.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.JSONElement.JSONObject;
      reader.readMessage(value,proto.yorkie.v1.JSONElement.JSONObject.deserializeBinaryFromReader);
      msg.setJsonObject(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.JSONElement.JSONArray;
      reader.readMessage(value,proto.yorkie.v1.JSONElement.JSONArray.deserializeBinaryFromReader);
      msg.setJsonArray(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.JSONElement.Primitive;
      reader.readMessage(value,proto.yorkie.v1.JSONElement.Primitive.deserializeBinaryFromReader);
      msg.setPrimitive(value);
      break;
    case 5:
      var value = new proto.yorkie.v1.JSONElement.Text;
      reader.readMessage(value,proto.yorkie.v1.JSONElement.Text.deserializeBinaryFromReader);
      msg.setText(value);
      break;
    case 6:
      var value = new proto.yorkie.v1.JSONElement.Counter;
      reader.readMessage(value,proto.yorkie.v1.JSONElement.Counter.deserializeBinaryFromReader);
      msg.setCounter(value);
      break;
    case 7:
      var value = new proto.yorkie.v1.JSONElement.Tree;
      reader.readMessage(value,proto.yorkie.v1.JSONElement.Tree.deserializeBinaryFromReader);
      msg.setTree(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.JSONElement.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.JSONElement.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.JSONElement} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.JSONElement.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getJsonObject();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.JSONElement.JSONObject.serializeBinaryToWriter
    );
  }
  f = message.getJsonArray();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.JSONElement.JSONArray.serializeBinaryToWriter
    );
  }
  f = message.getPrimitive();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.JSONElement.Primitive.serializeBinaryToWriter
    );
  }
  f = message.getText();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.yorkie.v1.JSONElement.Text.serializeBinaryToWriter
    );
  }
  f = message.getCounter();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.yorkie.v1.JSONElement.Counter.serializeBinaryToWriter
    );
  }
  f = message.getTree();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.yorkie.v1.JSONElement.Tree.serializeBinaryToWriter
    );
  }
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.yorkie.v1.JSONElement.JSONObject.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.JSONElement.JSONObject.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.JSONElement.JSONObject.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.JSONElement.JSONObject} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.JSONElement.JSONObject.toObject = function(includeInstance, msg) {
  var f, obj = {
    nodesList: jspb.Message.toObjectList(msg.getNodesList(),
    proto.yorkie.v1.RHTNode.toObject, includeInstance),
    createdAt: (f = msg.getCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    movedAt: (f = msg.getMovedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    removedAt: (f = msg.getRemovedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.JSONElement.JSONObject}
 */
proto.yorkie.v1.JSONElement.JSONObject.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.JSONElement.JSONObject;
  return proto.yorkie.v1.JSONElement.JSONObject.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.JSONElement.JSONObject} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.JSONElement.JSONObject}
 */
proto.yorkie.v1.JSONElement.JSONObject.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.RHTNode;
      reader.readMessage(value,proto.yorkie.v1.RHTNode.deserializeBinaryFromReader);
      msg.addNodes(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setCreatedAt(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setMovedAt(value);
      break;
    case 4:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setRemovedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.JSONElement.JSONObject.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.JSONElement.JSONObject.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.JSONElement.JSONObject} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.JSONElement.JSONObject.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNodesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.yorkie.v1.RHTNode.serializeBinaryToWriter
    );
  }
  f = message.getCreatedAt();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getMovedAt();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getRemovedAt();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
};


/**
 * repeated RHTNode nodes = 1;
 * @return {!Array<!proto.yorkie.v1.RHTNode>}
 */
proto.yorkie.v1.JSONElement.JSONObject.prototype.getNodesList = function() {
  return /** @type{!Array<!proto.yorkie.v1.RHTNode>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.yorkie.v1.RHTNode, 1));
};


/**
 * @param {!Array<!proto.yorkie.v1.RHTNode>} value
 * @return {!proto.yorkie.v1.JSONElement.JSONObject} returns this
*/
proto.yorkie.v1.JSONElement.JSONObject.prototype.setNodesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.yorkie.v1.RHTNode=} opt_value
 * @param {number=} opt_index
 * @return {!proto.yorkie.v1.RHTNode}
 */
proto.yorkie.v1.JSONElement.JSONObject.prototype.addNodes = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.yorkie.v1.RHTNode, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.yorkie.v1.JSONElement.JSONObject} returns this
 */
proto.yorkie.v1.JSONElement.JSONObject.prototype.clearNodesList = function() {
  return this.setNodesList([]);
};


/**
 * optional TimeTicket created_at = 2;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.JSONObject.prototype.getCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 2));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.JSONObject} returns this
*/
proto.yorkie.v1.JSONElement.JSONObject.prototype.setCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.JSONObject} returns this
 */
proto.yorkie.v1.JSONElement.JSONObject.prototype.clearCreatedAt = function() {
  return this.setCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.JSONObject.prototype.hasCreatedAt = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TimeTicket moved_at = 3;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.JSONObject.prototype.getMovedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 3));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.JSONObject} returns this
*/
proto.yorkie.v1.JSONElement.JSONObject.prototype.setMovedAt = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.JSONObject} returns this
 */
proto.yorkie.v1.JSONElement.JSONObject.prototype.clearMovedAt = function() {
  return this.setMovedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.JSONObject.prototype.hasMovedAt = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional TimeTicket removed_at = 4;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.JSONObject.prototype.getRemovedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 4));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.JSONObject} returns this
*/
proto.yorkie.v1.JSONElement.JSONObject.prototype.setRemovedAt = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.JSONObject} returns this
 */
proto.yorkie.v1.JSONElement.JSONObject.prototype.clearRemovedAt = function() {
  return this.setRemovedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.JSONObject.prototype.hasRemovedAt = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.yorkie.v1.JSONElement.JSONArray.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.JSONElement.JSONArray.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.JSONElement.JSONArray.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.JSONElement.JSONArray} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.JSONElement.JSONArray.toObject = function(includeInstance, msg) {
  var f, obj = {
    nodesList: jspb.Message.toObjectList(msg.getNodesList(),
    proto.yorkie.v1.RGANode.toObject, includeInstance),
    createdAt: (f = msg.getCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    movedAt: (f = msg.getMovedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    removedAt: (f = msg.getRemovedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.JSONElement.JSONArray}
 */
proto.yorkie.v1.JSONElement.JSONArray.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.JSONElement.JSONArray;
  return proto.yorkie.v1.JSONElement.JSONArray.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.JSONElement.JSONArray} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.JSONElement.JSONArray}
 */
proto.yorkie.v1.JSONElement.JSONArray.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.RGANode;
      reader.readMessage(value,proto.yorkie.v1.RGANode.deserializeBinaryFromReader);
      msg.addNodes(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setCreatedAt(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setMovedAt(value);
      break;
    case 4:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setRemovedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.JSONElement.JSONArray.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.JSONElement.JSONArray.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.JSONElement.JSONArray} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.JSONElement.JSONArray.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNodesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.yorkie.v1.RGANode.serializeBinaryToWriter
    );
  }
  f = message.getCreatedAt();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getMovedAt();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getRemovedAt();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
};


/**
 * repeated RGANode nodes = 1;
 * @return {!Array<!proto.yorkie.v1.RGANode>}
 */
proto.yorkie.v1.JSONElement.JSONArray.prototype.getNodesList = function() {
  return /** @type{!Array<!proto.yorkie.v1.RGANode>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.yorkie.v1.RGANode, 1));
};


/**
 * @param {!Array<!proto.yorkie.v1.RGANode>} value
 * @return {!proto.yorkie.v1.JSONElement.JSONArray} returns this
*/
proto.yorkie.v1.JSONElement.JSONArray.prototype.setNodesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.yorkie.v1.RGANode=} opt_value
 * @param {number=} opt_index
 * @return {!proto.yorkie.v1.RGANode}
 */
proto.yorkie.v1.JSONElement.JSONArray.prototype.addNodes = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.yorkie.v1.RGANode, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.yorkie.v1.JSONElement.JSONArray} returns this
 */
proto.yorkie.v1.JSONElement.JSONArray.prototype.clearNodesList = function() {
  return this.setNodesList([]);
};


/**
 * optional TimeTicket created_at = 2;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.JSONArray.prototype.getCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 2));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.JSONArray} returns this
*/
proto.yorkie.v1.JSONElement.JSONArray.prototype.setCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.JSONArray} returns this
 */
proto.yorkie.v1.JSONElement.JSONArray.prototype.clearCreatedAt = function() {
  return this.setCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.JSONArray.prototype.hasCreatedAt = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TimeTicket moved_at = 3;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.JSONArray.prototype.getMovedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 3));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.JSONArray} returns this
*/
proto.yorkie.v1.JSONElement.JSONArray.prototype.setMovedAt = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.JSONArray} returns this
 */
proto.yorkie.v1.JSONElement.JSONArray.prototype.clearMovedAt = function() {
  return this.setMovedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.JSONArray.prototype.hasMovedAt = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional TimeTicket removed_at = 4;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.JSONArray.prototype.getRemovedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 4));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.JSONArray} returns this
*/
proto.yorkie.v1.JSONElement.JSONArray.prototype.setRemovedAt = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.JSONArray} returns this
 */
proto.yorkie.v1.JSONElement.JSONArray.prototype.clearRemovedAt = function() {
  return this.setRemovedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.JSONArray.prototype.hasRemovedAt = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.JSONElement.Primitive.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.JSONElement.Primitive} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.JSONElement.Primitive.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getFieldWithDefault(msg, 1, 0),
    value: msg.getValue_asB64(),
    createdAt: (f = msg.getCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    movedAt: (f = msg.getMovedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    removedAt: (f = msg.getRemovedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.JSONElement.Primitive}
 */
proto.yorkie.v1.JSONElement.Primitive.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.JSONElement.Primitive;
  return proto.yorkie.v1.JSONElement.Primitive.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.JSONElement.Primitive} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.JSONElement.Primitive}
 */
proto.yorkie.v1.JSONElement.Primitive.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.yorkie.v1.ValueType} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setValue(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setCreatedAt(value);
      break;
    case 4:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setMovedAt(value);
      break;
    case 5:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setRemovedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.JSONElement.Primitive.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.JSONElement.Primitive} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.JSONElement.Primitive.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getValue_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getCreatedAt();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getMovedAt();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getRemovedAt();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
};


/**
 * optional ValueType type = 1;
 * @return {!proto.yorkie.v1.ValueType}
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.getType = function() {
  return /** @type {!proto.yorkie.v1.ValueType} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.yorkie.v1.ValueType} value
 * @return {!proto.yorkie.v1.JSONElement.Primitive} returns this
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.setType = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional bytes value = 2;
 * @return {string}
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.getValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes value = 2;
 * This is a type-conversion wrapper around `getValue()`
 * @return {string}
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.getValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getValue()));
};


/**
 * optional bytes value = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValue()`
 * @return {!Uint8Array}
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.getValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getValue()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.yorkie.v1.JSONElement.Primitive} returns this
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.setValue = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional TimeTicket created_at = 3;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.getCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 3));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.Primitive} returns this
*/
proto.yorkie.v1.JSONElement.Primitive.prototype.setCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.Primitive} returns this
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.clearCreatedAt = function() {
  return this.setCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.hasCreatedAt = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional TimeTicket moved_at = 4;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.getMovedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 4));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.Primitive} returns this
*/
proto.yorkie.v1.JSONElement.Primitive.prototype.setMovedAt = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.Primitive} returns this
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.clearMovedAt = function() {
  return this.setMovedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.hasMovedAt = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional TimeTicket removed_at = 5;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.getRemovedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 5));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.Primitive} returns this
*/
proto.yorkie.v1.JSONElement.Primitive.prototype.setRemovedAt = function(value) {
  return jspb.Message.setWrapperField(this, 5, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.Primitive} returns this
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.clearRemovedAt = function() {
  return this.setRemovedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.Primitive.prototype.hasRemovedAt = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.yorkie.v1.JSONElement.Text.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.JSONElement.Text.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.JSONElement.Text.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.JSONElement.Text} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.JSONElement.Text.toObject = function(includeInstance, msg) {
  var f, obj = {
    nodesList: jspb.Message.toObjectList(msg.getNodesList(),
    proto.yorkie.v1.TextNode.toObject, includeInstance),
    createdAt: (f = msg.getCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    movedAt: (f = msg.getMovedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    removedAt: (f = msg.getRemovedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.JSONElement.Text}
 */
proto.yorkie.v1.JSONElement.Text.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.JSONElement.Text;
  return proto.yorkie.v1.JSONElement.Text.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.JSONElement.Text} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.JSONElement.Text}
 */
proto.yorkie.v1.JSONElement.Text.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TextNode;
      reader.readMessage(value,proto.yorkie.v1.TextNode.deserializeBinaryFromReader);
      msg.addNodes(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setCreatedAt(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setMovedAt(value);
      break;
    case 4:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setRemovedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.JSONElement.Text.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.JSONElement.Text.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.JSONElement.Text} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.JSONElement.Text.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNodesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.yorkie.v1.TextNode.serializeBinaryToWriter
    );
  }
  f = message.getCreatedAt();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getMovedAt();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getRemovedAt();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
};


/**
 * repeated TextNode nodes = 1;
 * @return {!Array<!proto.yorkie.v1.TextNode>}
 */
proto.yorkie.v1.JSONElement.Text.prototype.getNodesList = function() {
  return /** @type{!Array<!proto.yorkie.v1.TextNode>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.yorkie.v1.TextNode, 1));
};


/**
 * @param {!Array<!proto.yorkie.v1.TextNode>} value
 * @return {!proto.yorkie.v1.JSONElement.Text} returns this
*/
proto.yorkie.v1.JSONElement.Text.prototype.setNodesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.yorkie.v1.TextNode=} opt_value
 * @param {number=} opt_index
 * @return {!proto.yorkie.v1.TextNode}
 */
proto.yorkie.v1.JSONElement.Text.prototype.addNodes = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.yorkie.v1.TextNode, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.yorkie.v1.JSONElement.Text} returns this
 */
proto.yorkie.v1.JSONElement.Text.prototype.clearNodesList = function() {
  return this.setNodesList([]);
};


/**
 * optional TimeTicket created_at = 2;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.Text.prototype.getCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 2));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.Text} returns this
*/
proto.yorkie.v1.JSONElement.Text.prototype.setCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.Text} returns this
 */
proto.yorkie.v1.JSONElement.Text.prototype.clearCreatedAt = function() {
  return this.setCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.Text.prototype.hasCreatedAt = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TimeTicket moved_at = 3;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.Text.prototype.getMovedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 3));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.Text} returns this
*/
proto.yorkie.v1.JSONElement.Text.prototype.setMovedAt = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.Text} returns this
 */
proto.yorkie.v1.JSONElement.Text.prototype.clearMovedAt = function() {
  return this.setMovedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.Text.prototype.hasMovedAt = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional TimeTicket removed_at = 4;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.Text.prototype.getRemovedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 4));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.Text} returns this
*/
proto.yorkie.v1.JSONElement.Text.prototype.setRemovedAt = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.Text} returns this
 */
proto.yorkie.v1.JSONElement.Text.prototype.clearRemovedAt = function() {
  return this.setRemovedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.Text.prototype.hasRemovedAt = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.JSONElement.Counter.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.JSONElement.Counter.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.JSONElement.Counter} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.JSONElement.Counter.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getFieldWithDefault(msg, 1, 0),
    value: msg.getValue_asB64(),
    createdAt: (f = msg.getCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    movedAt: (f = msg.getMovedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    removedAt: (f = msg.getRemovedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.JSONElement.Counter}
 */
proto.yorkie.v1.JSONElement.Counter.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.JSONElement.Counter;
  return proto.yorkie.v1.JSONElement.Counter.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.JSONElement.Counter} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.JSONElement.Counter}
 */
proto.yorkie.v1.JSONElement.Counter.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.yorkie.v1.ValueType} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setValue(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setCreatedAt(value);
      break;
    case 4:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setMovedAt(value);
      break;
    case 5:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setRemovedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.JSONElement.Counter.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.JSONElement.Counter.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.JSONElement.Counter} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.JSONElement.Counter.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getValue_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getCreatedAt();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getMovedAt();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getRemovedAt();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
};


/**
 * optional ValueType type = 1;
 * @return {!proto.yorkie.v1.ValueType}
 */
proto.yorkie.v1.JSONElement.Counter.prototype.getType = function() {
  return /** @type {!proto.yorkie.v1.ValueType} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.yorkie.v1.ValueType} value
 * @return {!proto.yorkie.v1.JSONElement.Counter} returns this
 */
proto.yorkie.v1.JSONElement.Counter.prototype.setType = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional bytes value = 2;
 * @return {string}
 */
proto.yorkie.v1.JSONElement.Counter.prototype.getValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes value = 2;
 * This is a type-conversion wrapper around `getValue()`
 * @return {string}
 */
proto.yorkie.v1.JSONElement.Counter.prototype.getValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getValue()));
};


/**
 * optional bytes value = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValue()`
 * @return {!Uint8Array}
 */
proto.yorkie.v1.JSONElement.Counter.prototype.getValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getValue()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.yorkie.v1.JSONElement.Counter} returns this
 */
proto.yorkie.v1.JSONElement.Counter.prototype.setValue = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional TimeTicket created_at = 3;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.Counter.prototype.getCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 3));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.Counter} returns this
*/
proto.yorkie.v1.JSONElement.Counter.prototype.setCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.Counter} returns this
 */
proto.yorkie.v1.JSONElement.Counter.prototype.clearCreatedAt = function() {
  return this.setCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.Counter.prototype.hasCreatedAt = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional TimeTicket moved_at = 4;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.Counter.prototype.getMovedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 4));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.Counter} returns this
*/
proto.yorkie.v1.JSONElement.Counter.prototype.setMovedAt = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.Counter} returns this
 */
proto.yorkie.v1.JSONElement.Counter.prototype.clearMovedAt = function() {
  return this.setMovedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.Counter.prototype.hasMovedAt = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional TimeTicket removed_at = 5;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.Counter.prototype.getRemovedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 5));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.Counter} returns this
*/
proto.yorkie.v1.JSONElement.Counter.prototype.setRemovedAt = function(value) {
  return jspb.Message.setWrapperField(this, 5, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.Counter} returns this
 */
proto.yorkie.v1.JSONElement.Counter.prototype.clearRemovedAt = function() {
  return this.setRemovedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.Counter.prototype.hasRemovedAt = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.yorkie.v1.JSONElement.Tree.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.JSONElement.Tree.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.JSONElement.Tree.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.JSONElement.Tree} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.JSONElement.Tree.toObject = function(includeInstance, msg) {
  var f, obj = {
    nodesList: jspb.Message.toObjectList(msg.getNodesList(),
    proto.yorkie.v1.TreeNode.toObject, includeInstance),
    createdAt: (f = msg.getCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    movedAt: (f = msg.getMovedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    removedAt: (f = msg.getRemovedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.JSONElement.Tree}
 */
proto.yorkie.v1.JSONElement.Tree.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.JSONElement.Tree;
  return proto.yorkie.v1.JSONElement.Tree.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.JSONElement.Tree} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.JSONElement.Tree}
 */
proto.yorkie.v1.JSONElement.Tree.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TreeNode;
      reader.readMessage(value,proto.yorkie.v1.TreeNode.deserializeBinaryFromReader);
      msg.addNodes(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setCreatedAt(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setMovedAt(value);
      break;
    case 4:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setRemovedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.JSONElement.Tree.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.JSONElement.Tree.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.JSONElement.Tree} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.JSONElement.Tree.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNodesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.yorkie.v1.TreeNode.serializeBinaryToWriter
    );
  }
  f = message.getCreatedAt();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getMovedAt();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getRemovedAt();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
};


/**
 * repeated TreeNode nodes = 1;
 * @return {!Array<!proto.yorkie.v1.TreeNode>}
 */
proto.yorkie.v1.JSONElement.Tree.prototype.getNodesList = function() {
  return /** @type{!Array<!proto.yorkie.v1.TreeNode>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.yorkie.v1.TreeNode, 1));
};


/**
 * @param {!Array<!proto.yorkie.v1.TreeNode>} value
 * @return {!proto.yorkie.v1.JSONElement.Tree} returns this
*/
proto.yorkie.v1.JSONElement.Tree.prototype.setNodesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.yorkie.v1.TreeNode=} opt_value
 * @param {number=} opt_index
 * @return {!proto.yorkie.v1.TreeNode}
 */
proto.yorkie.v1.JSONElement.Tree.prototype.addNodes = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.yorkie.v1.TreeNode, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.yorkie.v1.JSONElement.Tree} returns this
 */
proto.yorkie.v1.JSONElement.Tree.prototype.clearNodesList = function() {
  return this.setNodesList([]);
};


/**
 * optional TimeTicket created_at = 2;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.Tree.prototype.getCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 2));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.Tree} returns this
*/
proto.yorkie.v1.JSONElement.Tree.prototype.setCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.Tree} returns this
 */
proto.yorkie.v1.JSONElement.Tree.prototype.clearCreatedAt = function() {
  return this.setCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.Tree.prototype.hasCreatedAt = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TimeTicket moved_at = 3;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.Tree.prototype.getMovedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 3));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.Tree} returns this
*/
proto.yorkie.v1.JSONElement.Tree.prototype.setMovedAt = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.Tree} returns this
 */
proto.yorkie.v1.JSONElement.Tree.prototype.clearMovedAt = function() {
  return this.setMovedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.Tree.prototype.hasMovedAt = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional TimeTicket removed_at = 4;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.JSONElement.Tree.prototype.getRemovedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 4));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.JSONElement.Tree} returns this
*/
proto.yorkie.v1.JSONElement.Tree.prototype.setRemovedAt = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement.Tree} returns this
 */
proto.yorkie.v1.JSONElement.Tree.prototype.clearRemovedAt = function() {
  return this.setRemovedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.Tree.prototype.hasRemovedAt = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional JSONObject json_object = 1;
 * @return {?proto.yorkie.v1.JSONElement.JSONObject}
 */
proto.yorkie.v1.JSONElement.prototype.getJsonObject = function() {
  return /** @type{?proto.yorkie.v1.JSONElement.JSONObject} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.JSONElement.JSONObject, 1));
};


/**
 * @param {?proto.yorkie.v1.JSONElement.JSONObject|undefined} value
 * @return {!proto.yorkie.v1.JSONElement} returns this
*/
proto.yorkie.v1.JSONElement.prototype.setJsonObject = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.yorkie.v1.JSONElement.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement} returns this
 */
proto.yorkie.v1.JSONElement.prototype.clearJsonObject = function() {
  return this.setJsonObject(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.prototype.hasJsonObject = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional JSONArray json_array = 2;
 * @return {?proto.yorkie.v1.JSONElement.JSONArray}
 */
proto.yorkie.v1.JSONElement.prototype.getJsonArray = function() {
  return /** @type{?proto.yorkie.v1.JSONElement.JSONArray} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.JSONElement.JSONArray, 2));
};


/**
 * @param {?proto.yorkie.v1.JSONElement.JSONArray|undefined} value
 * @return {!proto.yorkie.v1.JSONElement} returns this
*/
proto.yorkie.v1.JSONElement.prototype.setJsonArray = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.yorkie.v1.JSONElement.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement} returns this
 */
proto.yorkie.v1.JSONElement.prototype.clearJsonArray = function() {
  return this.setJsonArray(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.prototype.hasJsonArray = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Primitive primitive = 3;
 * @return {?proto.yorkie.v1.JSONElement.Primitive}
 */
proto.yorkie.v1.JSONElement.prototype.getPrimitive = function() {
  return /** @type{?proto.yorkie.v1.JSONElement.Primitive} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.JSONElement.Primitive, 3));
};


/**
 * @param {?proto.yorkie.v1.JSONElement.Primitive|undefined} value
 * @return {!proto.yorkie.v1.JSONElement} returns this
*/
proto.yorkie.v1.JSONElement.prototype.setPrimitive = function(value) {
  return jspb.Message.setOneofWrapperField(this, 3, proto.yorkie.v1.JSONElement.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement} returns this
 */
proto.yorkie.v1.JSONElement.prototype.clearPrimitive = function() {
  return this.setPrimitive(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.prototype.hasPrimitive = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional Text text = 5;
 * @return {?proto.yorkie.v1.JSONElement.Text}
 */
proto.yorkie.v1.JSONElement.prototype.getText = function() {
  return /** @type{?proto.yorkie.v1.JSONElement.Text} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.JSONElement.Text, 5));
};


/**
 * @param {?proto.yorkie.v1.JSONElement.Text|undefined} value
 * @return {!proto.yorkie.v1.JSONElement} returns this
*/
proto.yorkie.v1.JSONElement.prototype.setText = function(value) {
  return jspb.Message.setOneofWrapperField(this, 5, proto.yorkie.v1.JSONElement.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement} returns this
 */
proto.yorkie.v1.JSONElement.prototype.clearText = function() {
  return this.setText(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.prototype.hasText = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional Counter counter = 6;
 * @return {?proto.yorkie.v1.JSONElement.Counter}
 */
proto.yorkie.v1.JSONElement.prototype.getCounter = function() {
  return /** @type{?proto.yorkie.v1.JSONElement.Counter} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.JSONElement.Counter, 6));
};


/**
 * @param {?proto.yorkie.v1.JSONElement.Counter|undefined} value
 * @return {!proto.yorkie.v1.JSONElement} returns this
*/
proto.yorkie.v1.JSONElement.prototype.setCounter = function(value) {
  return jspb.Message.setOneofWrapperField(this, 6, proto.yorkie.v1.JSONElement.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement} returns this
 */
proto.yorkie.v1.JSONElement.prototype.clearCounter = function() {
  return this.setCounter(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.prototype.hasCounter = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional Tree tree = 7;
 * @return {?proto.yorkie.v1.JSONElement.Tree}
 */
proto.yorkie.v1.JSONElement.prototype.getTree = function() {
  return /** @type{?proto.yorkie.v1.JSONElement.Tree} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.JSONElement.Tree, 7));
};


/**
 * @param {?proto.yorkie.v1.JSONElement.Tree|undefined} value
 * @return {!proto.yorkie.v1.JSONElement} returns this
*/
proto.yorkie.v1.JSONElement.prototype.setTree = function(value) {
  return jspb.Message.setOneofWrapperField(this, 7, proto.yorkie.v1.JSONElement.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.JSONElement} returns this
 */
proto.yorkie.v1.JSONElement.prototype.clearTree = function() {
  return this.setTree(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.JSONElement.prototype.hasTree = function() {
  return jspb.Message.getField(this, 7) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.RHTNode.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.RHTNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.RHTNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.RHTNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    key: jspb.Message.getFieldWithDefault(msg, 1, ""),
    element: (f = msg.getElement()) && proto.yorkie.v1.JSONElement.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.RHTNode}
 */
proto.yorkie.v1.RHTNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.RHTNode;
  return proto.yorkie.v1.RHTNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.RHTNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.RHTNode}
 */
proto.yorkie.v1.RHTNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setKey(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.JSONElement;
      reader.readMessage(value,proto.yorkie.v1.JSONElement.deserializeBinaryFromReader);
      msg.setElement(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.RHTNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.RHTNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.RHTNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.RHTNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getKey();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getElement();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.JSONElement.serializeBinaryToWriter
    );
  }
};


/**
 * optional string key = 1;
 * @return {string}
 */
proto.yorkie.v1.RHTNode.prototype.getKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.RHTNode} returns this
 */
proto.yorkie.v1.RHTNode.prototype.setKey = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional JSONElement element = 2;
 * @return {?proto.yorkie.v1.JSONElement}
 */
proto.yorkie.v1.RHTNode.prototype.getElement = function() {
  return /** @type{?proto.yorkie.v1.JSONElement} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.JSONElement, 2));
};


/**
 * @param {?proto.yorkie.v1.JSONElement|undefined} value
 * @return {!proto.yorkie.v1.RHTNode} returns this
*/
proto.yorkie.v1.RHTNode.prototype.setElement = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.RHTNode} returns this
 */
proto.yorkie.v1.RHTNode.prototype.clearElement = function() {
  return this.setElement(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.RHTNode.prototype.hasElement = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.RGANode.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.RGANode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.RGANode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.RGANode.toObject = function(includeInstance, msg) {
  var f, obj = {
    next: (f = msg.getNext()) && proto.yorkie.v1.RGANode.toObject(includeInstance, f),
    element: (f = msg.getElement()) && proto.yorkie.v1.JSONElement.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.RGANode}
 */
proto.yorkie.v1.RGANode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.RGANode;
  return proto.yorkie.v1.RGANode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.RGANode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.RGANode}
 */
proto.yorkie.v1.RGANode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.RGANode;
      reader.readMessage(value,proto.yorkie.v1.RGANode.deserializeBinaryFromReader);
      msg.setNext(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.JSONElement;
      reader.readMessage(value,proto.yorkie.v1.JSONElement.deserializeBinaryFromReader);
      msg.setElement(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.RGANode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.RGANode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.RGANode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.RGANode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNext();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.RGANode.serializeBinaryToWriter
    );
  }
  f = message.getElement();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.JSONElement.serializeBinaryToWriter
    );
  }
};


/**
 * optional RGANode next = 1;
 * @return {?proto.yorkie.v1.RGANode}
 */
proto.yorkie.v1.RGANode.prototype.getNext = function() {
  return /** @type{?proto.yorkie.v1.RGANode} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.RGANode, 1));
};


/**
 * @param {?proto.yorkie.v1.RGANode|undefined} value
 * @return {!proto.yorkie.v1.RGANode} returns this
*/
proto.yorkie.v1.RGANode.prototype.setNext = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.RGANode} returns this
 */
proto.yorkie.v1.RGANode.prototype.clearNext = function() {
  return this.setNext(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.RGANode.prototype.hasNext = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional JSONElement element = 2;
 * @return {?proto.yorkie.v1.JSONElement}
 */
proto.yorkie.v1.RGANode.prototype.getElement = function() {
  return /** @type{?proto.yorkie.v1.JSONElement} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.JSONElement, 2));
};


/**
 * @param {?proto.yorkie.v1.JSONElement|undefined} value
 * @return {!proto.yorkie.v1.RGANode} returns this
*/
proto.yorkie.v1.RGANode.prototype.setElement = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.RGANode} returns this
 */
proto.yorkie.v1.RGANode.prototype.clearElement = function() {
  return this.setElement(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.RGANode.prototype.hasElement = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.NodeAttr.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.NodeAttr.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.NodeAttr} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.NodeAttr.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, ""),
    updatedAt: (f = msg.getUpdatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.NodeAttr}
 */
proto.yorkie.v1.NodeAttr.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.NodeAttr;
  return proto.yorkie.v1.NodeAttr.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.NodeAttr} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.NodeAttr}
 */
proto.yorkie.v1.NodeAttr.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setValue(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setUpdatedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.NodeAttr.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.NodeAttr.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.NodeAttr} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.NodeAttr.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getUpdatedAt();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
};


/**
 * optional string value = 1;
 * @return {string}
 */
proto.yorkie.v1.NodeAttr.prototype.getValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.NodeAttr} returns this
 */
proto.yorkie.v1.NodeAttr.prototype.setValue = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional TimeTicket updated_at = 2;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.NodeAttr.prototype.getUpdatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 2));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.NodeAttr} returns this
*/
proto.yorkie.v1.NodeAttr.prototype.setUpdatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.NodeAttr} returns this
 */
proto.yorkie.v1.NodeAttr.prototype.clearUpdatedAt = function() {
  return this.setUpdatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.NodeAttr.prototype.hasUpdatedAt = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.TextNode.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.TextNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.TextNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.TextNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: (f = msg.getId()) && proto.yorkie.v1.TextNodeID.toObject(includeInstance, f),
    value: jspb.Message.getFieldWithDefault(msg, 2, ""),
    removedAt: (f = msg.getRemovedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    insPrevId: (f = msg.getInsPrevId()) && proto.yorkie.v1.TextNodeID.toObject(includeInstance, f),
    attributesMap: (f = msg.getAttributesMap()) ? f.toObject(includeInstance, proto.yorkie.v1.NodeAttr.toObject) : []
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.TextNode}
 */
proto.yorkie.v1.TextNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.TextNode;
  return proto.yorkie.v1.TextNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.TextNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.TextNode}
 */
proto.yorkie.v1.TextNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TextNodeID;
      reader.readMessage(value,proto.yorkie.v1.TextNodeID.deserializeBinaryFromReader);
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setValue(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setRemovedAt(value);
      break;
    case 4:
      var value = new proto.yorkie.v1.TextNodeID;
      reader.readMessage(value,proto.yorkie.v1.TextNodeID.deserializeBinaryFromReader);
      msg.setInsPrevId(value);
      break;
    case 5:
      var value = msg.getAttributesMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, proto.yorkie.v1.NodeAttr.deserializeBinaryFromReader, "", new proto.yorkie.v1.NodeAttr());
         });
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.TextNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.TextNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.TextNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.TextNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TextNodeID.serializeBinaryToWriter
    );
  }
  f = message.getValue();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getRemovedAt();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getInsPrevId();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.yorkie.v1.TextNodeID.serializeBinaryToWriter
    );
  }
  f = message.getAttributesMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(5, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, proto.yorkie.v1.NodeAttr.serializeBinaryToWriter);
  }
};


/**
 * optional TextNodeID id = 1;
 * @return {?proto.yorkie.v1.TextNodeID}
 */
proto.yorkie.v1.TextNode.prototype.getId = function() {
  return /** @type{?proto.yorkie.v1.TextNodeID} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TextNodeID, 1));
};


/**
 * @param {?proto.yorkie.v1.TextNodeID|undefined} value
 * @return {!proto.yorkie.v1.TextNode} returns this
*/
proto.yorkie.v1.TextNode.prototype.setId = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.TextNode} returns this
 */
proto.yorkie.v1.TextNode.prototype.clearId = function() {
  return this.setId(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.TextNode.prototype.hasId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string value = 2;
 * @return {string}
 */
proto.yorkie.v1.TextNode.prototype.getValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.TextNode} returns this
 */
proto.yorkie.v1.TextNode.prototype.setValue = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional TimeTicket removed_at = 3;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.TextNode.prototype.getRemovedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 3));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.TextNode} returns this
*/
proto.yorkie.v1.TextNode.prototype.setRemovedAt = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.TextNode} returns this
 */
proto.yorkie.v1.TextNode.prototype.clearRemovedAt = function() {
  return this.setRemovedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.TextNode.prototype.hasRemovedAt = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional TextNodeID ins_prev_id = 4;
 * @return {?proto.yorkie.v1.TextNodeID}
 */
proto.yorkie.v1.TextNode.prototype.getInsPrevId = function() {
  return /** @type{?proto.yorkie.v1.TextNodeID} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TextNodeID, 4));
};


/**
 * @param {?proto.yorkie.v1.TextNodeID|undefined} value
 * @return {!proto.yorkie.v1.TextNode} returns this
*/
proto.yorkie.v1.TextNode.prototype.setInsPrevId = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.TextNode} returns this
 */
proto.yorkie.v1.TextNode.prototype.clearInsPrevId = function() {
  return this.setInsPrevId(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.TextNode.prototype.hasInsPrevId = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * map<string, NodeAttr> attributes = 5;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.yorkie.v1.NodeAttr>}
 */
proto.yorkie.v1.TextNode.prototype.getAttributesMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,!proto.yorkie.v1.NodeAttr>} */ (
      jspb.Message.getMapField(this, 5, opt_noLazyCreate,
      proto.yorkie.v1.NodeAttr));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.yorkie.v1.TextNode} returns this
 */
proto.yorkie.v1.TextNode.prototype.clearAttributesMap = function() {
  this.getAttributesMap().clear();
  return this;};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.TextNodeID.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.TextNodeID.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.TextNodeID} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.TextNodeID.toObject = function(includeInstance, msg) {
  var f, obj = {
    createdAt: (f = msg.getCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    offset: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.TextNodeID}
 */
proto.yorkie.v1.TextNodeID.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.TextNodeID;
  return proto.yorkie.v1.TextNodeID.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.TextNodeID} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.TextNodeID}
 */
proto.yorkie.v1.TextNodeID.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setCreatedAt(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setOffset(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.TextNodeID.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.TextNodeID.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.TextNodeID} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.TextNodeID.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCreatedAt();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getOffset();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * optional TimeTicket created_at = 1;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.TextNodeID.prototype.getCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 1));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.TextNodeID} returns this
*/
proto.yorkie.v1.TextNodeID.prototype.setCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.TextNodeID} returns this
 */
proto.yorkie.v1.TextNodeID.prototype.clearCreatedAt = function() {
  return this.setCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.TextNodeID.prototype.hasCreatedAt = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int32 offset = 2;
 * @return {number}
 */
proto.yorkie.v1.TextNodeID.prototype.getOffset = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.yorkie.v1.TextNodeID} returns this
 */
proto.yorkie.v1.TextNodeID.prototype.setOffset = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.TreeNode.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.TreeNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.TreeNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.TreeNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: (f = msg.getId()) && proto.yorkie.v1.TreeNodeID.toObject(includeInstance, f),
    type: jspb.Message.getFieldWithDefault(msg, 2, ""),
    value: jspb.Message.getFieldWithDefault(msg, 3, ""),
    removedAt: (f = msg.getRemovedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    insPrevId: (f = msg.getInsPrevId()) && proto.yorkie.v1.TreeNodeID.toObject(includeInstance, f),
    insNextId: (f = msg.getInsNextId()) && proto.yorkie.v1.TreeNodeID.toObject(includeInstance, f),
    depth: jspb.Message.getFieldWithDefault(msg, 7, 0),
    attributesMap: (f = msg.getAttributesMap()) ? f.toObject(includeInstance, proto.yorkie.v1.NodeAttr.toObject) : []
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.TreeNode}
 */
proto.yorkie.v1.TreeNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.TreeNode;
  return proto.yorkie.v1.TreeNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.TreeNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.TreeNode}
 */
proto.yorkie.v1.TreeNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TreeNodeID;
      reader.readMessage(value,proto.yorkie.v1.TreeNodeID.deserializeBinaryFromReader);
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setType(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setValue(value);
      break;
    case 4:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setRemovedAt(value);
      break;
    case 5:
      var value = new proto.yorkie.v1.TreeNodeID;
      reader.readMessage(value,proto.yorkie.v1.TreeNodeID.deserializeBinaryFromReader);
      msg.setInsPrevId(value);
      break;
    case 6:
      var value = new proto.yorkie.v1.TreeNodeID;
      reader.readMessage(value,proto.yorkie.v1.TreeNodeID.deserializeBinaryFromReader);
      msg.setInsNextId(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setDepth(value);
      break;
    case 8:
      var value = msg.getAttributesMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, proto.yorkie.v1.NodeAttr.deserializeBinaryFromReader, "", new proto.yorkie.v1.NodeAttr());
         });
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.TreeNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.TreeNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.TreeNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.TreeNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TreeNodeID.serializeBinaryToWriter
    );
  }
  f = message.getType();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getValue();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getRemovedAt();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getInsPrevId();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.yorkie.v1.TreeNodeID.serializeBinaryToWriter
    );
  }
  f = message.getInsNextId();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.yorkie.v1.TreeNodeID.serializeBinaryToWriter
    );
  }
  f = message.getDepth();
  if (f !== 0) {
    writer.writeInt32(
      7,
      f
    );
  }
  f = message.getAttributesMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(8, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, proto.yorkie.v1.NodeAttr.serializeBinaryToWriter);
  }
};


/**
 * optional TreeNodeID id = 1;
 * @return {?proto.yorkie.v1.TreeNodeID}
 */
proto.yorkie.v1.TreeNode.prototype.getId = function() {
  return /** @type{?proto.yorkie.v1.TreeNodeID} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TreeNodeID, 1));
};


/**
 * @param {?proto.yorkie.v1.TreeNodeID|undefined} value
 * @return {!proto.yorkie.v1.TreeNode} returns this
*/
proto.yorkie.v1.TreeNode.prototype.setId = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.TreeNode} returns this
 */
proto.yorkie.v1.TreeNode.prototype.clearId = function() {
  return this.setId(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.TreeNode.prototype.hasId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string type = 2;
 * @return {string}
 */
proto.yorkie.v1.TreeNode.prototype.getType = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.TreeNode} returns this
 */
proto.yorkie.v1.TreeNode.prototype.setType = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string value = 3;
 * @return {string}
 */
proto.yorkie.v1.TreeNode.prototype.getValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.TreeNode} returns this
 */
proto.yorkie.v1.TreeNode.prototype.setValue = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional TimeTicket removed_at = 4;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.TreeNode.prototype.getRemovedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 4));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.TreeNode} returns this
*/
proto.yorkie.v1.TreeNode.prototype.setRemovedAt = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.TreeNode} returns this
 */
proto.yorkie.v1.TreeNode.prototype.clearRemovedAt = function() {
  return this.setRemovedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.TreeNode.prototype.hasRemovedAt = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional TreeNodeID ins_prev_id = 5;
 * @return {?proto.yorkie.v1.TreeNodeID}
 */
proto.yorkie.v1.TreeNode.prototype.getInsPrevId = function() {
  return /** @type{?proto.yorkie.v1.TreeNodeID} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TreeNodeID, 5));
};


/**
 * @param {?proto.yorkie.v1.TreeNodeID|undefined} value
 * @return {!proto.yorkie.v1.TreeNode} returns this
*/
proto.yorkie.v1.TreeNode.prototype.setInsPrevId = function(value) {
  return jspb.Message.setWrapperField(this, 5, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.TreeNode} returns this
 */
proto.yorkie.v1.TreeNode.prototype.clearInsPrevId = function() {
  return this.setInsPrevId(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.TreeNode.prototype.hasInsPrevId = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional TreeNodeID ins_next_id = 6;
 * @return {?proto.yorkie.v1.TreeNodeID}
 */
proto.yorkie.v1.TreeNode.prototype.getInsNextId = function() {
  return /** @type{?proto.yorkie.v1.TreeNodeID} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TreeNodeID, 6));
};


/**
 * @param {?proto.yorkie.v1.TreeNodeID|undefined} value
 * @return {!proto.yorkie.v1.TreeNode} returns this
*/
proto.yorkie.v1.TreeNode.prototype.setInsNextId = function(value) {
  return jspb.Message.setWrapperField(this, 6, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.TreeNode} returns this
 */
proto.yorkie.v1.TreeNode.prototype.clearInsNextId = function() {
  return this.setInsNextId(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.TreeNode.prototype.hasInsNextId = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional int32 depth = 7;
 * @return {number}
 */
proto.yorkie.v1.TreeNode.prototype.getDepth = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/**
 * @param {number} value
 * @return {!proto.yorkie.v1.TreeNode} returns this
 */
proto.yorkie.v1.TreeNode.prototype.setDepth = function(value) {
  return jspb.Message.setProto3IntField(this, 7, value);
};


/**
 * map<string, NodeAttr> attributes = 8;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.yorkie.v1.NodeAttr>}
 */
proto.yorkie.v1.TreeNode.prototype.getAttributesMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,!proto.yorkie.v1.NodeAttr>} */ (
      jspb.Message.getMapField(this, 8, opt_noLazyCreate,
      proto.yorkie.v1.NodeAttr));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.yorkie.v1.TreeNode} returns this
 */
proto.yorkie.v1.TreeNode.prototype.clearAttributesMap = function() {
  this.getAttributesMap().clear();
  return this;};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.yorkie.v1.TreeNodes.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.TreeNodes.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.TreeNodes.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.TreeNodes} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.TreeNodes.toObject = function(includeInstance, msg) {
  var f, obj = {
    contentList: jspb.Message.toObjectList(msg.getContentList(),
    proto.yorkie.v1.TreeNode.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.TreeNodes}
 */
proto.yorkie.v1.TreeNodes.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.TreeNodes;
  return proto.yorkie.v1.TreeNodes.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.TreeNodes} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.TreeNodes}
 */
proto.yorkie.v1.TreeNodes.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TreeNode;
      reader.readMessage(value,proto.yorkie.v1.TreeNode.deserializeBinaryFromReader);
      msg.addContent(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.TreeNodes.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.TreeNodes.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.TreeNodes} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.TreeNodes.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getContentList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.yorkie.v1.TreeNode.serializeBinaryToWriter
    );
  }
};


/**
 * repeated TreeNode content = 1;
 * @return {!Array<!proto.yorkie.v1.TreeNode>}
 */
proto.yorkie.v1.TreeNodes.prototype.getContentList = function() {
  return /** @type{!Array<!proto.yorkie.v1.TreeNode>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.yorkie.v1.TreeNode, 1));
};


/**
 * @param {!Array<!proto.yorkie.v1.TreeNode>} value
 * @return {!proto.yorkie.v1.TreeNodes} returns this
*/
proto.yorkie.v1.TreeNodes.prototype.setContentList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.yorkie.v1.TreeNode=} opt_value
 * @param {number=} opt_index
 * @return {!proto.yorkie.v1.TreeNode}
 */
proto.yorkie.v1.TreeNodes.prototype.addContent = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.yorkie.v1.TreeNode, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.yorkie.v1.TreeNodes} returns this
 */
proto.yorkie.v1.TreeNodes.prototype.clearContentList = function() {
  return this.setContentList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.TreeNodeID.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.TreeNodeID.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.TreeNodeID} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.TreeNodeID.toObject = function(includeInstance, msg) {
  var f, obj = {
    createdAt: (f = msg.getCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    offset: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.TreeNodeID}
 */
proto.yorkie.v1.TreeNodeID.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.TreeNodeID;
  return proto.yorkie.v1.TreeNodeID.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.TreeNodeID} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.TreeNodeID}
 */
proto.yorkie.v1.TreeNodeID.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setCreatedAt(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setOffset(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.TreeNodeID.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.TreeNodeID.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.TreeNodeID} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.TreeNodeID.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCreatedAt();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getOffset();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * optional TimeTicket created_at = 1;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.TreeNodeID.prototype.getCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 1));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.TreeNodeID} returns this
*/
proto.yorkie.v1.TreeNodeID.prototype.setCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.TreeNodeID} returns this
 */
proto.yorkie.v1.TreeNodeID.prototype.clearCreatedAt = function() {
  return this.setCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.TreeNodeID.prototype.hasCreatedAt = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int32 offset = 2;
 * @return {number}
 */
proto.yorkie.v1.TreeNodeID.prototype.getOffset = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.yorkie.v1.TreeNodeID} returns this
 */
proto.yorkie.v1.TreeNodeID.prototype.setOffset = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.TreePos.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.TreePos.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.TreePos} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.TreePos.toObject = function(includeInstance, msg) {
  var f, obj = {
    parentId: (f = msg.getParentId()) && proto.yorkie.v1.TreeNodeID.toObject(includeInstance, f),
    leftSiblingId: (f = msg.getLeftSiblingId()) && proto.yorkie.v1.TreeNodeID.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.TreePos}
 */
proto.yorkie.v1.TreePos.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.TreePos;
  return proto.yorkie.v1.TreePos.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.TreePos} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.TreePos}
 */
proto.yorkie.v1.TreePos.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TreeNodeID;
      reader.readMessage(value,proto.yorkie.v1.TreeNodeID.deserializeBinaryFromReader);
      msg.setParentId(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.TreeNodeID;
      reader.readMessage(value,proto.yorkie.v1.TreeNodeID.deserializeBinaryFromReader);
      msg.setLeftSiblingId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.TreePos.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.TreePos.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.TreePos} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.TreePos.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getParentId();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TreeNodeID.serializeBinaryToWriter
    );
  }
  f = message.getLeftSiblingId();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.TreeNodeID.serializeBinaryToWriter
    );
  }
};


/**
 * optional TreeNodeID parent_id = 1;
 * @return {?proto.yorkie.v1.TreeNodeID}
 */
proto.yorkie.v1.TreePos.prototype.getParentId = function() {
  return /** @type{?proto.yorkie.v1.TreeNodeID} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TreeNodeID, 1));
};


/**
 * @param {?proto.yorkie.v1.TreeNodeID|undefined} value
 * @return {!proto.yorkie.v1.TreePos} returns this
*/
proto.yorkie.v1.TreePos.prototype.setParentId = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.TreePos} returns this
 */
proto.yorkie.v1.TreePos.prototype.clearParentId = function() {
  return this.setParentId(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.TreePos.prototype.hasParentId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TreeNodeID left_sibling_id = 2;
 * @return {?proto.yorkie.v1.TreeNodeID}
 */
proto.yorkie.v1.TreePos.prototype.getLeftSiblingId = function() {
  return /** @type{?proto.yorkie.v1.TreeNodeID} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TreeNodeID, 2));
};


/**
 * @param {?proto.yorkie.v1.TreeNodeID|undefined} value
 * @return {!proto.yorkie.v1.TreePos} returns this
*/
proto.yorkie.v1.TreePos.prototype.setLeftSiblingId = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.TreePos} returns this
 */
proto.yorkie.v1.TreePos.prototype.clearLeftSiblingId = function() {
  return this.setLeftSiblingId(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.TreePos.prototype.hasLeftSiblingId = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.User.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.User.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.User} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.User.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: jspb.Message.getFieldWithDefault(msg, 1, ""),
    username: jspb.Message.getFieldWithDefault(msg, 2, ""),
    createdAt: (f = msg.getCreatedAt()) && google_protobuf_timestamp_pb.Timestamp.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.User}
 */
proto.yorkie.v1.User.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.User;
  return proto.yorkie.v1.User.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.User} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.User}
 */
proto.yorkie.v1.User.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setUsername(value);
      break;
    case 3:
      var value = new google_protobuf_timestamp_pb.Timestamp;
      reader.readMessage(value,google_protobuf_timestamp_pb.Timestamp.deserializeBinaryFromReader);
      msg.setCreatedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.User.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.User.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.User} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.User.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getUsername();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getCreatedAt();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      google_protobuf_timestamp_pb.Timestamp.serializeBinaryToWriter
    );
  }
};


/**
 * optional string id = 1;
 * @return {string}
 */
proto.yorkie.v1.User.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.User} returns this
 */
proto.yorkie.v1.User.prototype.setId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string username = 2;
 * @return {string}
 */
proto.yorkie.v1.User.prototype.getUsername = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.User} returns this
 */
proto.yorkie.v1.User.prototype.setUsername = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional google.protobuf.Timestamp created_at = 3;
 * @return {?proto.google.protobuf.Timestamp}
 */
proto.yorkie.v1.User.prototype.getCreatedAt = function() {
  return /** @type{?proto.google.protobuf.Timestamp} */ (
    jspb.Message.getWrapperField(this, google_protobuf_timestamp_pb.Timestamp, 3));
};


/**
 * @param {?proto.google.protobuf.Timestamp|undefined} value
 * @return {!proto.yorkie.v1.User} returns this
*/
proto.yorkie.v1.User.prototype.setCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.User} returns this
 */
proto.yorkie.v1.User.prototype.clearCreatedAt = function() {
  return this.setCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.User.prototype.hasCreatedAt = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.yorkie.v1.Project.repeatedFields_ = [6];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.Project.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.Project.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.Project} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Project.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: jspb.Message.getFieldWithDefault(msg, 1, ""),
    name: jspb.Message.getFieldWithDefault(msg, 2, ""),
    publicKey: jspb.Message.getFieldWithDefault(msg, 3, ""),
    secretKey: jspb.Message.getFieldWithDefault(msg, 4, ""),
    authWebhookUrl: jspb.Message.getFieldWithDefault(msg, 5, ""),
    authWebhookMethodsList: (f = jspb.Message.getRepeatedField(msg, 6)) == null ? undefined : f,
    clientDeactivateThreshold: jspb.Message.getFieldWithDefault(msg, 7, ""),
    createdAt: (f = msg.getCreatedAt()) && google_protobuf_timestamp_pb.Timestamp.toObject(includeInstance, f),
    updatedAt: (f = msg.getUpdatedAt()) && google_protobuf_timestamp_pb.Timestamp.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.Project}
 */
proto.yorkie.v1.Project.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.Project;
  return proto.yorkie.v1.Project.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.Project} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.Project}
 */
proto.yorkie.v1.Project.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setPublicKey(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setSecretKey(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setAuthWebhookUrl(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.addAuthWebhookMethods(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setClientDeactivateThreshold(value);
      break;
    case 8:
      var value = new google_protobuf_timestamp_pb.Timestamp;
      reader.readMessage(value,google_protobuf_timestamp_pb.Timestamp.deserializeBinaryFromReader);
      msg.setCreatedAt(value);
      break;
    case 9:
      var value = new google_protobuf_timestamp_pb.Timestamp;
      reader.readMessage(value,google_protobuf_timestamp_pb.Timestamp.deserializeBinaryFromReader);
      msg.setUpdatedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.Project.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.Project.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.Project} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Project.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getPublicKey();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getSecretKey();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getAuthWebhookUrl();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getAuthWebhookMethodsList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      6,
      f
    );
  }
  f = message.getClientDeactivateThreshold();
  if (f.length > 0) {
    writer.writeString(
      7,
      f
    );
  }
  f = message.getCreatedAt();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      google_protobuf_timestamp_pb.Timestamp.serializeBinaryToWriter
    );
  }
  f = message.getUpdatedAt();
  if (f != null) {
    writer.writeMessage(
      9,
      f,
      google_protobuf_timestamp_pb.Timestamp.serializeBinaryToWriter
    );
  }
};


/**
 * optional string id = 1;
 * @return {string}
 */
proto.yorkie.v1.Project.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.Project} returns this
 */
proto.yorkie.v1.Project.prototype.setId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string name = 2;
 * @return {string}
 */
proto.yorkie.v1.Project.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.Project} returns this
 */
proto.yorkie.v1.Project.prototype.setName = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string public_key = 3;
 * @return {string}
 */
proto.yorkie.v1.Project.prototype.getPublicKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.Project} returns this
 */
proto.yorkie.v1.Project.prototype.setPublicKey = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string secret_key = 4;
 * @return {string}
 */
proto.yorkie.v1.Project.prototype.getSecretKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.Project} returns this
 */
proto.yorkie.v1.Project.prototype.setSecretKey = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional string auth_webhook_url = 5;
 * @return {string}
 */
proto.yorkie.v1.Project.prototype.getAuthWebhookUrl = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.Project} returns this
 */
proto.yorkie.v1.Project.prototype.setAuthWebhookUrl = function(value) {
  return jspb.Message.setProto3StringField(this, 5, value);
};


/**
 * repeated string auth_webhook_methods = 6;
 * @return {!Array<string>}
 */
proto.yorkie.v1.Project.prototype.getAuthWebhookMethodsList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 6));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.yorkie.v1.Project} returns this
 */
proto.yorkie.v1.Project.prototype.setAuthWebhookMethodsList = function(value) {
  return jspb.Message.setField(this, 6, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.yorkie.v1.Project} returns this
 */
proto.yorkie.v1.Project.prototype.addAuthWebhookMethods = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 6, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.yorkie.v1.Project} returns this
 */
proto.yorkie.v1.Project.prototype.clearAuthWebhookMethodsList = function() {
  return this.setAuthWebhookMethodsList([]);
};


/**
 * optional string client_deactivate_threshold = 7;
 * @return {string}
 */
proto.yorkie.v1.Project.prototype.getClientDeactivateThreshold = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.Project} returns this
 */
proto.yorkie.v1.Project.prototype.setClientDeactivateThreshold = function(value) {
  return jspb.Message.setProto3StringField(this, 7, value);
};


/**
 * optional google.protobuf.Timestamp created_at = 8;
 * @return {?proto.google.protobuf.Timestamp}
 */
proto.yorkie.v1.Project.prototype.getCreatedAt = function() {
  return /** @type{?proto.google.protobuf.Timestamp} */ (
    jspb.Message.getWrapperField(this, google_protobuf_timestamp_pb.Timestamp, 8));
};


/**
 * @param {?proto.google.protobuf.Timestamp|undefined} value
 * @return {!proto.yorkie.v1.Project} returns this
*/
proto.yorkie.v1.Project.prototype.setCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 8, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Project} returns this
 */
proto.yorkie.v1.Project.prototype.clearCreatedAt = function() {
  return this.setCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Project.prototype.hasCreatedAt = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional google.protobuf.Timestamp updated_at = 9;
 * @return {?proto.google.protobuf.Timestamp}
 */
proto.yorkie.v1.Project.prototype.getUpdatedAt = function() {
  return /** @type{?proto.google.protobuf.Timestamp} */ (
    jspb.Message.getWrapperField(this, google_protobuf_timestamp_pb.Timestamp, 9));
};


/**
 * @param {?proto.google.protobuf.Timestamp|undefined} value
 * @return {!proto.yorkie.v1.Project} returns this
*/
proto.yorkie.v1.Project.prototype.setUpdatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 9, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.Project} returns this
 */
proto.yorkie.v1.Project.prototype.clearUpdatedAt = function() {
  return this.setUpdatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.Project.prototype.hasUpdatedAt = function() {
  return jspb.Message.getField(this, 9) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.UpdatableProjectFields.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.UpdatableProjectFields.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.UpdatableProjectFields} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.UpdatableProjectFields.toObject = function(includeInstance, msg) {
  var f, obj = {
    name: (f = msg.getName()) && google_protobuf_wrappers_pb.StringValue.toObject(includeInstance, f),
    authWebhookUrl: (f = msg.getAuthWebhookUrl()) && google_protobuf_wrappers_pb.StringValue.toObject(includeInstance, f),
    authWebhookMethods: (f = msg.getAuthWebhookMethods()) && proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.toObject(includeInstance, f),
    clientDeactivateThreshold: (f = msg.getClientDeactivateThreshold()) && google_protobuf_wrappers_pb.StringValue.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.UpdatableProjectFields}
 */
proto.yorkie.v1.UpdatableProjectFields.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.UpdatableProjectFields;
  return proto.yorkie.v1.UpdatableProjectFields.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.UpdatableProjectFields} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.UpdatableProjectFields}
 */
proto.yorkie.v1.UpdatableProjectFields.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new google_protobuf_wrappers_pb.StringValue;
      reader.readMessage(value,google_protobuf_wrappers_pb.StringValue.deserializeBinaryFromReader);
      msg.setName(value);
      break;
    case 2:
      var value = new google_protobuf_wrappers_pb.StringValue;
      reader.readMessage(value,google_protobuf_wrappers_pb.StringValue.deserializeBinaryFromReader);
      msg.setAuthWebhookUrl(value);
      break;
    case 3:
      var value = new proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods;
      reader.readMessage(value,proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.deserializeBinaryFromReader);
      msg.setAuthWebhookMethods(value);
      break;
    case 4:
      var value = new google_protobuf_wrappers_pb.StringValue;
      reader.readMessage(value,google_protobuf_wrappers_pb.StringValue.deserializeBinaryFromReader);
      msg.setClientDeactivateThreshold(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.UpdatableProjectFields.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.UpdatableProjectFields.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.UpdatableProjectFields} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.UpdatableProjectFields.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getName();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      google_protobuf_wrappers_pb.StringValue.serializeBinaryToWriter
    );
  }
  f = message.getAuthWebhookUrl();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      google_protobuf_wrappers_pb.StringValue.serializeBinaryToWriter
    );
  }
  f = message.getAuthWebhookMethods();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.serializeBinaryToWriter
    );
  }
  f = message.getClientDeactivateThreshold();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      google_protobuf_wrappers_pb.StringValue.serializeBinaryToWriter
    );
  }
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.toObject = function(includeInstance, msg) {
  var f, obj = {
    methodsList: (f = jspb.Message.getRepeatedField(msg, 1)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods}
 */
proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods;
  return proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods}
 */
proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.addMethods(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMethodsList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      1,
      f
    );
  }
};


/**
 * repeated string methods = 1;
 * @return {!Array<string>}
 */
proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.prototype.getMethodsList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 1));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods} returns this
 */
proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.prototype.setMethodsList = function(value) {
  return jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods} returns this
 */
proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.prototype.addMethods = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods} returns this
 */
proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods.prototype.clearMethodsList = function() {
  return this.setMethodsList([]);
};


/**
 * optional google.protobuf.StringValue name = 1;
 * @return {?proto.google.protobuf.StringValue}
 */
proto.yorkie.v1.UpdatableProjectFields.prototype.getName = function() {
  return /** @type{?proto.google.protobuf.StringValue} */ (
    jspb.Message.getWrapperField(this, google_protobuf_wrappers_pb.StringValue, 1));
};


/**
 * @param {?proto.google.protobuf.StringValue|undefined} value
 * @return {!proto.yorkie.v1.UpdatableProjectFields} returns this
*/
proto.yorkie.v1.UpdatableProjectFields.prototype.setName = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.UpdatableProjectFields} returns this
 */
proto.yorkie.v1.UpdatableProjectFields.prototype.clearName = function() {
  return this.setName(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.UpdatableProjectFields.prototype.hasName = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional google.protobuf.StringValue auth_webhook_url = 2;
 * @return {?proto.google.protobuf.StringValue}
 */
proto.yorkie.v1.UpdatableProjectFields.prototype.getAuthWebhookUrl = function() {
  return /** @type{?proto.google.protobuf.StringValue} */ (
    jspb.Message.getWrapperField(this, google_protobuf_wrappers_pb.StringValue, 2));
};


/**
 * @param {?proto.google.protobuf.StringValue|undefined} value
 * @return {!proto.yorkie.v1.UpdatableProjectFields} returns this
*/
proto.yorkie.v1.UpdatableProjectFields.prototype.setAuthWebhookUrl = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.UpdatableProjectFields} returns this
 */
proto.yorkie.v1.UpdatableProjectFields.prototype.clearAuthWebhookUrl = function() {
  return this.setAuthWebhookUrl(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.UpdatableProjectFields.prototype.hasAuthWebhookUrl = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional AuthWebhookMethods auth_webhook_methods = 3;
 * @return {?proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods}
 */
proto.yorkie.v1.UpdatableProjectFields.prototype.getAuthWebhookMethods = function() {
  return /** @type{?proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods, 3));
};


/**
 * @param {?proto.yorkie.v1.UpdatableProjectFields.AuthWebhookMethods|undefined} value
 * @return {!proto.yorkie.v1.UpdatableProjectFields} returns this
*/
proto.yorkie.v1.UpdatableProjectFields.prototype.setAuthWebhookMethods = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.UpdatableProjectFields} returns this
 */
proto.yorkie.v1.UpdatableProjectFields.prototype.clearAuthWebhookMethods = function() {
  return this.setAuthWebhookMethods(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.UpdatableProjectFields.prototype.hasAuthWebhookMethods = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional google.protobuf.StringValue client_deactivate_threshold = 4;
 * @return {?proto.google.protobuf.StringValue}
 */
proto.yorkie.v1.UpdatableProjectFields.prototype.getClientDeactivateThreshold = function() {
  return /** @type{?proto.google.protobuf.StringValue} */ (
    jspb.Message.getWrapperField(this, google_protobuf_wrappers_pb.StringValue, 4));
};


/**
 * @param {?proto.google.protobuf.StringValue|undefined} value
 * @return {!proto.yorkie.v1.UpdatableProjectFields} returns this
*/
proto.yorkie.v1.UpdatableProjectFields.prototype.setClientDeactivateThreshold = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.UpdatableProjectFields} returns this
 */
proto.yorkie.v1.UpdatableProjectFields.prototype.clearClientDeactivateThreshold = function() {
  return this.setClientDeactivateThreshold(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.UpdatableProjectFields.prototype.hasClientDeactivateThreshold = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.DocumentSummary.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.DocumentSummary.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.DocumentSummary} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.DocumentSummary.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: jspb.Message.getFieldWithDefault(msg, 1, ""),
    key: jspb.Message.getFieldWithDefault(msg, 2, ""),
    snapshot: jspb.Message.getFieldWithDefault(msg, 3, ""),
    createdAt: (f = msg.getCreatedAt()) && google_protobuf_timestamp_pb.Timestamp.toObject(includeInstance, f),
    accessedAt: (f = msg.getAccessedAt()) && google_protobuf_timestamp_pb.Timestamp.toObject(includeInstance, f),
    updatedAt: (f = msg.getUpdatedAt()) && google_protobuf_timestamp_pb.Timestamp.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.DocumentSummary}
 */
proto.yorkie.v1.DocumentSummary.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.DocumentSummary;
  return proto.yorkie.v1.DocumentSummary.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.DocumentSummary} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.DocumentSummary}
 */
proto.yorkie.v1.DocumentSummary.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setKey(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setSnapshot(value);
      break;
    case 4:
      var value = new google_protobuf_timestamp_pb.Timestamp;
      reader.readMessage(value,google_protobuf_timestamp_pb.Timestamp.deserializeBinaryFromReader);
      msg.setCreatedAt(value);
      break;
    case 5:
      var value = new google_protobuf_timestamp_pb.Timestamp;
      reader.readMessage(value,google_protobuf_timestamp_pb.Timestamp.deserializeBinaryFromReader);
      msg.setAccessedAt(value);
      break;
    case 6:
      var value = new google_protobuf_timestamp_pb.Timestamp;
      reader.readMessage(value,google_protobuf_timestamp_pb.Timestamp.deserializeBinaryFromReader);
      msg.setUpdatedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.DocumentSummary.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.DocumentSummary.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.DocumentSummary} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.DocumentSummary.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getKey();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getSnapshot();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getCreatedAt();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      google_protobuf_timestamp_pb.Timestamp.serializeBinaryToWriter
    );
  }
  f = message.getAccessedAt();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      google_protobuf_timestamp_pb.Timestamp.serializeBinaryToWriter
    );
  }
  f = message.getUpdatedAt();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      google_protobuf_timestamp_pb.Timestamp.serializeBinaryToWriter
    );
  }
};


/**
 * optional string id = 1;
 * @return {string}
 */
proto.yorkie.v1.DocumentSummary.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.DocumentSummary} returns this
 */
proto.yorkie.v1.DocumentSummary.prototype.setId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string key = 2;
 * @return {string}
 */
proto.yorkie.v1.DocumentSummary.prototype.getKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.DocumentSummary} returns this
 */
proto.yorkie.v1.DocumentSummary.prototype.setKey = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string snapshot = 3;
 * @return {string}
 */
proto.yorkie.v1.DocumentSummary.prototype.getSnapshot = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.DocumentSummary} returns this
 */
proto.yorkie.v1.DocumentSummary.prototype.setSnapshot = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional google.protobuf.Timestamp created_at = 4;
 * @return {?proto.google.protobuf.Timestamp}
 */
proto.yorkie.v1.DocumentSummary.prototype.getCreatedAt = function() {
  return /** @type{?proto.google.protobuf.Timestamp} */ (
    jspb.Message.getWrapperField(this, google_protobuf_timestamp_pb.Timestamp, 4));
};


/**
 * @param {?proto.google.protobuf.Timestamp|undefined} value
 * @return {!proto.yorkie.v1.DocumentSummary} returns this
*/
proto.yorkie.v1.DocumentSummary.prototype.setCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.DocumentSummary} returns this
 */
proto.yorkie.v1.DocumentSummary.prototype.clearCreatedAt = function() {
  return this.setCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.DocumentSummary.prototype.hasCreatedAt = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional google.protobuf.Timestamp accessed_at = 5;
 * @return {?proto.google.protobuf.Timestamp}
 */
proto.yorkie.v1.DocumentSummary.prototype.getAccessedAt = function() {
  return /** @type{?proto.google.protobuf.Timestamp} */ (
    jspb.Message.getWrapperField(this, google_protobuf_timestamp_pb.Timestamp, 5));
};


/**
 * @param {?proto.google.protobuf.Timestamp|undefined} value
 * @return {!proto.yorkie.v1.DocumentSummary} returns this
*/
proto.yorkie.v1.DocumentSummary.prototype.setAccessedAt = function(value) {
  return jspb.Message.setWrapperField(this, 5, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.DocumentSummary} returns this
 */
proto.yorkie.v1.DocumentSummary.prototype.clearAccessedAt = function() {
  return this.setAccessedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.DocumentSummary.prototype.hasAccessedAt = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional google.protobuf.Timestamp updated_at = 6;
 * @return {?proto.google.protobuf.Timestamp}
 */
proto.yorkie.v1.DocumentSummary.prototype.getUpdatedAt = function() {
  return /** @type{?proto.google.protobuf.Timestamp} */ (
    jspb.Message.getWrapperField(this, google_protobuf_timestamp_pb.Timestamp, 6));
};


/**
 * @param {?proto.google.protobuf.Timestamp|undefined} value
 * @return {!proto.yorkie.v1.DocumentSummary} returns this
*/
proto.yorkie.v1.DocumentSummary.prototype.setUpdatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 6, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.DocumentSummary} returns this
 */
proto.yorkie.v1.DocumentSummary.prototype.clearUpdatedAt = function() {
  return this.setUpdatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.DocumentSummary.prototype.hasUpdatedAt = function() {
  return jspb.Message.getField(this, 6) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.PresenceChange.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.PresenceChange.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.PresenceChange} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.PresenceChange.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getFieldWithDefault(msg, 1, 0),
    presence: (f = msg.getPresence()) && proto.yorkie.v1.Presence.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.PresenceChange}
 */
proto.yorkie.v1.PresenceChange.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.PresenceChange;
  return proto.yorkie.v1.PresenceChange.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.PresenceChange} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.PresenceChange}
 */
proto.yorkie.v1.PresenceChange.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.yorkie.v1.PresenceChange.ChangeType} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 2:
      var value = new proto.yorkie.v1.Presence;
      reader.readMessage(value,proto.yorkie.v1.Presence.deserializeBinaryFromReader);
      msg.setPresence(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.PresenceChange.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.PresenceChange.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.PresenceChange} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.PresenceChange.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getPresence();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.yorkie.v1.Presence.serializeBinaryToWriter
    );
  }
};


/**
 * @enum {number}
 */
proto.yorkie.v1.PresenceChange.ChangeType = {
  CHANGE_TYPE_UNSPECIFIED: 0,
  CHANGE_TYPE_PUT: 1,
  CHANGE_TYPE_DELETE: 2,
  CHANGE_TYPE_CLEAR: 3
};

/**
 * optional ChangeType type = 1;
 * @return {!proto.yorkie.v1.PresenceChange.ChangeType}
 */
proto.yorkie.v1.PresenceChange.prototype.getType = function() {
  return /** @type {!proto.yorkie.v1.PresenceChange.ChangeType} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.yorkie.v1.PresenceChange.ChangeType} value
 * @return {!proto.yorkie.v1.PresenceChange} returns this
 */
proto.yorkie.v1.PresenceChange.prototype.setType = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional Presence presence = 2;
 * @return {?proto.yorkie.v1.Presence}
 */
proto.yorkie.v1.PresenceChange.prototype.getPresence = function() {
  return /** @type{?proto.yorkie.v1.Presence} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.Presence, 2));
};


/**
 * @param {?proto.yorkie.v1.Presence|undefined} value
 * @return {!proto.yorkie.v1.PresenceChange} returns this
*/
proto.yorkie.v1.PresenceChange.prototype.setPresence = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.PresenceChange} returns this
 */
proto.yorkie.v1.PresenceChange.prototype.clearPresence = function() {
  return this.setPresence(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.PresenceChange.prototype.hasPresence = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.Presence.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.Presence.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.Presence} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Presence.toObject = function(includeInstance, msg) {
  var f, obj = {
    dataMap: (f = msg.getDataMap()) ? f.toObject(includeInstance, undefined) : []
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.Presence}
 */
proto.yorkie.v1.Presence.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.Presence;
  return proto.yorkie.v1.Presence.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.Presence} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.Presence}
 */
proto.yorkie.v1.Presence.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = msg.getDataMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readString, null, "", "");
         });
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.Presence.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.Presence.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.Presence} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Presence.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDataMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(1, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeString);
  }
};


/**
 * map<string, string> data = 1;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,string>}
 */
proto.yorkie.v1.Presence.prototype.getDataMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,string>} */ (
      jspb.Message.getMapField(this, 1, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.yorkie.v1.Presence} returns this
 */
proto.yorkie.v1.Presence.prototype.clearDataMap = function() {
  this.getDataMap().clear();
  return this;};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.Checkpoint.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.Checkpoint.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.Checkpoint} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Checkpoint.toObject = function(includeInstance, msg) {
  var f, obj = {
    serverSeq: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    clientSeq: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.Checkpoint}
 */
proto.yorkie.v1.Checkpoint.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.Checkpoint;
  return proto.yorkie.v1.Checkpoint.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.Checkpoint} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.Checkpoint}
 */
proto.yorkie.v1.Checkpoint.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readInt64String());
      msg.setServerSeq(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setClientSeq(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.Checkpoint.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.Checkpoint.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.Checkpoint} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.Checkpoint.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getServerSeq();
  if (parseInt(f, 10) !== 0) {
    writer.writeInt64String(
      1,
      f
    );
  }
  f = message.getClientSeq();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
};


/**
 * optional int64 server_seq = 1;
 * @return {string}
 */
proto.yorkie.v1.Checkpoint.prototype.getServerSeq = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.Checkpoint} returns this
 */
proto.yorkie.v1.Checkpoint.prototype.setServerSeq = function(value) {
  return jspb.Message.setProto3StringIntField(this, 1, value);
};


/**
 * optional uint32 client_seq = 2;
 * @return {number}
 */
proto.yorkie.v1.Checkpoint.prototype.getClientSeq = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.yorkie.v1.Checkpoint} returns this
 */
proto.yorkie.v1.Checkpoint.prototype.setClientSeq = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.TextNodePos.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.TextNodePos.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.TextNodePos} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.TextNodePos.toObject = function(includeInstance, msg) {
  var f, obj = {
    createdAt: (f = msg.getCreatedAt()) && proto.yorkie.v1.TimeTicket.toObject(includeInstance, f),
    offset: jspb.Message.getFieldWithDefault(msg, 2, 0),
    relativeOffset: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.TextNodePos}
 */
proto.yorkie.v1.TextNodePos.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.TextNodePos;
  return proto.yorkie.v1.TextNodePos.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.TextNodePos} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.TextNodePos}
 */
proto.yorkie.v1.TextNodePos.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.TimeTicket;
      reader.readMessage(value,proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader);
      msg.setCreatedAt(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setOffset(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRelativeOffset(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.TextNodePos.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.TextNodePos.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.TextNodePos} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.TextNodePos.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCreatedAt();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.TimeTicket.serializeBinaryToWriter
    );
  }
  f = message.getOffset();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = message.getRelativeOffset();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
};


/**
 * optional TimeTicket created_at = 1;
 * @return {?proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.TextNodePos.prototype.getCreatedAt = function() {
  return /** @type{?proto.yorkie.v1.TimeTicket} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.TimeTicket, 1));
};


/**
 * @param {?proto.yorkie.v1.TimeTicket|undefined} value
 * @return {!proto.yorkie.v1.TextNodePos} returns this
*/
proto.yorkie.v1.TextNodePos.prototype.setCreatedAt = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.TextNodePos} returns this
 */
proto.yorkie.v1.TextNodePos.prototype.clearCreatedAt = function() {
  return this.setCreatedAt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.TextNodePos.prototype.hasCreatedAt = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int32 offset = 2;
 * @return {number}
 */
proto.yorkie.v1.TextNodePos.prototype.getOffset = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.yorkie.v1.TextNodePos} returns this
 */
proto.yorkie.v1.TextNodePos.prototype.setOffset = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional int32 relative_offset = 3;
 * @return {number}
 */
proto.yorkie.v1.TextNodePos.prototype.getRelativeOffset = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.yorkie.v1.TextNodePos} returns this
 */
proto.yorkie.v1.TextNodePos.prototype.setRelativeOffset = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.TimeTicket.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.TimeTicket.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.TimeTicket} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.TimeTicket.toObject = function(includeInstance, msg) {
  var f, obj = {
    lamport: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    delimiter: jspb.Message.getFieldWithDefault(msg, 2, 0),
    actorId: msg.getActorId_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.TimeTicket.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.TimeTicket;
  return proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.TimeTicket} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.TimeTicket}
 */
proto.yorkie.v1.TimeTicket.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readInt64String());
      msg.setLamport(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setDelimiter(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setActorId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.TimeTicket.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.TimeTicket.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.TimeTicket} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.TimeTicket.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLamport();
  if (parseInt(f, 10) !== 0) {
    writer.writeInt64String(
      1,
      f
    );
  }
  f = message.getDelimiter();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getActorId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional int64 lamport = 1;
 * @return {string}
 */
proto.yorkie.v1.TimeTicket.prototype.getLamport = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.TimeTicket} returns this
 */
proto.yorkie.v1.TimeTicket.prototype.setLamport = function(value) {
  return jspb.Message.setProto3StringIntField(this, 1, value);
};


/**
 * optional uint32 delimiter = 2;
 * @return {number}
 */
proto.yorkie.v1.TimeTicket.prototype.getDelimiter = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.yorkie.v1.TimeTicket} returns this
 */
proto.yorkie.v1.TimeTicket.prototype.setDelimiter = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional bytes actor_id = 3;
 * @return {string}
 */
proto.yorkie.v1.TimeTicket.prototype.getActorId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes actor_id = 3;
 * This is a type-conversion wrapper around `getActorId()`
 * @return {string}
 */
proto.yorkie.v1.TimeTicket.prototype.getActorId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getActorId()));
};


/**
 * optional bytes actor_id = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getActorId()`
 * @return {!Uint8Array}
 */
proto.yorkie.v1.TimeTicket.prototype.getActorId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getActorId()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.yorkie.v1.TimeTicket} returns this
 */
proto.yorkie.v1.TimeTicket.prototype.setActorId = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.DocEvent.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.DocEvent.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.DocEvent} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.DocEvent.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getFieldWithDefault(msg, 1, 0),
    publisher: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.DocEvent}
 */
proto.yorkie.v1.DocEvent.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.DocEvent;
  return proto.yorkie.v1.DocEvent.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.DocEvent} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.DocEvent}
 */
proto.yorkie.v1.DocEvent.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.yorkie.v1.DocEventType} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setPublisher(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.DocEvent.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.DocEvent.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.DocEvent} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.DocEvent.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getPublisher();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional DocEventType type = 1;
 * @return {!proto.yorkie.v1.DocEventType}
 */
proto.yorkie.v1.DocEvent.prototype.getType = function() {
  return /** @type {!proto.yorkie.v1.DocEventType} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.yorkie.v1.DocEventType} value
 * @return {!proto.yorkie.v1.DocEvent} returns this
 */
proto.yorkie.v1.DocEvent.prototype.setType = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional string publisher = 2;
 * @return {string}
 */
proto.yorkie.v1.DocEvent.prototype.getPublisher = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.DocEvent} returns this
 */
proto.yorkie.v1.DocEvent.prototype.setPublisher = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * @enum {number}
 */
proto.yorkie.v1.ValueType = {
  VALUE_TYPE_NULL: 0,
  VALUE_TYPE_BOOLEAN: 1,
  VALUE_TYPE_INTEGER: 2,
  VALUE_TYPE_LONG: 3,
  VALUE_TYPE_DOUBLE: 4,
  VALUE_TYPE_STRING: 5,
  VALUE_TYPE_BYTES: 6,
  VALUE_TYPE_DATE: 7,
  VALUE_TYPE_JSON_OBJECT: 8,
  VALUE_TYPE_JSON_ARRAY: 9,
  VALUE_TYPE_TEXT: 10,
  VALUE_TYPE_INTEGER_CNT: 11,
  VALUE_TYPE_LONG_CNT: 12,
  VALUE_TYPE_TREE: 13
};

/**
 * @enum {number}
 */
proto.yorkie.v1.DocEventType = {
  DOC_EVENT_TYPE_DOCUMENT_CHANGED: 0,
  DOC_EVENT_TYPE_DOCUMENT_WATCHED: 1,
  DOC_EVENT_TYPE_DOCUMENT_UNWATCHED: 2
};

goog.object.extend(exports, proto.yorkie.v1);


/***/ }),

/***/ 458:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @fileoverview gRPC-Web generated client stub for yorkie.v1
 * @enhanceable
 * @public
 */

// Code generated by protoc-gen-grpc-web. DO NOT EDIT.
// versions:
// 	protoc-gen-grpc-web v1.4.2
// 	protoc              v3.20.3
// source: yorkie/v1/yorkie.proto


/* eslint-disable */
// @ts-nocheck



const grpc = {};
grpc.web = __webpack_require__(40);


var yorkie_v1_resources_pb = __webpack_require__(646)
const proto = {};
proto.yorkie = {};
proto.yorkie.v1 = __webpack_require__(176);

/**
 * @param {string} hostname
 * @param {?Object} credentials
 * @param {?grpc.web.ClientOptions} options
 * @constructor
 * @struct
 * @final
 */
proto.yorkie.v1.YorkieServiceClient =
    function(hostname, credentials, options) {
  if (!options) options = {};
  options.format = 'text';

  /**
   * @private @const {!grpc.web.GrpcWebClientBase} The client
   */
  this.client_ = new grpc.web.GrpcWebClientBase(options);

  /**
   * @private @const {string} The hostname
   */
  this.hostname_ = hostname.replace(/\/+$/, '');

};


/**
 * @param {string} hostname
 * @param {?Object} credentials
 * @param {?grpc.web.ClientOptions} options
 * @constructor
 * @struct
 * @final
 */
proto.yorkie.v1.YorkieServicePromiseClient =
    function(hostname, credentials, options) {
  if (!options) options = {};
  options.format = 'text';

  /**
   * @private @const {!grpc.web.GrpcWebClientBase} The client
   */
  this.client_ = new grpc.web.GrpcWebClientBase(options);

  /**
   * @private @const {string} The hostname
   */
  this.hostname_ = hostname.replace(/\/+$/, '');

};


/**
 * @const
 * @type {!grpc.web.MethodDescriptor<
 *   !proto.yorkie.v1.ActivateClientRequest,
 *   !proto.yorkie.v1.ActivateClientResponse>}
 */
const methodDescriptor_YorkieService_ActivateClient = new grpc.web.MethodDescriptor(
  '/yorkie.v1.YorkieService/ActivateClient',
  grpc.web.MethodType.UNARY,
  proto.yorkie.v1.ActivateClientRequest,
  proto.yorkie.v1.ActivateClientResponse,
  /**
   * @param {!proto.yorkie.v1.ActivateClientRequest} request
   * @return {!Uint8Array}
   */
  function(request) {
    return request.serializeBinary();
  },
  proto.yorkie.v1.ActivateClientResponse.deserializeBinary
);


/**
 * @param {!proto.yorkie.v1.ActivateClientRequest} request The
 *     request proto
 * @param {?Object<string, string>} metadata User defined
 *     call metadata
 * @param {function(?grpc.web.RpcError, ?proto.yorkie.v1.ActivateClientResponse)}
 *     callback The callback function(error, response)
 * @return {!grpc.web.ClientReadableStream<!proto.yorkie.v1.ActivateClientResponse>|undefined}
 *     The XHR Node Readable Stream
 */
proto.yorkie.v1.YorkieServiceClient.prototype.activateClient =
    function(request, metadata, callback) {
  return this.client_.rpcCall(this.hostname_ +
      '/yorkie.v1.YorkieService/ActivateClient',
      request,
      metadata || {},
      methodDescriptor_YorkieService_ActivateClient,
      callback);
};


/**
 * @param {!proto.yorkie.v1.ActivateClientRequest} request The
 *     request proto
 * @param {?Object<string, string>=} metadata User defined
 *     call metadata
 * @return {!Promise<!proto.yorkie.v1.ActivateClientResponse>}
 *     Promise that resolves to the response
 */
proto.yorkie.v1.YorkieServicePromiseClient.prototype.activateClient =
    function(request, metadata) {
  return this.client_.unaryCall(this.hostname_ +
      '/yorkie.v1.YorkieService/ActivateClient',
      request,
      metadata || {},
      methodDescriptor_YorkieService_ActivateClient);
};


/**
 * @const
 * @type {!grpc.web.MethodDescriptor<
 *   !proto.yorkie.v1.DeactivateClientRequest,
 *   !proto.yorkie.v1.DeactivateClientResponse>}
 */
const methodDescriptor_YorkieService_DeactivateClient = new grpc.web.MethodDescriptor(
  '/yorkie.v1.YorkieService/DeactivateClient',
  grpc.web.MethodType.UNARY,
  proto.yorkie.v1.DeactivateClientRequest,
  proto.yorkie.v1.DeactivateClientResponse,
  /**
   * @param {!proto.yorkie.v1.DeactivateClientRequest} request
   * @return {!Uint8Array}
   */
  function(request) {
    return request.serializeBinary();
  },
  proto.yorkie.v1.DeactivateClientResponse.deserializeBinary
);


/**
 * @param {!proto.yorkie.v1.DeactivateClientRequest} request The
 *     request proto
 * @param {?Object<string, string>} metadata User defined
 *     call metadata
 * @param {function(?grpc.web.RpcError, ?proto.yorkie.v1.DeactivateClientResponse)}
 *     callback The callback function(error, response)
 * @return {!grpc.web.ClientReadableStream<!proto.yorkie.v1.DeactivateClientResponse>|undefined}
 *     The XHR Node Readable Stream
 */
proto.yorkie.v1.YorkieServiceClient.prototype.deactivateClient =
    function(request, metadata, callback) {
  return this.client_.rpcCall(this.hostname_ +
      '/yorkie.v1.YorkieService/DeactivateClient',
      request,
      metadata || {},
      methodDescriptor_YorkieService_DeactivateClient,
      callback);
};


/**
 * @param {!proto.yorkie.v1.DeactivateClientRequest} request The
 *     request proto
 * @param {?Object<string, string>=} metadata User defined
 *     call metadata
 * @return {!Promise<!proto.yorkie.v1.DeactivateClientResponse>}
 *     Promise that resolves to the response
 */
proto.yorkie.v1.YorkieServicePromiseClient.prototype.deactivateClient =
    function(request, metadata) {
  return this.client_.unaryCall(this.hostname_ +
      '/yorkie.v1.YorkieService/DeactivateClient',
      request,
      metadata || {},
      methodDescriptor_YorkieService_DeactivateClient);
};


/**
 * @const
 * @type {!grpc.web.MethodDescriptor<
 *   !proto.yorkie.v1.AttachDocumentRequest,
 *   !proto.yorkie.v1.AttachDocumentResponse>}
 */
const methodDescriptor_YorkieService_AttachDocument = new grpc.web.MethodDescriptor(
  '/yorkie.v1.YorkieService/AttachDocument',
  grpc.web.MethodType.UNARY,
  proto.yorkie.v1.AttachDocumentRequest,
  proto.yorkie.v1.AttachDocumentResponse,
  /**
   * @param {!proto.yorkie.v1.AttachDocumentRequest} request
   * @return {!Uint8Array}
   */
  function(request) {
    return request.serializeBinary();
  },
  proto.yorkie.v1.AttachDocumentResponse.deserializeBinary
);


/**
 * @param {!proto.yorkie.v1.AttachDocumentRequest} request The
 *     request proto
 * @param {?Object<string, string>} metadata User defined
 *     call metadata
 * @param {function(?grpc.web.RpcError, ?proto.yorkie.v1.AttachDocumentResponse)}
 *     callback The callback function(error, response)
 * @return {!grpc.web.ClientReadableStream<!proto.yorkie.v1.AttachDocumentResponse>|undefined}
 *     The XHR Node Readable Stream
 */
proto.yorkie.v1.YorkieServiceClient.prototype.attachDocument =
    function(request, metadata, callback) {
  return this.client_.rpcCall(this.hostname_ +
      '/yorkie.v1.YorkieService/AttachDocument',
      request,
      metadata || {},
      methodDescriptor_YorkieService_AttachDocument,
      callback);
};


/**
 * @param {!proto.yorkie.v1.AttachDocumentRequest} request The
 *     request proto
 * @param {?Object<string, string>=} metadata User defined
 *     call metadata
 * @return {!Promise<!proto.yorkie.v1.AttachDocumentResponse>}
 *     Promise that resolves to the response
 */
proto.yorkie.v1.YorkieServicePromiseClient.prototype.attachDocument =
    function(request, metadata) {
  return this.client_.unaryCall(this.hostname_ +
      '/yorkie.v1.YorkieService/AttachDocument',
      request,
      metadata || {},
      methodDescriptor_YorkieService_AttachDocument);
};


/**
 * @const
 * @type {!grpc.web.MethodDescriptor<
 *   !proto.yorkie.v1.DetachDocumentRequest,
 *   !proto.yorkie.v1.DetachDocumentResponse>}
 */
const methodDescriptor_YorkieService_DetachDocument = new grpc.web.MethodDescriptor(
  '/yorkie.v1.YorkieService/DetachDocument',
  grpc.web.MethodType.UNARY,
  proto.yorkie.v1.DetachDocumentRequest,
  proto.yorkie.v1.DetachDocumentResponse,
  /**
   * @param {!proto.yorkie.v1.DetachDocumentRequest} request
   * @return {!Uint8Array}
   */
  function(request) {
    return request.serializeBinary();
  },
  proto.yorkie.v1.DetachDocumentResponse.deserializeBinary
);


/**
 * @param {!proto.yorkie.v1.DetachDocumentRequest} request The
 *     request proto
 * @param {?Object<string, string>} metadata User defined
 *     call metadata
 * @param {function(?grpc.web.RpcError, ?proto.yorkie.v1.DetachDocumentResponse)}
 *     callback The callback function(error, response)
 * @return {!grpc.web.ClientReadableStream<!proto.yorkie.v1.DetachDocumentResponse>|undefined}
 *     The XHR Node Readable Stream
 */
proto.yorkie.v1.YorkieServiceClient.prototype.detachDocument =
    function(request, metadata, callback) {
  return this.client_.rpcCall(this.hostname_ +
      '/yorkie.v1.YorkieService/DetachDocument',
      request,
      metadata || {},
      methodDescriptor_YorkieService_DetachDocument,
      callback);
};


/**
 * @param {!proto.yorkie.v1.DetachDocumentRequest} request The
 *     request proto
 * @param {?Object<string, string>=} metadata User defined
 *     call metadata
 * @return {!Promise<!proto.yorkie.v1.DetachDocumentResponse>}
 *     Promise that resolves to the response
 */
proto.yorkie.v1.YorkieServicePromiseClient.prototype.detachDocument =
    function(request, metadata) {
  return this.client_.unaryCall(this.hostname_ +
      '/yorkie.v1.YorkieService/DetachDocument',
      request,
      metadata || {},
      methodDescriptor_YorkieService_DetachDocument);
};


/**
 * @const
 * @type {!grpc.web.MethodDescriptor<
 *   !proto.yorkie.v1.RemoveDocumentRequest,
 *   !proto.yorkie.v1.RemoveDocumentResponse>}
 */
const methodDescriptor_YorkieService_RemoveDocument = new grpc.web.MethodDescriptor(
  '/yorkie.v1.YorkieService/RemoveDocument',
  grpc.web.MethodType.UNARY,
  proto.yorkie.v1.RemoveDocumentRequest,
  proto.yorkie.v1.RemoveDocumentResponse,
  /**
   * @param {!proto.yorkie.v1.RemoveDocumentRequest} request
   * @return {!Uint8Array}
   */
  function(request) {
    return request.serializeBinary();
  },
  proto.yorkie.v1.RemoveDocumentResponse.deserializeBinary
);


/**
 * @param {!proto.yorkie.v1.RemoveDocumentRequest} request The
 *     request proto
 * @param {?Object<string, string>} metadata User defined
 *     call metadata
 * @param {function(?grpc.web.RpcError, ?proto.yorkie.v1.RemoveDocumentResponse)}
 *     callback The callback function(error, response)
 * @return {!grpc.web.ClientReadableStream<!proto.yorkie.v1.RemoveDocumentResponse>|undefined}
 *     The XHR Node Readable Stream
 */
proto.yorkie.v1.YorkieServiceClient.prototype.removeDocument =
    function(request, metadata, callback) {
  return this.client_.rpcCall(this.hostname_ +
      '/yorkie.v1.YorkieService/RemoveDocument',
      request,
      metadata || {},
      methodDescriptor_YorkieService_RemoveDocument,
      callback);
};


/**
 * @param {!proto.yorkie.v1.RemoveDocumentRequest} request The
 *     request proto
 * @param {?Object<string, string>=} metadata User defined
 *     call metadata
 * @return {!Promise<!proto.yorkie.v1.RemoveDocumentResponse>}
 *     Promise that resolves to the response
 */
proto.yorkie.v1.YorkieServicePromiseClient.prototype.removeDocument =
    function(request, metadata) {
  return this.client_.unaryCall(this.hostname_ +
      '/yorkie.v1.YorkieService/RemoveDocument',
      request,
      metadata || {},
      methodDescriptor_YorkieService_RemoveDocument);
};


/**
 * @const
 * @type {!grpc.web.MethodDescriptor<
 *   !proto.yorkie.v1.PushPullChangesRequest,
 *   !proto.yorkie.v1.PushPullChangesResponse>}
 */
const methodDescriptor_YorkieService_PushPullChanges = new grpc.web.MethodDescriptor(
  '/yorkie.v1.YorkieService/PushPullChanges',
  grpc.web.MethodType.UNARY,
  proto.yorkie.v1.PushPullChangesRequest,
  proto.yorkie.v1.PushPullChangesResponse,
  /**
   * @param {!proto.yorkie.v1.PushPullChangesRequest} request
   * @return {!Uint8Array}
   */
  function(request) {
    return request.serializeBinary();
  },
  proto.yorkie.v1.PushPullChangesResponse.deserializeBinary
);


/**
 * @param {!proto.yorkie.v1.PushPullChangesRequest} request The
 *     request proto
 * @param {?Object<string, string>} metadata User defined
 *     call metadata
 * @param {function(?grpc.web.RpcError, ?proto.yorkie.v1.PushPullChangesResponse)}
 *     callback The callback function(error, response)
 * @return {!grpc.web.ClientReadableStream<!proto.yorkie.v1.PushPullChangesResponse>|undefined}
 *     The XHR Node Readable Stream
 */
proto.yorkie.v1.YorkieServiceClient.prototype.pushPullChanges =
    function(request, metadata, callback) {
  return this.client_.rpcCall(this.hostname_ +
      '/yorkie.v1.YorkieService/PushPullChanges',
      request,
      metadata || {},
      methodDescriptor_YorkieService_PushPullChanges,
      callback);
};


/**
 * @param {!proto.yorkie.v1.PushPullChangesRequest} request The
 *     request proto
 * @param {?Object<string, string>=} metadata User defined
 *     call metadata
 * @return {!Promise<!proto.yorkie.v1.PushPullChangesResponse>}
 *     Promise that resolves to the response
 */
proto.yorkie.v1.YorkieServicePromiseClient.prototype.pushPullChanges =
    function(request, metadata) {
  return this.client_.unaryCall(this.hostname_ +
      '/yorkie.v1.YorkieService/PushPullChanges',
      request,
      metadata || {},
      methodDescriptor_YorkieService_PushPullChanges);
};


/**
 * @const
 * @type {!grpc.web.MethodDescriptor<
 *   !proto.yorkie.v1.WatchDocumentRequest,
 *   !proto.yorkie.v1.WatchDocumentResponse>}
 */
const methodDescriptor_YorkieService_WatchDocument = new grpc.web.MethodDescriptor(
  '/yorkie.v1.YorkieService/WatchDocument',
  grpc.web.MethodType.SERVER_STREAMING,
  proto.yorkie.v1.WatchDocumentRequest,
  proto.yorkie.v1.WatchDocumentResponse,
  /**
   * @param {!proto.yorkie.v1.WatchDocumentRequest} request
   * @return {!Uint8Array}
   */
  function(request) {
    return request.serializeBinary();
  },
  proto.yorkie.v1.WatchDocumentResponse.deserializeBinary
);


/**
 * @param {!proto.yorkie.v1.WatchDocumentRequest} request The request proto
 * @param {?Object<string, string>=} metadata User defined
 *     call metadata
 * @return {!grpc.web.ClientReadableStream<!proto.yorkie.v1.WatchDocumentResponse>}
 *     The XHR Node Readable Stream
 */
proto.yorkie.v1.YorkieServiceClient.prototype.watchDocument =
    function(request, metadata) {
  return this.client_.serverStreaming(this.hostname_ +
      '/yorkie.v1.YorkieService/WatchDocument',
      request,
      metadata || {},
      methodDescriptor_YorkieService_WatchDocument);
};


/**
 * @param {!proto.yorkie.v1.WatchDocumentRequest} request The request proto
 * @param {?Object<string, string>=} metadata User defined
 *     call metadata
 * @return {!grpc.web.ClientReadableStream<!proto.yorkie.v1.WatchDocumentResponse>}
 *     The XHR Node Readable Stream
 */
proto.yorkie.v1.YorkieServicePromiseClient.prototype.watchDocument =
    function(request, metadata) {
  return this.client_.serverStreaming(this.hostname_ +
      '/yorkie.v1.YorkieService/WatchDocument',
      request,
      metadata || {},
      methodDescriptor_YorkieService_WatchDocument);
};


module.exports = proto.yorkie.v1;



/***/ }),

/***/ 176:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// source: yorkie/v1/yorkie.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = __webpack_require__(19);
var goog = jspb;
var global = (function() { return this || window || global || self || Function('return this')(); }).call(null);

var yorkie_v1_resources_pb = __webpack_require__(646);
goog.object.extend(proto, yorkie_v1_resources_pb);
goog.exportSymbol('proto.yorkie.v1.ActivateClientRequest', null, global);
goog.exportSymbol('proto.yorkie.v1.ActivateClientResponse', null, global);
goog.exportSymbol('proto.yorkie.v1.AttachDocumentRequest', null, global);
goog.exportSymbol('proto.yorkie.v1.AttachDocumentResponse', null, global);
goog.exportSymbol('proto.yorkie.v1.DeactivateClientRequest', null, global);
goog.exportSymbol('proto.yorkie.v1.DeactivateClientResponse', null, global);
goog.exportSymbol('proto.yorkie.v1.DetachDocumentRequest', null, global);
goog.exportSymbol('proto.yorkie.v1.DetachDocumentResponse', null, global);
goog.exportSymbol('proto.yorkie.v1.PushPullChangesRequest', null, global);
goog.exportSymbol('proto.yorkie.v1.PushPullChangesResponse', null, global);
goog.exportSymbol('proto.yorkie.v1.RemoveDocumentRequest', null, global);
goog.exportSymbol('proto.yorkie.v1.RemoveDocumentResponse', null, global);
goog.exportSymbol('proto.yorkie.v1.WatchDocumentRequest', null, global);
goog.exportSymbol('proto.yorkie.v1.WatchDocumentResponse', null, global);
goog.exportSymbol('proto.yorkie.v1.WatchDocumentResponse.BodyCase', null, global);
goog.exportSymbol('proto.yorkie.v1.WatchDocumentResponse.Initialization', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.ActivateClientRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.ActivateClientRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.ActivateClientRequest.displayName = 'proto.yorkie.v1.ActivateClientRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.ActivateClientResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.ActivateClientResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.ActivateClientResponse.displayName = 'proto.yorkie.v1.ActivateClientResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.DeactivateClientRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.DeactivateClientRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.DeactivateClientRequest.displayName = 'proto.yorkie.v1.DeactivateClientRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.DeactivateClientResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.DeactivateClientResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.DeactivateClientResponse.displayName = 'proto.yorkie.v1.DeactivateClientResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.AttachDocumentRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.AttachDocumentRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.AttachDocumentRequest.displayName = 'proto.yorkie.v1.AttachDocumentRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.AttachDocumentResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.AttachDocumentResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.AttachDocumentResponse.displayName = 'proto.yorkie.v1.AttachDocumentResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.DetachDocumentRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.DetachDocumentRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.DetachDocumentRequest.displayName = 'proto.yorkie.v1.DetachDocumentRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.DetachDocumentResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.DetachDocumentResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.DetachDocumentResponse.displayName = 'proto.yorkie.v1.DetachDocumentResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.WatchDocumentRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.WatchDocumentRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.WatchDocumentRequest.displayName = 'proto.yorkie.v1.WatchDocumentRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.WatchDocumentResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.yorkie.v1.WatchDocumentResponse.oneofGroups_);
};
goog.inherits(proto.yorkie.v1.WatchDocumentResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.WatchDocumentResponse.displayName = 'proto.yorkie.v1.WatchDocumentResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.WatchDocumentResponse.Initialization = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.yorkie.v1.WatchDocumentResponse.Initialization.repeatedFields_, null);
};
goog.inherits(proto.yorkie.v1.WatchDocumentResponse.Initialization, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.WatchDocumentResponse.Initialization.displayName = 'proto.yorkie.v1.WatchDocumentResponse.Initialization';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.RemoveDocumentRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.RemoveDocumentRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.RemoveDocumentRequest.displayName = 'proto.yorkie.v1.RemoveDocumentRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.RemoveDocumentResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.RemoveDocumentResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.RemoveDocumentResponse.displayName = 'proto.yorkie.v1.RemoveDocumentResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.PushPullChangesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.PushPullChangesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.PushPullChangesRequest.displayName = 'proto.yorkie.v1.PushPullChangesRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.yorkie.v1.PushPullChangesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.yorkie.v1.PushPullChangesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.yorkie.v1.PushPullChangesResponse.displayName = 'proto.yorkie.v1.PushPullChangesResponse';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.ActivateClientRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.ActivateClientRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.ActivateClientRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.ActivateClientRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    clientKey: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.ActivateClientRequest}
 */
proto.yorkie.v1.ActivateClientRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.ActivateClientRequest;
  return proto.yorkie.v1.ActivateClientRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.ActivateClientRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.ActivateClientRequest}
 */
proto.yorkie.v1.ActivateClientRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setClientKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.ActivateClientRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.ActivateClientRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.ActivateClientRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.ActivateClientRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getClientKey();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string client_key = 1;
 * @return {string}
 */
proto.yorkie.v1.ActivateClientRequest.prototype.getClientKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.ActivateClientRequest} returns this
 */
proto.yorkie.v1.ActivateClientRequest.prototype.setClientKey = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.ActivateClientResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.ActivateClientResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.ActivateClientResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.ActivateClientResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    clientId: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.ActivateClientResponse}
 */
proto.yorkie.v1.ActivateClientResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.ActivateClientResponse;
  return proto.yorkie.v1.ActivateClientResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.ActivateClientResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.ActivateClientResponse}
 */
proto.yorkie.v1.ActivateClientResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setClientId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.ActivateClientResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.ActivateClientResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.ActivateClientResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.ActivateClientResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getClientId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string client_id = 1;
 * @return {string}
 */
proto.yorkie.v1.ActivateClientResponse.prototype.getClientId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.ActivateClientResponse} returns this
 */
proto.yorkie.v1.ActivateClientResponse.prototype.setClientId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.DeactivateClientRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.DeactivateClientRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.DeactivateClientRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.DeactivateClientRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    clientId: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.DeactivateClientRequest}
 */
proto.yorkie.v1.DeactivateClientRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.DeactivateClientRequest;
  return proto.yorkie.v1.DeactivateClientRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.DeactivateClientRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.DeactivateClientRequest}
 */
proto.yorkie.v1.DeactivateClientRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setClientId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.DeactivateClientRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.DeactivateClientRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.DeactivateClientRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.DeactivateClientRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getClientId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string client_id = 1;
 * @return {string}
 */
proto.yorkie.v1.DeactivateClientRequest.prototype.getClientId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.DeactivateClientRequest} returns this
 */
proto.yorkie.v1.DeactivateClientRequest.prototype.setClientId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.DeactivateClientResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.DeactivateClientResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.DeactivateClientResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.DeactivateClientResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.DeactivateClientResponse}
 */
proto.yorkie.v1.DeactivateClientResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.DeactivateClientResponse;
  return proto.yorkie.v1.DeactivateClientResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.DeactivateClientResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.DeactivateClientResponse}
 */
proto.yorkie.v1.DeactivateClientResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.DeactivateClientResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.DeactivateClientResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.DeactivateClientResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.DeactivateClientResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.AttachDocumentRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.AttachDocumentRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.AttachDocumentRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.AttachDocumentRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    clientId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    changePack: (f = msg.getChangePack()) && yorkie_v1_resources_pb.ChangePack.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.AttachDocumentRequest}
 */
proto.yorkie.v1.AttachDocumentRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.AttachDocumentRequest;
  return proto.yorkie.v1.AttachDocumentRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.AttachDocumentRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.AttachDocumentRequest}
 */
proto.yorkie.v1.AttachDocumentRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setClientId(value);
      break;
    case 2:
      var value = new yorkie_v1_resources_pb.ChangePack;
      reader.readMessage(value,yorkie_v1_resources_pb.ChangePack.deserializeBinaryFromReader);
      msg.setChangePack(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.AttachDocumentRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.AttachDocumentRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.AttachDocumentRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.AttachDocumentRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getClientId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getChangePack();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      yorkie_v1_resources_pb.ChangePack.serializeBinaryToWriter
    );
  }
};


/**
 * optional string client_id = 1;
 * @return {string}
 */
proto.yorkie.v1.AttachDocumentRequest.prototype.getClientId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.AttachDocumentRequest} returns this
 */
proto.yorkie.v1.AttachDocumentRequest.prototype.setClientId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional ChangePack change_pack = 2;
 * @return {?proto.yorkie.v1.ChangePack}
 */
proto.yorkie.v1.AttachDocumentRequest.prototype.getChangePack = function() {
  return /** @type{?proto.yorkie.v1.ChangePack} */ (
    jspb.Message.getWrapperField(this, yorkie_v1_resources_pb.ChangePack, 2));
};


/**
 * @param {?proto.yorkie.v1.ChangePack|undefined} value
 * @return {!proto.yorkie.v1.AttachDocumentRequest} returns this
*/
proto.yorkie.v1.AttachDocumentRequest.prototype.setChangePack = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.AttachDocumentRequest} returns this
 */
proto.yorkie.v1.AttachDocumentRequest.prototype.clearChangePack = function() {
  return this.setChangePack(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.AttachDocumentRequest.prototype.hasChangePack = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.AttachDocumentResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.AttachDocumentResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.AttachDocumentResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.AttachDocumentResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    documentId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    changePack: (f = msg.getChangePack()) && yorkie_v1_resources_pb.ChangePack.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.AttachDocumentResponse}
 */
proto.yorkie.v1.AttachDocumentResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.AttachDocumentResponse;
  return proto.yorkie.v1.AttachDocumentResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.AttachDocumentResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.AttachDocumentResponse}
 */
proto.yorkie.v1.AttachDocumentResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setDocumentId(value);
      break;
    case 2:
      var value = new yorkie_v1_resources_pb.ChangePack;
      reader.readMessage(value,yorkie_v1_resources_pb.ChangePack.deserializeBinaryFromReader);
      msg.setChangePack(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.AttachDocumentResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.AttachDocumentResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.AttachDocumentResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.AttachDocumentResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDocumentId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getChangePack();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      yorkie_v1_resources_pb.ChangePack.serializeBinaryToWriter
    );
  }
};


/**
 * optional string document_id = 1;
 * @return {string}
 */
proto.yorkie.v1.AttachDocumentResponse.prototype.getDocumentId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.AttachDocumentResponse} returns this
 */
proto.yorkie.v1.AttachDocumentResponse.prototype.setDocumentId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional ChangePack change_pack = 2;
 * @return {?proto.yorkie.v1.ChangePack}
 */
proto.yorkie.v1.AttachDocumentResponse.prototype.getChangePack = function() {
  return /** @type{?proto.yorkie.v1.ChangePack} */ (
    jspb.Message.getWrapperField(this, yorkie_v1_resources_pb.ChangePack, 2));
};


/**
 * @param {?proto.yorkie.v1.ChangePack|undefined} value
 * @return {!proto.yorkie.v1.AttachDocumentResponse} returns this
*/
proto.yorkie.v1.AttachDocumentResponse.prototype.setChangePack = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.AttachDocumentResponse} returns this
 */
proto.yorkie.v1.AttachDocumentResponse.prototype.clearChangePack = function() {
  return this.setChangePack(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.AttachDocumentResponse.prototype.hasChangePack = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.DetachDocumentRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.DetachDocumentRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.DetachDocumentRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.DetachDocumentRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    clientId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    documentId: jspb.Message.getFieldWithDefault(msg, 2, ""),
    changePack: (f = msg.getChangePack()) && yorkie_v1_resources_pb.ChangePack.toObject(includeInstance, f),
    removeIfNotAttached: jspb.Message.getBooleanFieldWithDefault(msg, 4, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.DetachDocumentRequest}
 */
proto.yorkie.v1.DetachDocumentRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.DetachDocumentRequest;
  return proto.yorkie.v1.DetachDocumentRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.DetachDocumentRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.DetachDocumentRequest}
 */
proto.yorkie.v1.DetachDocumentRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setClientId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setDocumentId(value);
      break;
    case 3:
      var value = new yorkie_v1_resources_pb.ChangePack;
      reader.readMessage(value,yorkie_v1_resources_pb.ChangePack.deserializeBinaryFromReader);
      msg.setChangePack(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRemoveIfNotAttached(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.DetachDocumentRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.DetachDocumentRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.DetachDocumentRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.DetachDocumentRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getClientId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getDocumentId();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getChangePack();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      yorkie_v1_resources_pb.ChangePack.serializeBinaryToWriter
    );
  }
  f = message.getRemoveIfNotAttached();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
};


/**
 * optional string client_id = 1;
 * @return {string}
 */
proto.yorkie.v1.DetachDocumentRequest.prototype.getClientId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.DetachDocumentRequest} returns this
 */
proto.yorkie.v1.DetachDocumentRequest.prototype.setClientId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string document_id = 2;
 * @return {string}
 */
proto.yorkie.v1.DetachDocumentRequest.prototype.getDocumentId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.DetachDocumentRequest} returns this
 */
proto.yorkie.v1.DetachDocumentRequest.prototype.setDocumentId = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional ChangePack change_pack = 3;
 * @return {?proto.yorkie.v1.ChangePack}
 */
proto.yorkie.v1.DetachDocumentRequest.prototype.getChangePack = function() {
  return /** @type{?proto.yorkie.v1.ChangePack} */ (
    jspb.Message.getWrapperField(this, yorkie_v1_resources_pb.ChangePack, 3));
};


/**
 * @param {?proto.yorkie.v1.ChangePack|undefined} value
 * @return {!proto.yorkie.v1.DetachDocumentRequest} returns this
*/
proto.yorkie.v1.DetachDocumentRequest.prototype.setChangePack = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.DetachDocumentRequest} returns this
 */
proto.yorkie.v1.DetachDocumentRequest.prototype.clearChangePack = function() {
  return this.setChangePack(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.DetachDocumentRequest.prototype.hasChangePack = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bool remove_if_not_attached = 4;
 * @return {boolean}
 */
proto.yorkie.v1.DetachDocumentRequest.prototype.getRemoveIfNotAttached = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 4, false));
};


/**
 * @param {boolean} value
 * @return {!proto.yorkie.v1.DetachDocumentRequest} returns this
 */
proto.yorkie.v1.DetachDocumentRequest.prototype.setRemoveIfNotAttached = function(value) {
  return jspb.Message.setProto3BooleanField(this, 4, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.DetachDocumentResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.DetachDocumentResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.DetachDocumentResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.DetachDocumentResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    changePack: (f = msg.getChangePack()) && yorkie_v1_resources_pb.ChangePack.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.DetachDocumentResponse}
 */
proto.yorkie.v1.DetachDocumentResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.DetachDocumentResponse;
  return proto.yorkie.v1.DetachDocumentResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.DetachDocumentResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.DetachDocumentResponse}
 */
proto.yorkie.v1.DetachDocumentResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 2:
      var value = new yorkie_v1_resources_pb.ChangePack;
      reader.readMessage(value,yorkie_v1_resources_pb.ChangePack.deserializeBinaryFromReader);
      msg.setChangePack(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.DetachDocumentResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.DetachDocumentResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.DetachDocumentResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.DetachDocumentResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChangePack();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      yorkie_v1_resources_pb.ChangePack.serializeBinaryToWriter
    );
  }
};


/**
 * optional ChangePack change_pack = 2;
 * @return {?proto.yorkie.v1.ChangePack}
 */
proto.yorkie.v1.DetachDocumentResponse.prototype.getChangePack = function() {
  return /** @type{?proto.yorkie.v1.ChangePack} */ (
    jspb.Message.getWrapperField(this, yorkie_v1_resources_pb.ChangePack, 2));
};


/**
 * @param {?proto.yorkie.v1.ChangePack|undefined} value
 * @return {!proto.yorkie.v1.DetachDocumentResponse} returns this
*/
proto.yorkie.v1.DetachDocumentResponse.prototype.setChangePack = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.DetachDocumentResponse} returns this
 */
proto.yorkie.v1.DetachDocumentResponse.prototype.clearChangePack = function() {
  return this.setChangePack(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.DetachDocumentResponse.prototype.hasChangePack = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.WatchDocumentRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.WatchDocumentRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.WatchDocumentRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.WatchDocumentRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    clientId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    documentId: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.WatchDocumentRequest}
 */
proto.yorkie.v1.WatchDocumentRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.WatchDocumentRequest;
  return proto.yorkie.v1.WatchDocumentRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.WatchDocumentRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.WatchDocumentRequest}
 */
proto.yorkie.v1.WatchDocumentRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setClientId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setDocumentId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.WatchDocumentRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.WatchDocumentRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.WatchDocumentRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.WatchDocumentRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getClientId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getDocumentId();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string client_id = 1;
 * @return {string}
 */
proto.yorkie.v1.WatchDocumentRequest.prototype.getClientId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.WatchDocumentRequest} returns this
 */
proto.yorkie.v1.WatchDocumentRequest.prototype.setClientId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string document_id = 2;
 * @return {string}
 */
proto.yorkie.v1.WatchDocumentRequest.prototype.getDocumentId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.WatchDocumentRequest} returns this
 */
proto.yorkie.v1.WatchDocumentRequest.prototype.setDocumentId = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.yorkie.v1.WatchDocumentResponse.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.yorkie.v1.WatchDocumentResponse.BodyCase = {
  BODY_NOT_SET: 0,
  INITIALIZATION: 1,
  EVENT: 2
};

/**
 * @return {proto.yorkie.v1.WatchDocumentResponse.BodyCase}
 */
proto.yorkie.v1.WatchDocumentResponse.prototype.getBodyCase = function() {
  return /** @type {proto.yorkie.v1.WatchDocumentResponse.BodyCase} */(jspb.Message.computeOneofCase(this, proto.yorkie.v1.WatchDocumentResponse.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.WatchDocumentResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.WatchDocumentResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.WatchDocumentResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.WatchDocumentResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    initialization: (f = msg.getInitialization()) && proto.yorkie.v1.WatchDocumentResponse.Initialization.toObject(includeInstance, f),
    event: (f = msg.getEvent()) && yorkie_v1_resources_pb.DocEvent.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.WatchDocumentResponse}
 */
proto.yorkie.v1.WatchDocumentResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.WatchDocumentResponse;
  return proto.yorkie.v1.WatchDocumentResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.WatchDocumentResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.WatchDocumentResponse}
 */
proto.yorkie.v1.WatchDocumentResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.yorkie.v1.WatchDocumentResponse.Initialization;
      reader.readMessage(value,proto.yorkie.v1.WatchDocumentResponse.Initialization.deserializeBinaryFromReader);
      msg.setInitialization(value);
      break;
    case 2:
      var value = new yorkie_v1_resources_pb.DocEvent;
      reader.readMessage(value,yorkie_v1_resources_pb.DocEvent.deserializeBinaryFromReader);
      msg.setEvent(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.WatchDocumentResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.WatchDocumentResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.WatchDocumentResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.WatchDocumentResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getInitialization();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.yorkie.v1.WatchDocumentResponse.Initialization.serializeBinaryToWriter
    );
  }
  f = message.getEvent();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      yorkie_v1_resources_pb.DocEvent.serializeBinaryToWriter
    );
  }
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.yorkie.v1.WatchDocumentResponse.Initialization.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.WatchDocumentResponse.Initialization.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.WatchDocumentResponse.Initialization.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.WatchDocumentResponse.Initialization} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.WatchDocumentResponse.Initialization.toObject = function(includeInstance, msg) {
  var f, obj = {
    clientIdsList: (f = jspb.Message.getRepeatedField(msg, 1)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.WatchDocumentResponse.Initialization}
 */
proto.yorkie.v1.WatchDocumentResponse.Initialization.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.WatchDocumentResponse.Initialization;
  return proto.yorkie.v1.WatchDocumentResponse.Initialization.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.WatchDocumentResponse.Initialization} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.WatchDocumentResponse.Initialization}
 */
proto.yorkie.v1.WatchDocumentResponse.Initialization.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.addClientIds(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.WatchDocumentResponse.Initialization.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.WatchDocumentResponse.Initialization.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.WatchDocumentResponse.Initialization} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.WatchDocumentResponse.Initialization.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getClientIdsList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      1,
      f
    );
  }
};


/**
 * repeated string client_ids = 1;
 * @return {!Array<string>}
 */
proto.yorkie.v1.WatchDocumentResponse.Initialization.prototype.getClientIdsList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 1));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.yorkie.v1.WatchDocumentResponse.Initialization} returns this
 */
proto.yorkie.v1.WatchDocumentResponse.Initialization.prototype.setClientIdsList = function(value) {
  return jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.yorkie.v1.WatchDocumentResponse.Initialization} returns this
 */
proto.yorkie.v1.WatchDocumentResponse.Initialization.prototype.addClientIds = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.yorkie.v1.WatchDocumentResponse.Initialization} returns this
 */
proto.yorkie.v1.WatchDocumentResponse.Initialization.prototype.clearClientIdsList = function() {
  return this.setClientIdsList([]);
};


/**
 * optional Initialization initialization = 1;
 * @return {?proto.yorkie.v1.WatchDocumentResponse.Initialization}
 */
proto.yorkie.v1.WatchDocumentResponse.prototype.getInitialization = function() {
  return /** @type{?proto.yorkie.v1.WatchDocumentResponse.Initialization} */ (
    jspb.Message.getWrapperField(this, proto.yorkie.v1.WatchDocumentResponse.Initialization, 1));
};


/**
 * @param {?proto.yorkie.v1.WatchDocumentResponse.Initialization|undefined} value
 * @return {!proto.yorkie.v1.WatchDocumentResponse} returns this
*/
proto.yorkie.v1.WatchDocumentResponse.prototype.setInitialization = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.yorkie.v1.WatchDocumentResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.WatchDocumentResponse} returns this
 */
proto.yorkie.v1.WatchDocumentResponse.prototype.clearInitialization = function() {
  return this.setInitialization(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.WatchDocumentResponse.prototype.hasInitialization = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional DocEvent event = 2;
 * @return {?proto.yorkie.v1.DocEvent}
 */
proto.yorkie.v1.WatchDocumentResponse.prototype.getEvent = function() {
  return /** @type{?proto.yorkie.v1.DocEvent} */ (
    jspb.Message.getWrapperField(this, yorkie_v1_resources_pb.DocEvent, 2));
};


/**
 * @param {?proto.yorkie.v1.DocEvent|undefined} value
 * @return {!proto.yorkie.v1.WatchDocumentResponse} returns this
*/
proto.yorkie.v1.WatchDocumentResponse.prototype.setEvent = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.yorkie.v1.WatchDocumentResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.WatchDocumentResponse} returns this
 */
proto.yorkie.v1.WatchDocumentResponse.prototype.clearEvent = function() {
  return this.setEvent(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.WatchDocumentResponse.prototype.hasEvent = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.RemoveDocumentRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.RemoveDocumentRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.RemoveDocumentRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.RemoveDocumentRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    clientId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    documentId: jspb.Message.getFieldWithDefault(msg, 2, ""),
    changePack: (f = msg.getChangePack()) && yorkie_v1_resources_pb.ChangePack.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.RemoveDocumentRequest}
 */
proto.yorkie.v1.RemoveDocumentRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.RemoveDocumentRequest;
  return proto.yorkie.v1.RemoveDocumentRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.RemoveDocumentRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.RemoveDocumentRequest}
 */
proto.yorkie.v1.RemoveDocumentRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setClientId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setDocumentId(value);
      break;
    case 3:
      var value = new yorkie_v1_resources_pb.ChangePack;
      reader.readMessage(value,yorkie_v1_resources_pb.ChangePack.deserializeBinaryFromReader);
      msg.setChangePack(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.RemoveDocumentRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.RemoveDocumentRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.RemoveDocumentRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.RemoveDocumentRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getClientId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getDocumentId();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getChangePack();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      yorkie_v1_resources_pb.ChangePack.serializeBinaryToWriter
    );
  }
};


/**
 * optional string client_id = 1;
 * @return {string}
 */
proto.yorkie.v1.RemoveDocumentRequest.prototype.getClientId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.RemoveDocumentRequest} returns this
 */
proto.yorkie.v1.RemoveDocumentRequest.prototype.setClientId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string document_id = 2;
 * @return {string}
 */
proto.yorkie.v1.RemoveDocumentRequest.prototype.getDocumentId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.RemoveDocumentRequest} returns this
 */
proto.yorkie.v1.RemoveDocumentRequest.prototype.setDocumentId = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional ChangePack change_pack = 3;
 * @return {?proto.yorkie.v1.ChangePack}
 */
proto.yorkie.v1.RemoveDocumentRequest.prototype.getChangePack = function() {
  return /** @type{?proto.yorkie.v1.ChangePack} */ (
    jspb.Message.getWrapperField(this, yorkie_v1_resources_pb.ChangePack, 3));
};


/**
 * @param {?proto.yorkie.v1.ChangePack|undefined} value
 * @return {!proto.yorkie.v1.RemoveDocumentRequest} returns this
*/
proto.yorkie.v1.RemoveDocumentRequest.prototype.setChangePack = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.RemoveDocumentRequest} returns this
 */
proto.yorkie.v1.RemoveDocumentRequest.prototype.clearChangePack = function() {
  return this.setChangePack(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.RemoveDocumentRequest.prototype.hasChangePack = function() {
  return jspb.Message.getField(this, 3) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.RemoveDocumentResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.RemoveDocumentResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.RemoveDocumentResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.RemoveDocumentResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    changePack: (f = msg.getChangePack()) && yorkie_v1_resources_pb.ChangePack.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.RemoveDocumentResponse}
 */
proto.yorkie.v1.RemoveDocumentResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.RemoveDocumentResponse;
  return proto.yorkie.v1.RemoveDocumentResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.RemoveDocumentResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.RemoveDocumentResponse}
 */
proto.yorkie.v1.RemoveDocumentResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new yorkie_v1_resources_pb.ChangePack;
      reader.readMessage(value,yorkie_v1_resources_pb.ChangePack.deserializeBinaryFromReader);
      msg.setChangePack(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.RemoveDocumentResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.RemoveDocumentResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.RemoveDocumentResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.RemoveDocumentResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChangePack();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      yorkie_v1_resources_pb.ChangePack.serializeBinaryToWriter
    );
  }
};


/**
 * optional ChangePack change_pack = 1;
 * @return {?proto.yorkie.v1.ChangePack}
 */
proto.yorkie.v1.RemoveDocumentResponse.prototype.getChangePack = function() {
  return /** @type{?proto.yorkie.v1.ChangePack} */ (
    jspb.Message.getWrapperField(this, yorkie_v1_resources_pb.ChangePack, 1));
};


/**
 * @param {?proto.yorkie.v1.ChangePack|undefined} value
 * @return {!proto.yorkie.v1.RemoveDocumentResponse} returns this
*/
proto.yorkie.v1.RemoveDocumentResponse.prototype.setChangePack = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.RemoveDocumentResponse} returns this
 */
proto.yorkie.v1.RemoveDocumentResponse.prototype.clearChangePack = function() {
  return this.setChangePack(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.RemoveDocumentResponse.prototype.hasChangePack = function() {
  return jspb.Message.getField(this, 1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.PushPullChangesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.PushPullChangesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.PushPullChangesRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.PushPullChangesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    clientId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    documentId: jspb.Message.getFieldWithDefault(msg, 2, ""),
    changePack: (f = msg.getChangePack()) && yorkie_v1_resources_pb.ChangePack.toObject(includeInstance, f),
    pushOnly: jspb.Message.getBooleanFieldWithDefault(msg, 4, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.PushPullChangesRequest}
 */
proto.yorkie.v1.PushPullChangesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.PushPullChangesRequest;
  return proto.yorkie.v1.PushPullChangesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.PushPullChangesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.PushPullChangesRequest}
 */
proto.yorkie.v1.PushPullChangesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setClientId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setDocumentId(value);
      break;
    case 3:
      var value = new yorkie_v1_resources_pb.ChangePack;
      reader.readMessage(value,yorkie_v1_resources_pb.ChangePack.deserializeBinaryFromReader);
      msg.setChangePack(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPushOnly(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.PushPullChangesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.PushPullChangesRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.PushPullChangesRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.PushPullChangesRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getClientId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getDocumentId();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getChangePack();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      yorkie_v1_resources_pb.ChangePack.serializeBinaryToWriter
    );
  }
  f = message.getPushOnly();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
};


/**
 * optional string client_id = 1;
 * @return {string}
 */
proto.yorkie.v1.PushPullChangesRequest.prototype.getClientId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.PushPullChangesRequest} returns this
 */
proto.yorkie.v1.PushPullChangesRequest.prototype.setClientId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string document_id = 2;
 * @return {string}
 */
proto.yorkie.v1.PushPullChangesRequest.prototype.getDocumentId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.yorkie.v1.PushPullChangesRequest} returns this
 */
proto.yorkie.v1.PushPullChangesRequest.prototype.setDocumentId = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional ChangePack change_pack = 3;
 * @return {?proto.yorkie.v1.ChangePack}
 */
proto.yorkie.v1.PushPullChangesRequest.prototype.getChangePack = function() {
  return /** @type{?proto.yorkie.v1.ChangePack} */ (
    jspb.Message.getWrapperField(this, yorkie_v1_resources_pb.ChangePack, 3));
};


/**
 * @param {?proto.yorkie.v1.ChangePack|undefined} value
 * @return {!proto.yorkie.v1.PushPullChangesRequest} returns this
*/
proto.yorkie.v1.PushPullChangesRequest.prototype.setChangePack = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.PushPullChangesRequest} returns this
 */
proto.yorkie.v1.PushPullChangesRequest.prototype.clearChangePack = function() {
  return this.setChangePack(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.PushPullChangesRequest.prototype.hasChangePack = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bool push_only = 4;
 * @return {boolean}
 */
proto.yorkie.v1.PushPullChangesRequest.prototype.getPushOnly = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 4, false));
};


/**
 * @param {boolean} value
 * @return {!proto.yorkie.v1.PushPullChangesRequest} returns this
 */
proto.yorkie.v1.PushPullChangesRequest.prototype.setPushOnly = function(value) {
  return jspb.Message.setProto3BooleanField(this, 4, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.yorkie.v1.PushPullChangesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.yorkie.v1.PushPullChangesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.yorkie.v1.PushPullChangesResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.PushPullChangesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    changePack: (f = msg.getChangePack()) && yorkie_v1_resources_pb.ChangePack.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.yorkie.v1.PushPullChangesResponse}
 */
proto.yorkie.v1.PushPullChangesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.yorkie.v1.PushPullChangesResponse;
  return proto.yorkie.v1.PushPullChangesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.yorkie.v1.PushPullChangesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.yorkie.v1.PushPullChangesResponse}
 */
proto.yorkie.v1.PushPullChangesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new yorkie_v1_resources_pb.ChangePack;
      reader.readMessage(value,yorkie_v1_resources_pb.ChangePack.deserializeBinaryFromReader);
      msg.setChangePack(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.yorkie.v1.PushPullChangesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.yorkie.v1.PushPullChangesResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.yorkie.v1.PushPullChangesResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.yorkie.v1.PushPullChangesResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChangePack();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      yorkie_v1_resources_pb.ChangePack.serializeBinaryToWriter
    );
  }
};


/**
 * optional ChangePack change_pack = 1;
 * @return {?proto.yorkie.v1.ChangePack}
 */
proto.yorkie.v1.PushPullChangesResponse.prototype.getChangePack = function() {
  return /** @type{?proto.yorkie.v1.ChangePack} */ (
    jspb.Message.getWrapperField(this, yorkie_v1_resources_pb.ChangePack, 1));
};


/**
 * @param {?proto.yorkie.v1.ChangePack|undefined} value
 * @return {!proto.yorkie.v1.PushPullChangesResponse} returns this
*/
proto.yorkie.v1.PushPullChangesResponse.prototype.setChangePack = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.yorkie.v1.PushPullChangesResponse} returns this
 */
proto.yorkie.v1.PushPullChangesResponse.prototype.clearChangePack = function() {
  return this.setChangePack(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.yorkie.v1.PushPullChangesResponse.prototype.hasChangePack = function() {
  return jspb.Message.getField(this, 1) != null;
};


goog.object.extend(exports, proto.yorkie.v1);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Change: () => (/* reexport */ Change),
  Client: () => (/* reexport */ Client),
  ClientEventType: () => (/* reexport */ ClientEventType),
  ClientStatus: () => (/* reexport */ ClientStatus),
  Counter: () => (/* reexport */ Counter),
  DocEventType: () => (/* reexport */ DocEventType),
  Document: () => (/* reexport */ Document),
  DocumentSyncResultType: () => (/* reexport */ DocumentSyncResultType),
  Primitive: () => (/* reexport */ Primitive),
  StreamConnectionStatus: () => (/* reexport */ StreamConnectionStatus),
  SyncMode: () => (/* reexport */ SyncMode),
  Text: () => (/* reexport */ Text),
  TimeTicket: () => (/* reexport */ TimeTicket),
  Tree: () => (/* reexport */ Tree),
  converter: () => (/* reexport */ converter),
  "default": () => (/* binding */ src_yorkie)
});

;// CONCATENATED MODULE: ./src/util/logger.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Trivial"] = 0] = "Trivial";
    LogLevel[LogLevel["Debug"] = 1] = "Debug";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Warn"] = 3] = "Warn";
    LogLevel[LogLevel["Error"] = 4] = "Error";
    LogLevel[LogLevel["Fatal"] = 5] = "Fatal";
})(LogLevel || (LogLevel = {}));
let level = LogLevel.Info;
/**
 * `setLogLevel` sets log level.
 */
function setLogLevel(l) {
    level = l;
}
const logger = {
    trivial: (...messages) => {
        if (level > LogLevel.Trivial) {
            return;
        }
        if (typeof console != 'undefined') {
            console.log('YORKIE T:', ...messages);
        }
    },
    debug: (...messages) => {
        if (level > LogLevel.Debug) {
            return;
        }
        if (typeof console != 'undefined') {
            console.log('YORKIE D:', ...messages);
        }
    },
    info: (...messages) => {
        if (level > LogLevel.Info) {
            return;
        }
        if (typeof console != 'undefined') {
            console.log('YORKIE I:', ...messages);
        }
    },
    warn: (...messages) => {
        if (level > LogLevel.Warn) {
            return;
        }
        if (typeof console != 'undefined') {
            if (typeof console.warn !== 'undefined') {
                console.warn('YORKIE W:', ...messages);
            }
            else {
                console.log('YORKIE W:', ...messages);
            }
        }
    },
    error: (...messages) => {
        if (level > LogLevel.Error) {
            return;
        }
        if (typeof console != 'undefined') {
            if (typeof console.error !== 'undefined') {
                console.error('YORKIE E:', ...messages);
            }
            else {
                console.log('YORKIE E:', ...messages);
            }
        }
    },
    fatal: (message, ...messages) => {
        if (typeof console != 'undefined') {
            if (typeof console.error !== 'undefined') {
                console.error('YORKIE F:', ...messages);
            }
            else {
                console.log('YORKIE F:', ...messages);
            }
        }
        throw new Error(`YORKIE F: ${message}`);
    },
    isEnabled: (l) => {
        return level <= l;
    },
};

;// CONCATENATED MODULE: ./src/util/uuid.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * `uuid` generates uuid string
 * @see http://www.ietf.org/rfc/rfc4122.txt
 */
function uuid() {
    return 'xxxxxxxx-xxxx-4xxxy-xxxx-xxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        const r = (Math.random() * 16) | 0;
        const v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}

;// CONCATENATED MODULE: ./src/util/observable.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const Noop = () => {
    // Do nothing
};
/**
 * `ObserverProxy` is proxy of `Observer`.
 */
class ObserverProxy {
    constructor(executor) {
        this.finalized = false;
        this.observers = [];
        try {
            executor(this);
        }
        catch (error) {
            this.error(error);
        }
    }
    /**
     * `next` iterates next observer synchronously.
     */
    next(value) {
        this.forEachObserver((observer) => {
            observer.next(value);
        });
    }
    /**
     * `error` invoke error.
     */
    error(error) {
        this.forEachObserver((observer) => {
            observer.error(error);
        });
        this.close(error);
    }
    /**
     * `complete` completes observer.
     */
    complete() {
        this.forEachObserver((observer) => {
            observer.complete();
        });
        this.close();
    }
    /**
     * `subscribe` is a function for subscribing observer.
     */
    subscribe(nextOrObserver, error, complete) {
        let observer;
        if (!nextOrObserver) {
            logger.fatal('missing observer');
        }
        if (this.finalized) {
            logger.fatal('observable is finalized due to previous error');
        }
        if (typeof nextOrObserver === 'object') {
            observer = nextOrObserver;
        }
        else {
            observer = {
                next: nextOrObserver,
                error,
                complete,
            };
        }
        if (observer.next === undefined) {
            observer.next = Noop;
        }
        if (observer.error === undefined) {
            observer.error = Noop;
        }
        if (observer.complete === undefined) {
            observer.complete = Noop;
        }
        const id = uuid();
        const unsub = this.unsubscribeOne.bind(this, id);
        this.observers.push({
            subscriptionID: id,
            observer: observer,
        });
        if (this.finalized) {
            try {
                if (this.finalError) {
                    observer.error(this.finalError);
                }
                else {
                    observer.complete();
                }
            }
            catch (err) {
                // nothing
                logger.warn(err);
            }
        }
        return unsub;
    }
    unsubscribeOne(id) {
        var _a;
        this.observers = (_a = this.observers) === null || _a === void 0 ? void 0 : _a.filter((it) => it.subscriptionID !== id);
    }
    forEachObserver(fn) {
        if (this.finalized) {
            return;
        }
        for (let i = 0; i < this.observers.length; i++) {
            this.sendOne(i, fn);
        }
    }
    sendOne(i, fn) {
        if (this.observers !== undefined && this.observers[i] !== undefined) {
            try {
                fn(this.observers[i].observer);
            }
            catch (err) {
                logger.error(err);
            }
        }
    }
    close(err) {
        if (this.finalized) {
            return;
        }
        this.finalized = true;
        if (err !== undefined) {
            this.finalError = err;
        }
        this.observers = undefined;
    }
}
/**
 * `createObservable` creates a new instance of ObserverProxy
 * and subscribe the instance.
 */
function createObservable(executor) {
    const proxy = new ObserverProxy(executor);
    return {
        subscribe: proxy.subscribe.bind(proxy),
        getProxy: () => {
            return proxy;
        },
    };
}

// EXTERNAL MODULE: ./src/api/yorkie/v1/yorkie_pb.js
var yorkie_pb = __webpack_require__(176);
// EXTERNAL MODULE: ./src/api/yorkie/v1/resources_pb.js
var resources_pb = __webpack_require__(646);
;// CONCATENATED MODULE: ./node_modules/long/index.js
/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

// WebAssembly optimizations to do native i64 multiplication and divide
var wasm = null;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

  /**
   * The low 32 bits as a signed value.
   * @type {number}
   */
  this.low = low | 0;

  /**
   * The high 32 bits as a signed value.
   * @type {number}
   */
  this.high = high | 0;

  /**
   * Whether unsigned or not.
   * @type {boolean}
   */
  this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}

/**
 * @function
 * @param {*} value number
 * @returns {number}
 * @inner
 */
function ctz32(value) {
  var c = Math.clz32(value & -value);
  return value ? 31 - c : c;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
  var obj, cachedObj, cache;
  if (unsigned) {
    value >>>= 0;
    if (cache = (0 <= value && value < 256)) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, 0, true);
    if (cache)
      UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache = (-128 <= value && value < 128)) {
      cachedObj = INT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache)
      INT_CACHE[value] = obj;
    return obj;
  }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
  if (isNaN(value))
    return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0)
      return UZERO;
    if (value >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL)
      return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  if (value < 0)
    return fromNumber(-value, unsigned).neg();
  return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
  return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
  if (str.length === 0)
    throw Error('empty string');
  if (typeof unsigned === 'number') {
    // For goog.math.long compatibility
    radix = unsigned;
    unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
    return unsigned ? UZERO : ZERO;
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError('radix');

  var p;
  if ((p = str.indexOf('-')) > 0)
    throw Error('interior hyphen');
  else if (p === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  }

  // Do several (8) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = fromNumber(pow_dbl(radix, 8));

  var result = ZERO;
  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i),
      value = parseInt(str.substring(i, i + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
  if (typeof val === 'number')
    return fromNumber(val, unsigned);
  if (typeof val === 'string')
    return fromString(val, unsigned);
  // Throws for non-objects, converts non-instanceof Long:
  return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
  if (this.unsigned)
    return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @this {!Long}
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError('radix');
  if (this.isZero())
    return '0';
  if (this.isNegative()) { // Unsigned Longs are never negative
    if (this.eq(MIN_VALUE)) {
      // We need to change the Long value before it can be negated, so we remove
      // the bottom-most digit in this base and then recurse to do the rest.
      var radixLong = fromNumber(radix),
        div = this.div(radixLong),
        rem1 = div.mul(radixLong).sub(this);
      return div.toString(radix) + rem1.toInt().toString(radix);
    } else
      return '-' + this.neg().toString(radix);
  }

  // Do several (6) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
    rem = this;
  var result = '';
  while (true) {
    var remDiv = rem.div(radixToPower),
      intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
      digits = intval.toString(radix);
    rem = remDiv;
    if (rem.isZero())
      return digits + result;
    else {
      while (digits.length < 6)
        digits = '0' + digits;
      result = '' + digits + result;
    }
  }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @this {!Long}
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @this {!Long}
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @this {!Long}
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @this {!Long}
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative()) // Unsigned Longs are never negative
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val = this.high != 0 ? this.high : this.low;
  for (var bit = 31; bit > 0; bit--)
    if ((val & (1 << bit)) != 0)
      break;
  return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
  return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
  return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive or zero.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
  return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
  return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
    return false;
  return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
  return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.eq(other))
    return 0;
  var thisNeg = this.isNegative(),
    otherNeg = other.isNegative();
  if (thisNeg && !otherNeg)
    return -1;
  if (!thisNeg && otherNeg)
    return 1;
  // At this point the sign bits are the same
  if (!this.unsigned)
    return this.sub(other).isNegative() ? -1 : 1;
  // Both are positive if at least one is unsigned
  return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @this {!Long}
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
  if (!this.unsigned && this.eq(MIN_VALUE))
    return MIN_VALUE;
  return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
  if (!isLong(addend))
    addend = fromValue(addend);

  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

  var a48 = this.high >>> 16;
  var a32 = this.high & 0xFFFF;
  var a16 = this.low >>> 16;
  var a00 = this.low & 0xFFFF;

  var b48 = addend.high >>> 16;
  var b32 = addend.high & 0xFFFF;
  var b16 = addend.low >>> 16;
  var b00 = addend.low & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 + b48;
  c48 &= 0xFFFF;
  return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
  if (!isLong(subtrahend))
    subtrahend = fromValue(subtrahend);
  return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
  if (this.isZero())
    return this;
  if (!isLong(multiplier))
    multiplier = fromValue(multiplier);

  // use wasm support if present
  if (wasm) {
    var low = wasm["mul"](this.low,
      this.high,
      multiplier.low,
      multiplier.high);
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }

  if (multiplier.isZero())
    return this.unsigned ? UZERO : ZERO;
  if (this.eq(MIN_VALUE))
    return multiplier.isOdd() ? MIN_VALUE : ZERO;
  if (multiplier.eq(MIN_VALUE))
    return this.isOdd() ? MIN_VALUE : ZERO;

  if (this.isNegative()) {
    if (multiplier.isNegative())
      return this.neg().mul(multiplier.neg());
    else
      return this.neg().mul(multiplier).neg();
  } else if (multiplier.isNegative())
    return this.mul(multiplier.neg()).neg();

  // If both longs are small, use float multiplication
  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
  // We can skip products that would overflow.

  var a48 = this.high >>> 16;
  var a32 = this.high & 0xFFFF;
  var a16 = this.low >>> 16;
  var a00 = this.low & 0xFFFF;

  var b48 = multiplier.high >>> 16;
  var b32 = multiplier.high & 0xFFFF;
  var b16 = multiplier.low >>> 16;
  var b00 = multiplier.low & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 0xFFFF;
  return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @this {!Long}
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);
  if (divisor.isZero())
    throw Error('division by zero');

  // use wasm support if present
  if (wasm) {
    // guard against signed division overflow: the largest
    // negative number / -1 would be 1 larger than the largest
    // positive number, due to two's complement.
    if (!this.unsigned &&
      this.high === -0x80000000 &&
      divisor.low === -1 && divisor.high === -1) {
      // be consistent with non-wasm code path
      return this;
    }
    var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }

  if (this.isZero())
    return this.unsigned ? UZERO : ZERO;
  var approx, rem, res;
  if (!this.unsigned) {
    // This section is only relevant for signed longs and is derived from the
    // closure library as a whole.
    if (this.eq(MIN_VALUE)) {
      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
        return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
      else if (divisor.eq(MIN_VALUE))
        return ONE;
      else {
        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
        var halfThis = this.shr(1);
        approx = halfThis.div(divisor).shl(1);
        if (approx.eq(ZERO)) {
          return divisor.isNegative() ? ONE : NEG_ONE;
        } else {
          rem = this.sub(divisor.mul(approx));
          res = approx.add(rem.div(divisor));
          return res;
        }
      }
    } else if (divisor.eq(MIN_VALUE))
      return this.unsigned ? UZERO : ZERO;
    if (this.isNegative()) {
      if (divisor.isNegative())
        return this.neg().div(divisor.neg());
      return this.neg().div(divisor).neg();
    } else if (divisor.isNegative())
      return this.div(divisor.neg()).neg();
    res = ZERO;
  } else {
    // The algorithm below has not been made for unsigned longs. It's therefore
    // required to take special care of the MSB prior to running it.
    if (!divisor.unsigned)
      divisor = divisor.toUnsigned();
    if (divisor.gt(this))
      return UZERO;
    if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
      return UONE;
    res = UZERO;
  }

  // Repeat the following until the remainder is less than other:  find a
  // floating-point that approximates remainder / other *from below*, add this
  // into the result, and subtract it from the remainder.  It is critical that
  // the approximate value is less than or equal to the real value so that the
  // remainder never becomes negative.
  rem = this;
  while (rem.gte(divisor)) {
    // Approximate the result of division. This may be a little greater or
    // smaller than the actual value.
    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

    // We will tweak the approximate result by changing it in the 48-th digit or
    // the smallest non-fractional digit, whichever is larger.
    var log2 = Math.ceil(Math.log(approx) / Math.LN2),
      delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

      // Decrease the approximation until it is smaller than the remainder.  Note
      // that if it is too large, the product overflows and is negative.
      approxRes = fromNumber(approx),
      approxRem = approxRes.mul(divisor);
    while (approxRem.isNegative() || approxRem.gt(rem)) {
      approx -= delta;
      approxRes = fromNumber(approx, this.unsigned);
      approxRem = approxRes.mul(divisor);
    }

    // We know the answer can't be zero... and actually, zero would cause
    // infinite recursion since we would make no progress.
    if (approxRes.isZero())
      approxRes = ONE;

    res = res.add(approxRes);
    rem = rem.sub(approxRem);
  }
  return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @this {!Long}
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);

  // use wasm support if present
  if (wasm) {
    var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }

  return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @this {!Long}
 * @returns {!Long}
 */
LongPrototype.not = function not() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns count leading zeros of this Long.
 * @this {!Long}
 * @returns {!number}
 */
LongPrototype.countLeadingZeros = function countLeadingZeros() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};

/**
 * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
 * @function
 * @param {!Long}
 * @returns {!number}
 */
LongPrototype.clz = LongPrototype.countLeadingZeros;

/**
 * Returns count trailing zeros of this Long.
 * @this {!Long}
 * @returns {!number}
 */
LongPrototype.countTrailingZeros = function countTrailingZeros() {
  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};

/**
 * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
 * @function
 * @param {!Long}
 * @returns {!number}
 */
LongPrototype.ctz = LongPrototype.countTrailingZeros;

/**
 * Returns the bitwise AND of this Long and the specified.
 * @this {!Long}
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @this {!Long}
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @this {!Long}
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
  else
    return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
  else
    return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits < 32) return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >>> numBits, this.unsigned);
  if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
  return fromBits(this.high >>> (numBits - 32), 0, this.unsigned);
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits rotated to the left by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotateLeft = function rotateLeft(numBits) {
  var b;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = (32 - numBits);
    return fromBits(((this.low << numBits) | (this.high >>> b)), ((this.high << numBits) | (this.low >>> b)), this.unsigned);
  }
  numBits -= 32;
  b = (32 - numBits);
  return fromBits(((this.high << numBits) | (this.low >>> b)), ((this.low << numBits) | (this.high >>> b)), this.unsigned);
}
/**
 * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotl = LongPrototype.rotateLeft;

/**
 * Returns this Long with bits rotated to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotateRight = function rotateRight(numBits) {
  var b;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = (32 - numBits);
    return fromBits(((this.high << b) | (this.low >>> numBits)), ((this.low << b) | (this.high >>> numBits)), this.unsigned);
  }
  numBits -= 32;
  b = (32 - numBits);
  return fromBits(((this.low << b) | (this.high >>> numBits)), ((this.high << b) | (this.low >>> numBits)), this.unsigned);
}
/**
 * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotr = LongPrototype.rotateRight;

/**
 * Converts this Long to signed.
 * @this {!Long}
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned)
    return this;
  return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @this {!Long}
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned)
    return this;
  return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @this {!Long}
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
  return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @this {!Long}
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
  var hi = this.high,
    lo = this.low;
  return [
    lo & 0xff,
    lo >>> 8 & 0xff,
    lo >>> 16 & 0xff,
    lo >>> 24,
    hi & 0xff,
    hi >>> 8 & 0xff,
    hi >>> 16 & 0xff,
    hi >>> 24
  ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @this {!Long}
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
  var hi = this.high,
    lo = this.low;
  return [
    hi >>> 24,
    hi >>> 16 & 0xff,
    hi >>> 8 & 0xff,
    hi & 0xff,
    lo >>> 24,
    lo >>> 16 & 0xff,
    lo >>> 8 & 0xff,
    lo & 0xff
  ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
  return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
  return new Long(
    bytes[0] |
    bytes[1] << 8 |
    bytes[2] << 16 |
    bytes[3] << 24,
    bytes[4] |
    bytes[5] << 8 |
    bytes[6] << 16 |
    bytes[7] << 24,
    unsigned
  );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
  return new Long(
    bytes[4] << 24 |
    bytes[5] << 16 |
    bytes[6] << 8 |
    bytes[7],
    bytes[0] << 24 |
    bytes[1] << 16 |
    bytes[2] << 8 |
    bytes[3],
    unsigned
  );
};

/* harmony default export */ const node_modules_long = (Long);

;// CONCATENATED MODULE: ./src/util/error.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Code;
(function (Code) {
    // Ok is returned when the operation completed successfully.
    Code["Ok"] = "ok";
    // ClientNotActive is returned when the client is not active.
    Code["ClientNotActive"] = "client-not-active";
    // Unimplemented is returned when the operation is not implemented.
    Code["Unimplemented"] = "unimplemented";
    // Unsupported is returned when the operation is not supported.
    Code["Unsupported"] = "unsupported";
    // DocumentNotAttached is returned when the document is not attached.
    Code["DocumentNotAttached"] = "document-not-attached";
    // DocumentNotDetached is returned when the document is not detached.
    Code["DocumentNotDetached"] = "document-not-detached";
    // DocumentRemoved is returned when the document is removed.
    Code["DocumentRemoved"] = "document-removed";
    // InvalidObjectKey is returned when the object key is invalid.
    Code["InvalidObjectKey"] = "invalid-object-key";
    // InvalidArgument is returned when the argument is invalid.
    Code["InvalidArgument"] = "invalid-argument";
})(Code || (Code = {}));
/**
 * `YorkieError` is an error returned by a Yorkie operation.
 */
class YorkieError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        this.message = message;
        this.name = 'YorkieError';
        this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
    }
}

;// CONCATENATED MODULE: ./src/util/object.ts
/*
 * Copyright 2023 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * `deepcopy` returns a deep copy of the given object.
 */
function deepcopy(object) {
    if (object instanceof Map) {
        const pairs = Array.from(object);
        return new Map(JSON.parse(JSON.stringify(pairs)));
    }
    return JSON.parse(JSON.stringify(object));
}
/**
 `isEmpty` returns whether parameter object is empty or not
 */
const isEmpty = (object) => {
    if (!object) {
        return true;
    }
    return Object.entries(object).length === 0;
};
/**
 * `stringifyObjectValues` makes values of attributes to JSON parsable string.
 */
const stringifyObjectValues = (attributes) => {
    const attrs = {};
    for (const [key, value] of Object.entries(attributes)) {
        attrs[key] = JSON.stringify(value);
    }
    return attrs;
};
/**
 `parseObjectValues` returns the JSON parsable string values to the origin states.
 */
const parseObjectValues = (attrs) => {
    const attributes = {};
    for (const [key, value] of Object.entries(attrs)) {
        attributes[key] = JSON.parse(value);
    }
    return attributes;
};

;// CONCATENATED MODULE: ./src/document/presence/presence.ts
/*
 * Copyright 2023 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * `PresenceChangeType` represents the type of presence change.
 */
var PresenceChangeType;
(function (PresenceChangeType) {
    PresenceChangeType["Put"] = "put";
    PresenceChangeType["Clear"] = "clear";
})(PresenceChangeType || (PresenceChangeType = {}));
/**
 * `Presence` represents a proxy for the Presence to be manipulated from the outside.
 */
class Presence {
    constructor(changeContext, presence) {
        this.context = changeContext;
        this.presence = presence;
    }
    /**
     * `set` updates the presence based on the partial presence.
     */
    set(presence, option) {
        for (const key of Object.keys(presence)) {
            this.presence[key] = presence[key];
        }
        this.context.setPresenceChange({
            type: PresenceChangeType.Put,
            presence: deepcopy(this.presence),
        });
        this.context.setReversePresence(presence, option);
    }
    /**
     * `get` returns the presence value of the given key.
     */
    get(key) {
        return this.presence[key];
    }
    /**
     * `clear` clears the presence.
     * @internal
     */
    clear() {
        this.presence = {};
        this.context.setPresenceChange({
            type: PresenceChangeType.Clear,
        });
    }
}

;// CONCATENATED MODULE: ./src/document/time/actor_id.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * `InitialActorID` is the initial value of ActorID.
 */
const InitialActorID = '000000000000000000000000';
/**
 * `MaxActorID` is the maximum value of ActorID.
 */
const MaxActorID = 'FFFFFFFFFFFFFFFFFFFFFFFF';

;// CONCATENATED MODULE: ./src/document/time/ticket.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const TicketComparator = (p1, p2) => {
    return p1.compare(p2);
};
/**
 * `TimeTicket` is a timestamp of the logical clock. Ticket is immutable.
 * It is created by `ChangeID`.
 *
 * @public
 */
class TimeTicket {
    /** @hideconstructor */
    constructor(lamport, delimiter, actorID) {
        this.lamport = lamport;
        this.delimiter = delimiter;
        this.actorID = actorID;
    }
    /**
     * `of` creates an instance of Ticket.
     */
    static of(lamport, delimiter, actorID) {
        return new TimeTicket(lamport, delimiter, actorID);
    }
    /**
     * `fromStruct` creates an instance of Ticket from the struct.
     */
    static fromStruct(struct) {
        return TimeTicket.of(node_modules_long.fromString(struct.lamport, true), struct.delimiter, struct.actorID);
    }
    /**
     * `toIDString` returns the lamport string for this Ticket.
     */
    toIDString() {
        if (!this.actorID) {
            return `${this.lamport.toString()}:nil:${this.delimiter}`;
        }
        return `${this.lamport.toString()}:${this.actorID}:${this.delimiter}`;
    }
    /**
     * `toStruct` returns the structure of this Ticket.
     */
    toStruct() {
        return {
            lamport: this.getLamportAsString(),
            delimiter: this.getDelimiter(),
            actorID: this.getActorID(),
        };
    }
    /**
     * `toTestString` returns a string containing the meta data of the ticket
     * for debugging purpose.
     */
    toTestString() {
        if (!this.actorID) {
            return `${this.lamport.toString()}:nil:${this.delimiter}`;
        }
        return `${this.lamport.toString()}:${this.actorID.slice(-2)}:${this.delimiter}`;
    }
    /**
     * `setActor` creates a new instance of Ticket with the given actorID.
     */
    setActor(actorID) {
        return new TimeTicket(this.lamport, this.delimiter, actorID);
    }
    /**
     * `getLamportAsString` returns the lamport string.
     */
    getLamportAsString() {
        return this.lamport.toString();
    }
    /**
     * `getDelimiter` returns delimiter.
     */
    getDelimiter() {
        return this.delimiter;
    }
    /**
     * `getActorID` returns actorID.
     */
    getActorID() {
        return this.actorID;
    }
    /**
     * `after` returns whether the given ticket was created later.
     */
    after(other) {
        return this.compare(other) > 0;
    }
    /**
     * `equals` returns whether the given ticket was created.
     */
    equals(other) {
        return this.compare(other) === 0;
    }
    /**
     * `compare` returns an integer comparing two Ticket.
     *  The result will be 0 if id==other, -1 if `id < other`, and +1 if `id > other`.
     *  If the receiver or argument is nil, it would panic at runtime.
     */
    compare(other) {
        if (this.lamport.greaterThan(other.lamport)) {
            return 1;
        }
        else if (other.lamport.greaterThan(this.lamport)) {
            return -1;
        }
        const compare = this.actorID.localeCompare(other.actorID);
        if (compare !== 0) {
            return compare;
        }
        if (this.delimiter > other.delimiter) {
            return 1;
        }
        else if (other.delimiter > this.delimiter) {
            return -1;
        }
        return 0;
    }
}
const InitialDelimiter = 0;
const MaxDelemiter = 4294967295; // UInt32 MAX_VALUE
const MaxLamport = node_modules_long.MAX_VALUE;
const InitialTimeTicket = new TimeTicket(node_modules_long.fromNumber(0), InitialDelimiter, InitialActorID);
const MaxTimeTicket = new TimeTicket(MaxLamport, MaxDelemiter, MaxActorID);

;// CONCATENATED MODULE: ./src/document/crdt/element.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * `CRDTElement` represents an element that has `TimeTicket`s.
 *
 * @internal
 */
class CRDTElement {
    constructor(createdAt) {
        this.createdAt = createdAt;
    }
    /**
     * `getCreatedAt` returns the creation time of this element.
     */
    getCreatedAt() {
        return this.createdAt;
    }
    /**
     * `getID` returns the creation time of this element.
     */
    getID() {
        return this.createdAt;
    }
    /**
     * `getMovedAt` returns the move time of this element.
     */
    getMovedAt() {
        return this.movedAt;
    }
    /**
     * `getRemovedAt` returns the removal time of this element.
     */
    getRemovedAt() {
        return this.removedAt;
    }
    /**
     * `getPositionedAt` returns the time of this element when it was positioned
     * in the document by undo/redo or move operation.
     */
    getPositionedAt() {
        if (!this.movedAt) {
            return this.createdAt;
        }
        return this.movedAt;
    }
    /**
     * `setMovedAt` sets the move time of this element.
     */
    setMovedAt(movedAt) {
        if (!this.movedAt || (movedAt && movedAt.after(this.movedAt))) {
            this.movedAt = movedAt;
            return true;
        }
        return false;
    }
    /**
     * `setRemovedAt` sets the remove time of this element.
     */
    setRemovedAt(removedAt) {
        this.removedAt = removedAt;
    }
    /**
     * `remove` removes this element.
     */
    remove(removedAt) {
        if (removedAt &&
            removedAt.after(this.getPositionedAt()) &&
            (!this.removedAt || removedAt.after(this.removedAt))) {
            // NOTE(chacha912): If it's a CRDTContainer, removedAt is marked only on
            // the top-level element, without marking all descendant elements. This
            // enhances the speed of deletion.
            this.removedAt = removedAt;
            return true;
        }
        return false;
    }
    /**
     * `isRemoved` check if this element was removed.
     */
    isRemoved() {
        return !!this.removedAt;
    }
}
/**
 *
 * `CRDTContainer` represents CRDTArray or CRDtObject.
 */
class CRDTContainer extends CRDTElement {
    constructor(createdAt) {
        super(createdAt);
    }
}
/**
 * `CRDTGCElement` represents element which has garbage collecting method.
 */
class CRDTGCElement extends CRDTElement {
}

;// CONCATENATED MODULE: ./src/document/crdt/element_rht.ts
/*
 * Copyright 2023 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * `ElementRHTNode` is a node of ElementRHT.
 */
class ElementRHTNode {
    constructor(strKey, value) {
        this.strKey = strKey;
        this.value = value;
    }
    /**
     * `of` creates a instance of ElementRHTNode.
     */
    static of(strKey, value) {
        return new ElementRHTNode(strKey, value);
    }
    /**
     * `isRemoved` checks whether this value was removed.
     */
    isRemoved() {
        return this.value.isRemoved();
    }
    /**
     * `getStrKey` returns the key of this node.
     */
    getStrKey() {
        return this.strKey;
    }
    /**
     * `getValue` return the value(element) of this node
     */
    getValue() {
        return this.value;
    }
    /**
     * `remove` removes a value base on removing time.
     */
    remove(removedAt) {
        return this.value.remove(removedAt);
    }
}
/**
 * ElementRHT is a hashtable with logical clock(Replicated hashtable)
 *
 */
class ElementRHT {
    constructor() {
        this.nodeMapByKey = new Map();
        this.nodeMapByCreatedAt = new Map();
    }
    /**
     * `create` creates an instance of ElementRHT.
     */
    static create() {
        return new ElementRHT();
    }
    /**
     * `set` sets the value of the given key.
     */
    set(key, value, executedAt) {
        let removed;
        const node = this.nodeMapByKey.get(key);
        if (node != null && !node.isRemoved() && node.remove(executedAt)) {
            removed = node.getValue();
        }
        const newNode = ElementRHTNode.of(key, value);
        this.nodeMapByCreatedAt.set(value.getCreatedAt().toIDString(), newNode);
        if (node == null || executedAt.after(node.getValue().getPositionedAt())) {
            this.nodeMapByKey.set(key, newNode);
            value.setMovedAt(executedAt);
        }
        return removed;
    }
    /**
     * `delete` deletes the Element of the given key.
     */
    delete(createdAt, executedAt) {
        if (!this.nodeMapByCreatedAt.has(createdAt.toIDString())) {
            logger.fatal(`fail to find ${createdAt.toIDString()}`);
        }
        const node = this.nodeMapByCreatedAt.get(createdAt.toIDString());
        node.remove(executedAt);
        return node.getValue();
    }
    /**
     * `subPathOf` returns the sub path of the given element.
     */
    subPathOf(createdAt) {
        const node = this.nodeMapByCreatedAt.get(createdAt.toIDString());
        if (!node) {
            return;
        }
        return node.getStrKey();
    }
    /**
     * `purge` physically purge child element.
     */
    purge(element) {
        const node = this.nodeMapByCreatedAt.get(element.getCreatedAt().toIDString());
        if (!node) {
            logger.fatal(`fail to find ${element.getCreatedAt().toIDString()}`);
            return;
        }
        const nodeByKey = this.nodeMapByKey.get(node.getStrKey());
        if (node === nodeByKey) {
            this.nodeMapByKey.delete(nodeByKey.getStrKey());
        }
        this.nodeMapByCreatedAt.delete(node.getValue().getCreatedAt().toIDString());
    }
    /**
     * `deleteByKey` deletes the Element of the given key and removed time.
     */
    deleteByKey(key, removedAt) {
        const node = this.nodeMapByKey.get(key);
        if (node == null) {
            return;
        }
        if (!node.remove(removedAt)) {
            return;
        }
        return node.getValue();
    }
    /**
     * `has` returns whether the element exists of the given key or not.
     */
    has(key) {
        const node = this.nodeMapByKey.get(key);
        if (node == null) {
            return false;
        }
        return !node.isRemoved();
    }
    /**
     * `getByID` returns the node of the given createdAt.
     */
    getByID(createdAt) {
        return this.nodeMapByCreatedAt.get(createdAt.toIDString());
    }
    /**
     * `get` returns the node of the given key.
     */
    get(key) {
        const node = this.nodeMapByKey.get(key);
        if (!node || node.isRemoved()) {
            return;
        }
        return node;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    *[Symbol.iterator]() {
        for (const [, node] of this.nodeMapByKey) {
            yield node;
        }
    }
}

;// CONCATENATED MODULE: ./src/document/crdt/object.ts
/*
 * Copyright 2023 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * `CRDTObject` represents an object data type, but unlike regular JSON,
 * it has `TimeTicket`s which are created by logical clock.
 *
 */
class CRDTObject extends CRDTContainer {
    /** @hideconstructor */
    constructor(createdAt, memberNodes) {
        super(createdAt);
        this.memberNodes = memberNodes;
    }
    /**
     * `create` creates a new instance of CRDTObject.
     */
    static create(createdAt, value) {
        if (!value) {
            return new CRDTObject(createdAt, ElementRHT.create());
        }
        const memberNodes = ElementRHT.create();
        for (const [k, v] of Object.entries(value)) {
            memberNodes.set(k, v.deepcopy(), v.getCreatedAt());
        }
        return new CRDTObject(createdAt, memberNodes);
    }
    /**
     * `subPathOf` returns the sub path of the given element.
     */
    subPathOf(createdAt) {
        return this.memberNodes.subPathOf(createdAt);
    }
    /**
     * `purge` physically purges the given element.
     */
    purge(value) {
        this.memberNodes.purge(value);
    }
    /**
     * `set` sets the given element of the given key.
     */
    set(key, value, executedAt) {
        return this.memberNodes.set(key, value, executedAt);
    }
    /**
     * `delete` deletes the element of the given key.
     */
    delete(createdAt, executedAt) {
        return this.memberNodes.delete(createdAt, executedAt);
    }
    /**
     * `deleteByKey` deletes the element of the given key and execution time.
     */
    deleteByKey(key, executedAt) {
        return this.memberNodes.deleteByKey(key, executedAt);
    }
    /**
     * `get` returns the value of the given key.
     */
    get(key) {
        const node = this.memberNodes.get(key);
        return node === null || node === void 0 ? void 0 : node.getValue();
    }
    /**
     * `getByID` returns the element of the given createAt.
     */
    getByID(createdAt) {
        const node = this.memberNodes.getByID(createdAt);
        return node === null || node === void 0 ? void 0 : node.getValue();
    }
    /**
     * `has` returns whether the element exists of the given key or not.
     */
    has(key) {
        return this.memberNodes.has(key);
    }
    /**
     * `toJSON` returns the JSON encoding of this object.
     */
    toJSON() {
        const json = [];
        for (const [key, value] of this) {
            json.push(`"${key}":${value.toJSON()}`);
        }
        return `{${json.join(',')}}`;
    }
    /**
     * `toJS` returns the JavaScript object of this object.
     */
    toJS() {
        return JSON.parse(this.toJSON());
    }
    /**
     * `toJSForTest` returns value with meta data for testing.
     */
    toJSForTest() {
        const values = {};
        for (const [key, elem] of this) {
            const { id, value, type } = elem.toJSForTest();
            values[key] = {
                key,
                id,
                value,
                type,
            };
        }
        return {
            id: this.getCreatedAt().toTestString(),
            value: values,
            type: 'YORKIE_OBJECT',
        };
    }
    /**
     * `getKeys` returns array of keys in this object.
     */
    getKeys() {
        const keys = Array();
        for (const [key] of this) {
            keys.push(key);
        }
        return keys;
    }
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this object.
     */
    toSortedJSON() {
        var _a;
        const keys = Array();
        for (const [key] of this) {
            keys.push(key);
        }
        const json = [];
        for (const key of keys.sort()) {
            const node = (_a = this.memberNodes.get(key)) === null || _a === void 0 ? void 0 : _a.getValue();
            json.push(`"${key}":${node.toSortedJSON()}`);
        }
        return `{${json.join(',')}}`;
    }
    /**
     * `getRHT` RHTNodes returns the RHTPQMap nodes.
     */
    getRHT() {
        return this.memberNodes;
    }
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy() {
        const clone = CRDTObject.create(this.getCreatedAt());
        for (const node of this.memberNodes) {
            clone.memberNodes.set(node.getStrKey(), node.getValue().deepcopy(), this.getPositionedAt());
        }
        clone.remove(this.getRemovedAt());
        return clone;
    }
    /**
     * `getDescendants` returns the descendants of this object by traversing.
     */
    getDescendants(callback) {
        for (const node of this.memberNodes) {
            const element = node.getValue();
            if (callback(element, this)) {
                return;
            }
            if (element instanceof CRDTContainer) {
                element.getDescendants(callback);
            }
        }
    }
    /**
     * eslint-disable-next-line jsdoc/require-jsdoc
     * @internal
     */
    *[Symbol.iterator]() {
        const keySet = new Set();
        for (const node of this.memberNodes) {
            if (!keySet.has(node.getStrKey())) {
                keySet.add(node.getStrKey());
                if (!node.isRemoved()) {
                    yield [node.getStrKey(), node.getValue()];
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/document/operation/operation.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * `OpSource` represents the source of the operation. It is used to handle
 * corner cases in the operations created by undo/redo allow the removed
 * elements when executing them.
 */
var OpSource;
(function (OpSource) {
    OpSource["Local"] = "local";
    OpSource["Remote"] = "remote";
    OpSource["UndoRedo"] = "undoredo";
})(OpSource || (OpSource = {}));
/**
 * `Operation` represents an operation to be executed on a document.
 */
class Operation {
    constructor(parentCreatedAt, executedAt) {
        this.parentCreatedAt = parentCreatedAt;
        this.executedAt = executedAt;
    }
    /**
     * `getParentCreatedAt` returns the creation time of the target element to
     * execute the operation.
     */
    getParentCreatedAt() {
        return this.parentCreatedAt;
    }
    /**
     * `getExecutedAt` returns execution time of this operation.
     */
    getExecutedAt() {
        // NOTE(chacha912): When an operation is in the undo/redo stack,
        // it doesn't have an executedAt yet. The executedAt is set when
        // the operation is executed through undo or redo.
        if (!this.executedAt) {
            throw new Error(`executedAt has not been set yet`);
        }
        return this.executedAt;
    }
    /**
     * `setActor` sets the given actor to this operation.
     */
    setActor(actorID) {
        if (this.executedAt) {
            this.executedAt = this.executedAt.setActor(actorID);
        }
    }
    /**
     * `setExecutedAt` sets the executedAt.
     */
    setExecutedAt(executedAt) {
        this.executedAt = executedAt;
    }
}

;// CONCATENATED MODULE: ./src/util/splay_tree.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * `SplayNode` is a node of SplayTree.
 */
class SplayNode {
    constructor(value) {
        this.value = value;
        this.initWeight();
    }
    /**
     * `getNodeString` returns a string of weight and value of this node.
     */
    getNodeString() {
        return `${this.weight}${this.value}`;
    }
    /**
     * `getValue` returns value of this node.
     */
    getValue() {
        return this.value;
    }
    /**
     * `getLeftWeight` returns left weight of this node.
     */
    getLeftWeight() {
        return !this.hasLeft() ? 0 : this.left.getWeight();
    }
    /**
     * `getRightWeight` returns right weight of this node.
     */
    getRightWeight() {
        return !this.hasRight() ? 0 : this.right.getWeight();
    }
    /**
     * `getWeight` returns weight of this node.
     */
    getWeight() {
        return this.weight;
    }
    /**
     * `getLeft` returns a left node.
     */
    getLeft() {
        return this.left;
    }
    /**
     * `getRight` returns a right node.
     */
    getRight() {
        return this.right;
    }
    /**
     * `getParent` returns parent of this node.
     */
    getParent() {
        return this.parent;
    }
    /**
     * `hasLeft` check if the left node exists
     */
    hasLeft() {
        return !!this.left;
    }
    /**
     * `hasRight` check if the right node exists
     */
    hasRight() {
        return !!this.right;
    }
    /**
     * `hasParent` check if the parent node exists
     */
    hasParent() {
        return !!this.parent;
    }
    /**
     * `setLeft` sets a left node.
     */
    setLeft(left) {
        this.left = left;
    }
    /**
     * `setRight` sets a right node.
     */
    setRight(right) {
        this.right = right;
    }
    /**
     * `setParent` sets a parent node.
     */
    setParent(parent) {
        this.parent = parent;
    }
    /**
     * `unlink` unlink parent, right and left node.
     */
    unlink() {
        this.parent = undefined;
        this.right = undefined;
        this.left = undefined;
    }
    /**
     * `hasLinks` checks if parent, right and left node exists.
     */
    hasLinks() {
        return this.hasParent() || this.hasLeft() || this.hasRight();
    }
    /**
     * `increaseWeight` increases weight.
     */
    increaseWeight(weight) {
        this.weight += weight;
    }
    /**
     * `initWeight` sets initial weight of this node.
     */
    initWeight() {
        this.weight = this.getLength();
    }
}
/**
 * SplayTree is weighted binary search tree which is based on Splay tree.
 * original paper on Splay Trees:
 * @see https://www.cs.cmu.edu/~sleator/papers/self-adjusting.pdf
 */
class SplayTree {
    constructor(root) {
        this.root = root;
    }
    /**
     * `length` returns the size of this tree.
     */
    get length() {
        return this.root ? this.root.getWeight() : 0;
    }
    /**
     * `find` returns the Node and offset of the given index.
     */
    find(pos) {
        if (!this.root || pos < 0) {
            return [undefined, 0];
        }
        let node = this.root;
        for (;;) {
            if (node.hasLeft() && pos <= node.getLeftWeight()) {
                node = node.getLeft();
            }
            else if (node.hasRight() &&
                node.getLeftWeight() + node.getLength() < pos) {
                pos -= node.getLeftWeight() + node.getLength();
                node = node.getRight();
            }
            else {
                pos -= node.getLeftWeight();
                break;
            }
        }
        if (pos > node.getLength()) {
            logger.fatal(`out of index range: pos: ${pos} > node.length: ${node.getLength()}`);
        }
        return [node, pos];
    }
    /**
     * Find the index of the given node in BST.
     *
     * @param node - the given node
     * @returns the index of given node
     */
    indexOf(node) {
        if (!node || (node !== this.root && !node.hasLinks())) {
            return -1;
        }
        let index = 0;
        let current = node;
        let prev;
        while (current) {
            if (!prev || prev === current.getRight()) {
                index +=
                    current.getLength() +
                        (current.hasLeft() ? current.getLeftWeight() : 0);
            }
            prev = current;
            current = current.getParent();
        }
        return index - node.getLength();
    }
    /**
     * `getRoot` returns root of this tree.
     */
    getRoot() {
        return this.root;
    }
    /**
     * `insert` inserts the node at the last.
     */
    insert(newNode) {
        return this.insertAfter(this.root, newNode);
    }
    /**
     * `insertAfter` inserts the node after the given previous node.
     */
    insertAfter(target, newNode) {
        // TODO(Eithea): Consider moving the code below to insert()
        if (!target) {
            this.root = newNode;
            return newNode;
        }
        this.splayNode(target);
        this.root = newNode;
        newNode.setRight(target.getRight());
        if (target.hasRight()) {
            target.getRight().setParent(newNode);
        }
        newNode.setLeft(target);
        target.setParent(newNode);
        target.setRight();
        this.updateWeight(target);
        this.updateWeight(newNode);
        return newNode;
    }
    /**
     * `updateWeight` recalculates the weight of this node with the value and children.
     */
    updateWeight(node) {
        node.initWeight();
        if (node.hasLeft()) {
            node.increaseWeight(node.getLeftWeight());
        }
        if (node.hasRight()) {
            node.increaseWeight(node.getRightWeight());
        }
    }
    updateTreeWeight(node) {
        while (node) {
            this.updateWeight(node);
            node = node.getParent();
        }
    }
    /**
     * `splayNode` moves the given node to the root.
     */
    splayNode(node) {
        if (!node) {
            return;
        }
        for (;;) {
            if (this.isLeftChild(node.getParent()) && this.isRightChild(node)) {
                // zig-zag
                this.rotateLeft(node);
                this.rotateRight(node);
            }
            else if (this.isRightChild(node.getParent()) &&
                this.isLeftChild(node)) {
                // zig-zag
                this.rotateRight(node);
                this.rotateLeft(node);
            }
            else if (this.isLeftChild(node.getParent()) && this.isLeftChild(node)) {
                // zig-zig
                this.rotateRight(node.getParent());
                this.rotateRight(node);
            }
            else if (this.isRightChild(node.getParent()) &&
                this.isRightChild(node)) {
                // zig-zig
                this.rotateLeft(node.getParent());
                this.rotateLeft(node);
            }
            else {
                // zig
                if (this.isLeftChild(node)) {
                    this.rotateRight(node);
                }
                else if (this.isRightChild(node)) {
                    this.rotateLeft(node);
                }
                this.updateWeight(node);
                return;
            }
        }
    }
    /**
     * `delete` deletes target node of this tree.
     */
    delete(node) {
        this.splayNode(node);
        const leftTree = new SplayTree(node.getLeft());
        if (leftTree.root) {
            leftTree.root.setParent();
        }
        const rightTree = new SplayTree(node.getRight());
        if (rightTree.root) {
            rightTree.root.setParent();
        }
        if (leftTree.root) {
            const rightmostNode = leftTree.getRightmost();
            leftTree.splayNode(rightmostNode);
            leftTree.root.setRight(rightTree.root);
            if (rightTree.root) {
                rightTree.root.setParent(leftTree.root);
            }
            this.root = leftTree.root;
        }
        else {
            this.root = rightTree.root;
        }
        node.unlink();
        if (this.root) {
            this.updateWeight(this.root);
        }
    }
    /**
     * `deleteRange` separates the range between given 2 boundaries from this Tree.
     * This function separates the range to delete as a subtree
     * by splaying outer boundary nodes.
     * leftBoundary must exist because of 0-indexed initial dummy node of tree,
     * but rightBoundary can be nil means range to delete includes the end of tree.
     * Refer to the design document in https://github.com/yorkie-team/yorkie/tree/main/design
     */
    deleteRange(leftBoundary, rightBoundary) {
        if (!rightBoundary) {
            this.splayNode(leftBoundary);
            this.cutOffRight(leftBoundary);
            return;
        }
        this.splayNode(leftBoundary);
        this.splayNode(rightBoundary);
        if (rightBoundary.getLeft() != leftBoundary) {
            this.rotateRight(leftBoundary);
        }
        this.cutOffRight(leftBoundary);
    }
    cutOffRight(root) {
        const nodesToFreeWeight = [];
        this.traversePostorder(root.getRight(), nodesToFreeWeight);
        for (const node of nodesToFreeWeight) {
            node.initWeight();
        }
        this.updateTreeWeight(root);
    }
    /**
     * `toTestString` returns a string containing the meta data of the Node
     * for debugging purpose.
     */
    toTestString() {
        const metaString = [];
        this.traverseInorder(this.root, metaString);
        return metaString
            .map((n) => `[${n.getWeight()},${n.getLength()}]${n.getValue() || ''}`)
            .join('');
    }
    /**
     * `checkWeight` returns false when there is an incorrect weight node.
     * for debugging purpose.
     */
    checkWeight() {
        const nodes = [];
        this.traverseInorder(this.root, nodes);
        for (const node of nodes) {
            if (node.getWeight() !=
                node.getLength() + node.getLeftWeight() + node.getRightWeight()) {
                return false;
            }
        }
        return true;
    }
    getRightmost() {
        let node = this.root;
        while (node.hasRight()) {
            node = node.getRight();
        }
        return node;
    }
    traverseInorder(node, stack) {
        if (!node) {
            return;
        }
        this.traverseInorder(node.getLeft(), stack);
        stack.push(node);
        this.traverseInorder(node.getRight(), stack);
    }
    traversePostorder(node, stack) {
        if (!node) {
            return;
        }
        this.traversePostorder(node.getLeft(), stack);
        this.traversePostorder(node.getRight(), stack);
        stack.push(node);
    }
    rotateLeft(pivot) {
        const root = pivot.getParent();
        if (root.hasParent()) {
            if (root === root.getParent().getLeft()) {
                root.getParent().setLeft(pivot);
            }
            else {
                root.getParent().setRight(pivot);
            }
        }
        else {
            this.root = pivot;
        }
        pivot.setParent(root.getParent());
        root.setRight(pivot.getLeft());
        if (root.hasRight()) {
            root.getRight().setParent(root);
        }
        pivot.setLeft(root);
        pivot.getLeft().setParent(pivot);
        this.updateWeight(root);
        this.updateWeight(pivot);
    }
    rotateRight(pivot) {
        const root = pivot.getParent();
        if (root.hasParent()) {
            if (root === root.getParent().getLeft()) {
                root.getParent().setLeft(pivot);
            }
            else {
                root.getParent().setRight(pivot);
            }
        }
        else {
            this.root = pivot;
        }
        pivot.setParent(root.getParent());
        root.setLeft(pivot.getRight());
        if (root.hasLeft()) {
            root.getLeft().setParent(root);
        }
        pivot.setRight(root);
        pivot.getRight().setParent(pivot);
        this.updateWeight(root);
        this.updateWeight(pivot);
    }
    isLeftChild(node) {
        if (node && node.hasParent()) {
            return node.getParent().getLeft() === node;
        }
        return false;
    }
    isRightChild(node) {
        if (node && node.hasParent()) {
            return node.getParent().getRight() === node;
        }
        return false;
    }
}

;// CONCATENATED MODULE: ./src/document/json/strings.ts
/**
 * `EscapeString` escapes the given string.
 */
function escapeString(str) {
    return str.replace(/["'\\\n\r\f\b\t\u2028\u2029]/g, function (character) {
        switch (character) {
            case '"':
            case "'":
            case '\\':
                return '\\' + character;
            case '\n':
                return '\\n';
            case '\r':
                return '\\r';
            case '\f':
                return '\\f';
            case '\b':
                return '\\b';
            case '\t':
                return '\\t';
            case '\u2028':
                return '\\u2028';
            case '\u2029':
                return '\\u2029';
            default:
                return character;
        }
    });
}

;// CONCATENATED MODULE: ./src/document/crdt/primitive.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var PrimitiveType;
(function (PrimitiveType) {
    PrimitiveType[PrimitiveType["Null"] = 0] = "Null";
    PrimitiveType[PrimitiveType["Boolean"] = 1] = "Boolean";
    PrimitiveType[PrimitiveType["Integer"] = 2] = "Integer";
    PrimitiveType[PrimitiveType["Long"] = 3] = "Long";
    PrimitiveType[PrimitiveType["Double"] = 4] = "Double";
    PrimitiveType[PrimitiveType["String"] = 5] = "String";
    PrimitiveType[PrimitiveType["Bytes"] = 6] = "Bytes";
    PrimitiveType[PrimitiveType["Date"] = 7] = "Date";
})(PrimitiveType || (PrimitiveType = {}));
/**
 * `Primitive` represents primitive data type including logical clock.
 * It has a type and a value.
 */
class Primitive extends CRDTElement {
    constructor(value, createdAt) {
        super(createdAt);
        this.valueType = Primitive.getPrimitiveType(value);
        this.value = value === undefined ? null : value;
    }
    /**
     * `of` creates a new instance of Primitive.
     */
    static of(value, createdAt) {
        return new Primitive(value, createdAt);
    }
    /**
     * `valueFromBytes` parses the given bytes into value.
     */
    static valueFromBytes(primitiveType, bytes) {
        switch (primitiveType) {
            case PrimitiveType.Null:
                return null;
            case PrimitiveType.Boolean:
                return bytes[0] ? true : false;
            case PrimitiveType.Integer:
                return bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);
            case PrimitiveType.Double: {
                const view = new DataView(bytes.buffer);
                bytes.forEach(function (b, i) {
                    view.setUint8(i, b);
                });
                return view.getFloat64(0, true);
            }
            case PrimitiveType.String:
                return new TextDecoder('utf-8').decode(bytes);
            case PrimitiveType.Long:
                return node_modules_long.fromBytesLE(Array.from(bytes));
            case PrimitiveType.Bytes:
                return bytes;
            case PrimitiveType.Date:
                return new Date(node_modules_long.fromBytesLE(Array.from(bytes), true).toNumber());
            default:
                throw new YorkieError(Code.Unimplemented, `unimplemented type: ${primitiveType}`);
        }
    }
    /**
     * `toJSON` returns the JSON encoding of the value.
     */
    toJSON() {
        if (this.valueType === PrimitiveType.String) {
            return `"${escapeString(this.value)}"`;
        }
        // TODO(hackerwins): We need to consider the case where the value is
        // a byte array and a date.
        return `${this.value}`;
    }
    /**
     * `toSortedJSON` returns the sorted JSON encoding of the value.
     */
    toSortedJSON() {
        return this.toJSON();
    }
    /**
     * `toJSForTest` returns value with meta data for testing.
     */
    toJSForTest() {
        return {
            id: this.getCreatedAt().toTestString(),
            value: this.value,
            type: 'YORKIE_PRIMITIVE',
        };
    }
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy() {
        const primitive = Primitive.of(this.value, this.getCreatedAt());
        primitive.setMovedAt(this.getMovedAt());
        primitive.setRemovedAt(this.getRemovedAt());
        return primitive;
    }
    /**
     * `getType` returns the type of the value.
     */
    getType() {
        return this.valueType;
    }
    /**
     * `getPrimitiveType` returns the primitive type of the value.
     */
    static getPrimitiveType(value) {
        switch (typeof value) {
            case 'undefined':
                return PrimitiveType.Null;
            case 'boolean':
                return PrimitiveType.Boolean;
            case 'number':
                if (this.isInteger(value)) {
                    return PrimitiveType.Integer;
                }
                else {
                    return PrimitiveType.Double;
                }
            case 'string':
                return PrimitiveType.String;
            case 'object':
                if (value === null) {
                    return PrimitiveType.Null;
                }
                else if (value instanceof node_modules_long) {
                    return PrimitiveType.Long;
                }
                else if (value instanceof Uint8Array) {
                    return PrimitiveType.Bytes;
                }
                else if (value instanceof Date) {
                    return PrimitiveType.Date;
                }
        }
        return;
    }
    /**
     * `isSupport` check if the given value is supported type.
     */
    static isSupport(value) {
        const primitiveType = Primitive.getPrimitiveType(value);
        if (primitiveType === undefined) {
            return false;
        }
        return true;
    }
    /**
     * `isInteger` checks if the given number is integer.
     */
    static isInteger(num) {
        return num % 1 === 0;
    }
    /**
     * `isNumericType` checks numeric type by JSONPrimitive
     */
    isNumericType() {
        const t = this.valueType;
        return (t === PrimitiveType.Integer ||
            t === PrimitiveType.Long ||
            t === PrimitiveType.Double);
    }
    /**
     * `getValue` returns the value of Primitive.
     */
    getValue() {
        return this.value;
    }
    /**
     * `toBytes` creates an array representing the value.
     */
    toBytes() {
        switch (this.valueType) {
            case PrimitiveType.Null: {
                return new Uint8Array();
            }
            case PrimitiveType.Boolean: {
                const boolVal = this.value;
                return boolVal ? new Uint8Array([1]) : new Uint8Array([0]);
            }
            case PrimitiveType.Integer: {
                const intVal = this.value;
                return new Uint8Array([
                    intVal & 0xff,
                    (intVal >> 8) & 0xff,
                    (intVal >> 16) & 0xff,
                    (intVal >> 24) & 0xff,
                ]);
            }
            case PrimitiveType.Double: {
                const doubleVal = this.value;
                const uint8Array = new Uint8Array(8);
                const view = new DataView(uint8Array.buffer);
                view.setFloat64(0, doubleVal, true);
                return uint8Array;
            }
            case PrimitiveType.String: {
                return new TextEncoder().encode(this.value);
            }
            case PrimitiveType.Long: {
                const longVal = this.value;
                const longToBytes = longVal.toBytesLE();
                return Uint8Array.from(longToBytes);
            }
            case PrimitiveType.Bytes: {
                const bytesVal = this.value;
                return bytesVal;
            }
            case PrimitiveType.Date: {
                const dateVal = this.value;
                const dateToBytes = node_modules_long.fromNumber(dateVal.getTime(), true).toBytesLE();
                return Uint8Array.from(dateToBytes);
            }
            default:
                throw new YorkieError(Code.Unimplemented, `unimplemented type: ${this.valueType}`);
        }
    }
}

;// CONCATENATED MODULE: ./src/document/crdt/rga_tree_list.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * `RGATreeListNode` is a node of RGATreeList.
 */
class RGATreeListNode extends SplayNode {
    constructor(value) {
        super(value);
        this.value = value;
    }
    /**
     * `createAfter` creates a new node after the given node.
     */
    static createAfter(prev, value) {
        const newNode = new RGATreeListNode(value);
        const prevNext = prev.next;
        prev.next = newNode;
        newNode.prev = prev;
        newNode.next = prevNext;
        if (prevNext) {
            prevNext.prev = newNode;
        }
        return newNode;
    }
    /**
     * `remove` removes value based on removing time.
     */
    remove(removedAt) {
        return this.value.remove(removedAt);
    }
    /**
     * `getCreatedAt` returns creation time of this value
     */
    getCreatedAt() {
        return this.value.getCreatedAt();
    }
    /**
     * `getPositionedAt` returns the time of this element when it was positioned
     * in the array.
     */
    getPositionedAt() {
        return this.value.getPositionedAt();
    }
    /**
     * `release` releases prev and next node.
     */
    release() {
        if (this.prev) {
            this.prev.next = this.next;
        }
        if (this.next) {
            this.next.prev = this.prev;
        }
        this.prev = undefined;
        this.next = undefined;
    }
    /**
     * `getLength` returns the length of this node.
     */
    getLength() {
        return this.value.isRemoved() ? 0 : 1;
    }
    /**
     * `getPrev` returns a previous node.
     */
    getPrev() {
        return this.prev;
    }
    /**
     * `getNext` returns a next node.
     */
    getNext() {
        return this.next;
    }
    /**
     * `getValue` returns a element value.
     */
    getValue() {
        return this.value;
    }
    /**
     * `isRemoved` checks if the value was removed.
     */
    isRemoved() {
        return this.value.isRemoved();
    }
}
/**
 * `RGATreeList` is a replicated growable array.
 *
 * @internal
 */
class RGATreeList {
    constructor() {
        const dummyValue = Primitive.of(0, InitialTimeTicket);
        dummyValue.setRemovedAt(InitialTimeTicket);
        this.dummyHead = new RGATreeListNode(dummyValue);
        this.last = this.dummyHead;
        this.nodeMapByIndex = new SplayTree();
        this.nodeMapByCreatedAt = new Map();
        this.nodeMapByIndex.insert(this.dummyHead);
        this.nodeMapByCreatedAt.set(this.dummyHead.getCreatedAt().toIDString(), this.dummyHead);
    }
    /**
     * `create` creates instance of RGATreeList.
     */
    static create() {
        return new RGATreeList();
    }
    /**
     * `length` returns size of RGATreeList.
     */
    get length() {
        return this.nodeMapByIndex.length;
    }
    /**
     * `findNextBeforeExecutedAt` returns the node by the given createdAt and
     * executedAt. It passes through nodes created after executedAt from the
     * given node and returns the next node.
     * @param createdAt - created time
     * @param executedAt - executed time
     * @returns next node
     */
    findNextBeforeExecutedAt(createdAt, executedAt) {
        let node = this.nodeMapByCreatedAt.get(createdAt.toIDString());
        if (!node) {
            logger.fatal(`cant find the given node: ${createdAt.toIDString()}`);
        }
        while (node.getNext() &&
            node.getNext().getPositionedAt().after(executedAt)) {
            node = node.getNext();
        }
        return node;
    }
    release(node) {
        if (this.last === node) {
            this.last = node.getPrev();
        }
        node.release();
        this.nodeMapByIndex.delete(node);
        this.nodeMapByCreatedAt.delete(node.getValue().getCreatedAt().toIDString());
    }
    /**
     * `insertAfter` adds a new node with the value after the given node.
     */
    insertAfter(prevCreatedAt, value, executedAt = value.getCreatedAt()) {
        const prevNode = this.findNextBeforeExecutedAt(prevCreatedAt, executedAt);
        const newNode = RGATreeListNode.createAfter(prevNode, value);
        if (prevNode === this.last) {
            this.last = newNode;
        }
        this.nodeMapByIndex.insertAfter(prevNode, newNode);
        this.nodeMapByCreatedAt.set(newNode.getCreatedAt().toIDString(), newNode);
    }
    /**
     * `moveAfter` moves the given `createdAt` element
     * after the `prevCreatedAt` element.
     */
    moveAfter(prevCreatedAt, createdAt, executedAt) {
        const prevNode = this.nodeMapByCreatedAt.get(prevCreatedAt.toIDString());
        if (!prevNode) {
            logger.fatal(`cant find the given node: ${prevCreatedAt.toIDString()}`);
        }
        const node = this.nodeMapByCreatedAt.get(createdAt.toIDString());
        if (!node) {
            logger.fatal(`cant find the given node: ${createdAt.toIDString()}`);
        }
        if (prevNode !== node &&
            (!node.getValue().getMovedAt() ||
                executedAt.after(node.getValue().getMovedAt()))) {
            this.release(node);
            this.insertAfter(prevNode.getCreatedAt(), node.getValue(), executedAt);
            node.getValue().setMovedAt(executedAt);
        }
    }
    /**
     * `insert` adds the given element after the last node.
     */
    insert(value) {
        this.insertAfter(this.last.getCreatedAt(), value);
    }
    /**
     * `getByID` returns the element of the given creation time.
     */
    getByID(createdAt) {
        return this.nodeMapByCreatedAt.get(createdAt.toIDString());
    }
    /**
     * `subPathOf` returns the sub path of the given element.
     */
    subPathOf(createdAt) {
        const node = this.nodeMapByCreatedAt.get(createdAt.toIDString());
        if (!node) {
            return;
        }
        return String(this.nodeMapByIndex.indexOf(node));
    }
    /**
     * `purge` physically purges element.
     */
    purge(element) {
        const node = this.nodeMapByCreatedAt.get(element.getCreatedAt().toIDString());
        if (!node) {
            logger.fatal(`fail to find the given createdAt: ${element
                .getCreatedAt()
                .toIDString()}`);
        }
        this.release(node);
    }
    /**
     * `getByIndex` returns node of the given index.
     */
    getByIndex(idx) {
        if (idx >= this.length) {
            return;
        }
        const [node, offset] = this.nodeMapByIndex.find(idx);
        let rgaNode = node;
        if ((idx === 0 && node === this.dummyHead) || offset > 0) {
            do {
                if (rgaNode) {
                    rgaNode = rgaNode.getNext();
                }
            } while (rgaNode && rgaNode.isRemoved());
        }
        return rgaNode;
    }
    /**
     * `getPrevCreatedAt` returns a creation time of the previous node.
     */
    getPrevCreatedAt(createdAt) {
        let node = this.nodeMapByCreatedAt.get(createdAt.toIDString());
        do {
            node = node.getPrev();
        } while (this.dummyHead !== node && node.isRemoved());
        return node.getValue().getCreatedAt();
    }
    /**
     * `delete` deletes the node of the given creation time.
     */
    delete(createdAt, editedAt) {
        const node = this.nodeMapByCreatedAt.get(createdAt.toIDString());
        const alreadyRemoved = node.isRemoved();
        if (node.remove(editedAt) && !alreadyRemoved) {
            this.nodeMapByIndex.splayNode(node);
        }
        return node.getValue();
    }
    /**
     * `deleteByIndex` deletes the node of the given index.
     */
    deleteByIndex(index, editedAt) {
        const node = this.getByIndex(index);
        if (!node) {
            return;
        }
        if (node.remove(editedAt)) {
            this.nodeMapByIndex.splayNode(node);
        }
        return node.getValue();
    }
    /**
     * `getHead` returns the value of head elements.
     */
    getHead() {
        return this.dummyHead.getValue();
    }
    /**
     * `getLast` returns the value of last elements.
     */
    getLast() {
        return this.last.getValue();
    }
    /**
     * `getLastCreatedAt` returns the creation time of last element.
     */
    getLastCreatedAt() {
        return this.last.getCreatedAt();
    }
    /**
     * `toTestString` returns a String containing the meta data of the node id
     * for debugging purpose.
     */
    toTestString() {
        const json = [];
        for (const node of this) {
            const elem = `${node.getCreatedAt().toIDString()}:${node
                .getValue()
                .toJSON()}`;
            if (node.isRemoved()) {
                json.push(`{${elem}}`);
            }
            else {
                json.push(`[${elem}]`);
            }
        }
        return json.join('');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    *[Symbol.iterator]() {
        let node = this.dummyHead.getNext();
        while (node) {
            yield node;
            node = node.getNext();
        }
    }
}

;// CONCATENATED MODULE: ./src/document/crdt/array.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * `CRDTArray` represents an array data type containing `CRDTElement`s.
 *
 * @internal
 */
class CRDTArray extends CRDTContainer {
    /** @hideconstructor */
    constructor(createdAt, elements) {
        super(createdAt);
        this.elements = elements;
    }
    /**
     * `create` creates a new instance of Array.
     */
    static create(createdAt, value) {
        if (!value) {
            return new CRDTArray(createdAt, RGATreeList.create());
        }
        const elements = RGATreeList.create();
        for (const v of value) {
            elements.insertAfter(elements.getLastCreatedAt(), v.deepcopy());
        }
        return new CRDTArray(createdAt, elements);
    }
    /**
     * `subPathOf` returns the sub path of the given element.
     */
    subPathOf(createdAt) {
        return this.elements.subPathOf(createdAt);
    }
    /**
     * `purge` physically purge the given element.
     */
    purge(element) {
        this.elements.purge(element);
    }
    /**
     * `insertAfter` adds a new node after the the given node.
     */
    insertAfter(prevCreatedAt, value) {
        this.elements.insertAfter(prevCreatedAt, value);
    }
    /**
     * `moveAfter` moves the given `createdAt` element after the `prevCreatedAt`.
     */
    moveAfter(prevCreatedAt, createdAt, executedAt) {
        this.elements.moveAfter(prevCreatedAt, createdAt, executedAt);
    }
    /**
     * `get` returns the element of the given index.
     */
    get(index) {
        const node = this.elements.getByIndex(index);
        return node === null || node === void 0 ? void 0 : node.getValue();
    }
    /**
     * `getByID` returns the element of the given createAt.
     */
    getByID(createdAt) {
        const node = this.elements.getByID(createdAt);
        return node === null || node === void 0 ? void 0 : node.getValue();
    }
    /**
     * `getHead` returns dummy head element.
     */
    getHead() {
        return this.elements.getHead();
    }
    /**
     * `getLast` returns last element.
     */
    getLast() {
        return this.elements.getLast();
    }
    /**
     * `getPrevCreatedAt` returns the creation time of the previous node.
     */
    getPrevCreatedAt(createdAt) {
        return this.elements.getPrevCreatedAt(createdAt);
    }
    /**
     * `delete` deletes the element of the given creation time.
     */
    delete(createdAt, editedAt) {
        return this.elements.delete(createdAt, editedAt);
    }
    /**
     * `deleteByIndex` deletes the element of given index and editedAt.
     */
    deleteByIndex(index, editedAt) {
        return this.elements.deleteByIndex(index, editedAt);
    }
    /**
     * `getLastCreatedAt` get last created element.
     */
    getLastCreatedAt() {
        return this.elements.getLastCreatedAt();
    }
    /**
     * `length` returns length of this elements.
     */
    get length() {
        return this.elements.length;
    }
    /**
     * eslint-disable-next-line jsdoc/require-jsdoc
     * @internal
     */
    *[Symbol.iterator]() {
        for (const node of this.elements) {
            if (!node.isRemoved()) {
                yield node.getValue();
            }
        }
    }
    /**
     * `toTestString` returns a String containing the meta data of this value
     * for debugging purpose.
     */
    toTestString() {
        return this.elements.toTestString();
    }
    /**
     * `getDescendants` traverse the descendants of this array.
     */
    getDescendants(callback) {
        for (const node of this.elements) {
            const element = node.getValue();
            if (callback(element, this)) {
                return;
            }
            if (element instanceof CRDTContainer) {
                element.getDescendants(callback);
            }
        }
    }
    /**
     * `toJSON` returns the JSON encoding of this array.
     */
    toJSON() {
        const json = [];
        for (const value of this) {
            json.push(value.toJSON());
        }
        return `[${json.join(',')}]`;
    }
    /**
     * `toJS` return the javascript object of this array.
     */
    toJS() {
        return JSON.parse(this.toJSON());
    }
    /**
     * `toJSForTest` returns value with meta data for testing.
     */
    toJSForTest() {
        const values = {};
        for (let i = 0; i < this.length; i++) {
            const { id, value, type } = this.get(i).toJSForTest();
            values[i] = {
                key: String(i),
                id,
                value,
                type,
            };
        }
        return {
            id: this.getCreatedAt().toTestString(),
            value: values,
            type: 'YORKIE_ARRAY',
        };
    }
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this array.
     */
    toSortedJSON() {
        return this.toJSON();
    }
    /**
     * `getElements` returns an array of elements contained in this RGATreeList.
     */
    getElements() {
        return this.elements;
    }
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy() {
        const clone = CRDTArray.create(this.getCreatedAt());
        for (const node of this.elements) {
            clone.elements.insertAfter(clone.getLastCreatedAt(), node.getValue().deepcopy());
        }
        clone.remove(this.getRemovedAt());
        return clone;
    }
}

;// CONCATENATED MODULE: ./src/document/operation/remove_operation.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * `RemoveOperation` is an operation that removes an element from `CRDTContainer`.
 */
class RemoveOperation extends Operation {
    constructor(parentCreatedAt, createdAt, executedAt) {
        super(parentCreatedAt, executedAt);
        this.createdAt = createdAt;
    }
    /**
     * `create` creates a new instance of RemoveOperation.
     */
    static create(parentCreatedAt, createdAt, executedAt) {
        return new RemoveOperation(parentCreatedAt, createdAt, executedAt);
    }
    /**
     * `execute` executes this operation on the given `CRDTRoot`.
     */
    execute(root, source) {
        var _a;
        const container = root.findByCreatedAt(this.getParentCreatedAt());
        if (!container) {
            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);
        }
        if (!(container instanceof CRDTContainer)) {
            logger.fatal(`only object and array can execute remove: ${container}`);
        }
        // NOTE(chacha912): Handle cases where operation cannot be executed during undo and redo.
        if (source === OpSource.UndoRedo) {
            let parent = container.getByID(this.createdAt);
            while (parent) {
                if (parent.getRemovedAt()) {
                    return;
                }
                parent = (_a = root.findElementPairByCreatedAt(parent.getCreatedAt())) === null || _a === void 0 ? void 0 : _a.parent;
            }
        }
        const key = container.subPathOf(this.createdAt);
        const reverseOp = this.toReverseOperation(container);
        const elem = container.delete(this.createdAt, this.getExecutedAt());
        root.registerRemovedElement(elem);
        const opInfos = container instanceof CRDTArray
            ? [
                {
                    type: 'remove',
                    path: root.createPath(this.getParentCreatedAt()),
                    index: Number(key),
                },
            ]
            : [
                {
                    type: 'remove',
                    path: root.createPath(this.getParentCreatedAt()),
                    key,
                },
            ];
        return { opInfos, reverseOp };
    }
    /**
     * `toReverseOperation` returns the reverse operation of this operation.
     */
    toReverseOperation(parentObject) {
        // TODO(Hyemmie): consider CRDTArray
        if (parentObject instanceof CRDTObject) {
            const key = parentObject.subPathOf(this.createdAt);
            if (key !== undefined) {
                const value = parentObject.get(key);
                if (value !== undefined) {
                    return SetOperation.create(key, value.deepcopy(), this.getParentCreatedAt());
                }
            }
        }
    }
    /**
     * `getEffectedCreatedAt` returns the creation time of the effected element.
     */
    getEffectedCreatedAt() {
        return this.getParentCreatedAt();
    }
    /**
     * `toTestString` returns a string containing the meta data.
     */
    toTestString() {
        return `${this.getParentCreatedAt().toTestString()}.REMOVE.${this.createdAt.toTestString()}`;
    }
    /**
     * `getCreatedAt` returns the creation time of the target element.
     */
    getCreatedAt() {
        return this.createdAt;
    }
}

;// CONCATENATED MODULE: ./src/document/operation/set_operation.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * `SetOperation` represents an operation that stores the value corresponding to the
 * given key in the Object.
 */
class SetOperation extends Operation {
    constructor(key, value, parentCreatedAt, executedAt) {
        super(parentCreatedAt, executedAt);
        this.key = key;
        this.value = value;
    }
    /**
     * `create` creates a new instance of SetOperation.
     */
    static create(key, value, parentCreatedAt, executedAt) {
        return new SetOperation(key, value, parentCreatedAt, executedAt);
    }
    /**
     * `execute` executes this operation on the given `CRDTRoot`.
     */
    execute(root, source) {
        var _a;
        const obj = root.findByCreatedAt(this.getParentCreatedAt());
        if (!obj) {
            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);
        }
        if (!(obj instanceof CRDTObject)) {
            logger.fatal(`fail to execute, only object can execute set`);
        }
        // NOTE(chacha912): Handle cases where operation cannot be executed during undo and redo.
        if (source === OpSource.UndoRedo) {
            let parent = obj;
            while (parent) {
                if (parent.getRemovedAt()) {
                    return;
                }
                parent = (_a = root.findElementPairByCreatedAt(parent.getCreatedAt())) === null || _a === void 0 ? void 0 : _a.parent;
            }
        }
        const previousValue = obj.get(this.key);
        const reverseOp = this.toReverseOperation(previousValue);
        const value = this.value.deepcopy();
        const removed = obj.set(this.key, value, this.getExecutedAt());
        // NOTE(chacha912): When resetting elements with the pre-existing createdAt
        // during undo/redo, it's essential to handle previously tombstoned elements.
        // In non-GC languages, there may be a need to execute both deregister and purge.
        if (source === OpSource.UndoRedo &&
            root.findByCreatedAt(value.getCreatedAt())) {
            root.deregisterElement(value);
        }
        root.registerElement(value, obj);
        if (removed) {
            root.registerRemovedElement(removed);
        }
        return {
            opInfos: [
                {
                    type: 'set',
                    path: root.createPath(this.getParentCreatedAt()),
                    key: this.key,
                },
            ],
            reverseOp,
        };
    }
    /**
     * `toReverseOperation` returns the reverse operation of this operation.
     */
    toReverseOperation(value) {
        let reverseOp = RemoveOperation.create(this.getParentCreatedAt(), this.value.getCreatedAt());
        if (value !== undefined && !value.isRemoved()) {
            reverseOp = SetOperation.create(this.key, value.deepcopy(), this.getParentCreatedAt());
        }
        return reverseOp;
    }
    /**
     * `getEffectedCreatedAt` returns the creation time of the effected element.
     */
    getEffectedCreatedAt() {
        return this.value.getCreatedAt();
    }
    /**
     * `toTestString` returns a string containing the meta data.
     */
    toTestString() {
        return `${this.getParentCreatedAt().toTestString()}.SET.${this.key}=${this.value.toSortedJSON()}`;
    }
    /**
     * `getKey` returns the key of this operation.
     */
    getKey() {
        return this.key;
    }
    /**
     * `getValue` returns the value of this operation.
     */
    getValue() {
        return this.value;
    }
}

;// CONCATENATED MODULE: ./src/document/operation/add_operation.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * `AddOperation` is an operation representing adding an element to an Array.
 */
class AddOperation extends Operation {
    constructor(parentCreatedAt, prevCreatedAt, value, executedAt) {
        super(parentCreatedAt, executedAt);
        this.prevCreatedAt = prevCreatedAt;
        this.value = value;
    }
    /**
     * `create` creates a new instance of AddOperation.
     */
    static create(parentCreatedAt, prevCreatedAt, value, executedAt) {
        return new AddOperation(parentCreatedAt, prevCreatedAt, value, executedAt);
    }
    /**
     * `execute` executes this operation on the given `CRDTRoot`.
     */
    execute(root) {
        const parentObject = root.findByCreatedAt(this.getParentCreatedAt());
        if (!parentObject) {
            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);
        }
        if (!(parentObject instanceof CRDTArray)) {
            logger.fatal(`fail to execute, only array can execute add`);
        }
        const array = parentObject;
        const value = this.value.deepcopy();
        array.insertAfter(this.prevCreatedAt, value);
        root.registerElement(value, array);
        return {
            opInfos: [
                {
                    type: 'add',
                    path: root.createPath(this.getParentCreatedAt()),
                    index: Number(array.subPathOf(this.getEffectedCreatedAt())),
                },
            ],
        };
    }
    /**
     * `getEffectedCreatedAt` returns the creation time of the effected element.
     */
    getEffectedCreatedAt() {
        return this.value.getCreatedAt();
    }
    /**
     * `toTestString` returns a string containing the meta data.
     */
    toTestString() {
        return `${this.getParentCreatedAt().toTestString()}.ADD.${this.value.toJSON()}`;
    }
    /**
     * `getPrevCreatedAt` returns the creation time of previous element.
     */
    getPrevCreatedAt() {
        return this.prevCreatedAt;
    }
    /**
     * `getValue` returns the value of this operation.
     */
    getValue() {
        return this.value;
    }
}

;// CONCATENATED MODULE: ./src/document/operation/move_operation.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * `MoveOperation` is an operation representing moving an element to an Array.
 */
class MoveOperation extends Operation {
    constructor(parentCreatedAt, prevCreatedAt, createdAt, executedAt) {
        super(parentCreatedAt, executedAt);
        this.prevCreatedAt = prevCreatedAt;
        this.createdAt = createdAt;
    }
    /**
     * `create` creates a new instance of MoveOperation.
     */
    static create(parentCreatedAt, prevCreatedAt, createdAt, executedAt) {
        return new MoveOperation(parentCreatedAt, prevCreatedAt, createdAt, executedAt);
    }
    /**
     * `execute` executes this operation on the given `CRDTRoot`.
     */
    execute(root) {
        const parentObject = root.findByCreatedAt(this.getParentCreatedAt());
        if (!parentObject) {
            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);
        }
        if (!(parentObject instanceof CRDTArray)) {
            logger.fatal(`fail to execute, only array can execute move`);
        }
        const array = parentObject;
        const previousIndex = Number(array.subPathOf(this.createdAt));
        array.moveAfter(this.prevCreatedAt, this.createdAt, this.getExecutedAt());
        const index = Number(array.subPathOf(this.createdAt));
        return {
            opInfos: [
                {
                    type: 'move',
                    path: root.createPath(this.getParentCreatedAt()),
                    index,
                    previousIndex,
                },
            ],
        };
    }
    /**
     * `getEffectedCreatedAt` returns the creation time of the effected element.
     */
    getEffectedCreatedAt() {
        return this.createdAt;
    }
    /**
     * `toTestString` returns a string containing the meta data.
     */
    toTestString() {
        return `${this.getParentCreatedAt().toTestString()}.MOVE`;
    }
    /**
     * `getPrevCreatedAt` returns the creation time of previous element.
     */
    getPrevCreatedAt() {
        return this.prevCreatedAt;
    }
    /**
     * `getCreatedAt` returns the creation time of the target element.
     */
    getCreatedAt() {
        return this.createdAt;
    }
}

;// CONCATENATED MODULE: ./src/document/crdt/rht.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * `RHTNode` is a node of RHT(Replicated Hashtable).
 */
class RHTNode {
    constructor(key, value, updatedAt) {
        this.key = key;
        this.value = value;
        this.updatedAt = updatedAt;
    }
    /**
     * `of` creates a new instance of RHTNode.
     */
    static of(key, value, createdAt) {
        return new RHTNode(key, value, createdAt);
    }
    /**
     * `getKey` returns a key of node.
     */
    getKey() {
        return this.key;
    }
    /**
     * `getValue` returns a value of node.
     */
    getValue() {
        return this.value;
    }
    /**
     * `getUpdatedAt `returns updated time of node.
     */
    getUpdatedAt() {
        return this.updatedAt;
    }
}
/**
 * RHT is replicated hash table by creation time.
 * For more details about RHT: @see http://csl.skku.edu/papers/jpdc11.pdf
 */
class RHT {
    constructor() {
        this.nodeMapByKey = new Map();
    }
    /**
     * `create` creates a new instance of RHT.
     */
    static create() {
        return new RHT();
    }
    /**
     * `set` sets the value of the given key.
     */
    set(key, value, executedAt) {
        const prev = this.nodeMapByKey.get(key);
        if (prev === undefined || executedAt.after(prev.getUpdatedAt())) {
            const node = RHTNode.of(key, value, executedAt);
            this.nodeMapByKey.set(key, node);
        }
    }
    /**
     * `has` returns whether the element exists of the given key or not.
     */
    has(key) {
        return this.nodeMapByKey.has(key);
    }
    /**
     * `get` returns the value of the given key.
     */
    get(key) {
        if (!this.nodeMapByKey.has(key)) {
            return;
        }
        return this.nodeMapByKey.get(key).getValue();
    }
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy() {
        const rht = new RHT();
        for (const [, node] of this.nodeMapByKey) {
            rht.set(node.getKey(), node.getValue(), node.getUpdatedAt());
        }
        return rht;
    }
    /**
     * `toJSON` returns the JSON encoding of this hashtable.
     */
    toJSON() {
        const items = [];
        for (const [key, node] of this.nodeMapByKey) {
            items.push(`"${key}":"${escapeString(node.getValue())}"`);
        }
        return `{${items.join(',')}}`;
    }
    /**
     * `toXML` converts the given RHT to XML string.
     */
    toXML() {
        if (!this.size()) {
            return '';
        }
        return ` ${[...this.nodeMapByKey]
            .map(([k, v]) => `${k}="${JSON.parse(v.getValue())}"`)
            .join(' ')}`;
    }
    /**
     * `size` returns the size of RHT
     */
    size() {
        return this.nodeMapByKey.size;
    }
    /**
     * `toObject` returns the object of this hashtable.
     */
    toObject() {
        const obj = {};
        for (const [key, node] of this.nodeMapByKey) {
            obj[key] = node.getValue();
        }
        return obj;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    *[Symbol.iterator]() {
        for (const [, node] of this.nodeMapByKey) {
            yield node;
        }
    }
}

;// CONCATENATED MODULE: ./src/document/crdt/text.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * `TextChangeType` is the type of TextChange.
 *
 */
var TextChangeType;
(function (TextChangeType) {
    TextChangeType["Content"] = "content";
    TextChangeType["Style"] = "style";
})(TextChangeType || (TextChangeType = {}));
/**
 * `CRDTTextValue` is a value of Text
 * which has a attributes that expresses the text style.
 * Attributes are represented by RHT.
 *
 */
class CRDTTextValue {
    /** @hideconstructor */
    constructor(content) {
        this.attributes = RHT.create();
        this.content = content;
    }
    /**
     * `create` creates a instance of CRDTTextValue.
     */
    static create(content) {
        return new CRDTTextValue(content);
    }
    /**
     * `length` returns the length of value.
     */
    get length() {
        return this.content.length;
    }
    /**
     * `substring` returns a sub-string value of the given range.
     */
    substring(indexStart, indexEnd) {
        const value = new CRDTTextValue(this.content.substring(indexStart, indexEnd));
        value.attributes = this.attributes.deepcopy();
        return value;
    }
    /**
     * `setAttr` sets attribute of the given key, updated time and value.
     */
    setAttr(key, content, updatedAt) {
        this.attributes.set(key, content, updatedAt);
    }
    /**
     * `getAttr` returns the attributes of this value.
     */
    getAttrs() {
        return this.attributes;
    }
    /**
     * `toString` returns the string representation of this value.
     */
    toString() {
        return this.content;
    }
    /**
     * `toJSON` returns the JSON encoding of this value.
     */
    toJSON() {
        const content = escapeString(this.content);
        const attrsObj = this.attributes.toObject();
        const attrs = [];
        for (const [key, v] of Object.entries(attrsObj)) {
            const value = JSON.parse(v);
            const item = typeof value === 'string'
                ? `"${key}":"${escapeString(value)}"`
                : `"${key}":${String(value)}`;
            attrs.push(item);
        }
        attrs.sort();
        if (attrs.length === 0) {
            return `{"val":"${content}"}`;
        }
        return `{"attrs":{${attrs.join(',')}},"val":"${content}"}`;
    }
    /**
     * `getAttributes` returns the attributes of this value.
     */
    getAttributes() {
        return this.attributes.toObject();
    }
    /**
     * `getContent` returns the internal content.
     */
    getContent() {
        return this.content;
    }
}
/**
 *  `CRDTText` is a custom CRDT data type to represent the contents of text editors.
 *
 */
class CRDTText extends CRDTGCElement {
    constructor(rgaTreeSplit, createdAt) {
        super(createdAt);
        this.rgaTreeSplit = rgaTreeSplit;
    }
    /**
     * `create` a instance of Text.
     */
    static create(rgaTreeSplit, createdAt) {
        return new CRDTText(rgaTreeSplit, createdAt);
    }
    /**
     * `edit` edits the given range with the given value and attributes.
     *
     * @internal
     */
    edit(range, content, editedAt, attributes, latestCreatedAtMapByActor) {
        const crdtTextValue = content ? CRDTTextValue.create(content) : undefined;
        if (crdtTextValue && attributes) {
            for (const [k, v] of Object.entries(attributes)) {
                crdtTextValue.setAttr(k, v, editedAt);
            }
        }
        const [caretPos, latestCreatedAtMap, valueChanges] = this.rgaTreeSplit.edit(range, editedAt, crdtTextValue, latestCreatedAtMapByActor);
        const changes = valueChanges.map((change) => ({
            ...change,
            value: change.value
                ? {
                    attributes: parseObjectValues(change.value.getAttributes()),
                    content: change.value.getContent(),
                }
                : {
                    attributes: undefined,
                    content: '',
                },
            type: TextChangeType.Content,
        }));
        return [latestCreatedAtMap, changes, [caretPos, caretPos]];
    }
    /**
     * `setStyle` applies the style of the given range.
     * 01. split nodes with from and to
     * 02. style nodes between from and to
     *
     * @param range - range of RGATreeSplitNode
     * @param attributes - style attributes
     * @param editedAt - edited time
     * @internal
     */
    setStyle(range, attributes, editedAt, latestCreatedAtMapByActor) {
        // 01. split nodes with from and to
        const [, toRight] = this.rgaTreeSplit.findNodeWithSplit(range[1], editedAt);
        const [, fromRight] = this.rgaTreeSplit.findNodeWithSplit(range[0], editedAt);
        // 02. style nodes between from and to
        const changes = [];
        const nodes = this.rgaTreeSplit.findBetween(fromRight, toRight);
        const createdAtMapByActor = new Map();
        const toBeStyleds = [];
        for (const node of nodes) {
            const actorID = node.getCreatedAt().getActorID();
            const latestCreatedAt = (latestCreatedAtMapByActor === null || latestCreatedAtMapByActor === void 0 ? void 0 : latestCreatedAtMapByActor.size)
                ? latestCreatedAtMapByActor.has(actorID)
                    ? latestCreatedAtMapByActor.get(actorID)
                    : InitialTimeTicket
                : MaxTimeTicket;
            if (node.canStyle(editedAt, latestCreatedAt)) {
                const latestCreatedAt = createdAtMapByActor.get(actorID);
                const createdAt = node.getCreatedAt();
                if (!latestCreatedAt || createdAt.after(latestCreatedAt)) {
                    createdAtMapByActor.set(actorID, createdAt);
                }
                toBeStyleds.push(node);
            }
        }
        for (const node of toBeStyleds) {
            if (node.isRemoved()) {
                continue;
            }
            const [fromIdx, toIdx] = this.rgaTreeSplit.findIndexesFromRange(node.createPosRange());
            changes.push({
                type: TextChangeType.Style,
                actor: editedAt.getActorID(),
                from: fromIdx,
                to: toIdx,
                value: {
                    attributes: parseObjectValues(attributes),
                },
            });
            for (const [key, value] of Object.entries(attributes)) {
                node.getValue().setAttr(key, value, editedAt);
            }
        }
        return [createdAtMapByActor, changes];
    }
    /**
     * `indexRangeToPosRange` returns the position range of the given index range.
     */
    indexRangeToPosRange(fromIdx, toIdx) {
        const fromPos = this.rgaTreeSplit.indexToPos(fromIdx);
        if (fromIdx === toIdx) {
            return [fromPos, fromPos];
        }
        return [fromPos, this.rgaTreeSplit.indexToPos(toIdx)];
    }
    /**
     * `length` returns size of RGATreeList.
     */
    get length() {
        return this.rgaTreeSplit.length;
    }
    /**
     * `checkWeight` returns false when there is an incorrect weight node.
     * for debugging purpose.
     */
    checkWeight() {
        return this.rgaTreeSplit.checkWeight();
    }
    /**
     * `toJSON` returns the JSON encoding of this text.
     */
    toJSON() {
        const json = [];
        for (const node of this.rgaTreeSplit) {
            if (!node.isRemoved()) {
                json.push(node.getValue().toJSON());
            }
        }
        return `[${json.join(',')}]`;
    }
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this text.
     */
    toSortedJSON() {
        return this.toJSON();
    }
    /**
     * `toJSForTest` returns value with meta data for testing.
     */
    toJSForTest() {
        return {
            id: this.getCreatedAt().toTestString(),
            value: JSON.parse(this.toJSON()),
            type: 'YORKIE_TEXT',
        };
    }
    /**
     * `toString` returns the string representation of this text.
     */
    toString() {
        return this.rgaTreeSplit.toString();
    }
    /**
     * `values` returns the content-attributes pair array of this text.
     */
    values() {
        const values = [];
        for (const node of this.rgaTreeSplit) {
            if (!node.isRemoved()) {
                const value = node.getValue();
                values.push({
                    attributes: parseObjectValues(value.getAttributes()),
                    content: value.getContent(),
                });
            }
        }
        return values;
    }
    /**
     * `getRGATreeSplit` returns rgaTreeSplit.
     *
     * @internal
     */
    getRGATreeSplit() {
        return this.rgaTreeSplit;
    }
    /**
     * `toTestString` returns a String containing the meta data of this value
     * for debugging purpose.
     */
    toTestString() {
        return this.rgaTreeSplit.toTestString();
    }
    /**
     * `getRemovedNodesLen` returns length of removed nodes
     */
    getRemovedNodesLen() {
        return this.rgaTreeSplit.getRemovedNodesLen();
    }
    /**
     * `purgeRemovedNodesBefore` purges removed nodes before the given time.
     *
     * @internal
     */
    purgeRemovedNodesBefore(ticket) {
        return this.rgaTreeSplit.purgeRemovedNodesBefore(ticket);
    }
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy() {
        const text = new CRDTText(this.rgaTreeSplit.deepcopy(), this.getCreatedAt());
        text.remove(this.getRemovedAt());
        return text;
    }
    /**
     * `findIndexesFromRange` returns pair of integer offsets of the given range.
     */
    findIndexesFromRange(range) {
        return this.rgaTreeSplit.findIndexesFromRange(range);
    }
}

;// CONCATENATED MODULE: ./src/document/operation/edit_operation.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * `EditOperation` is an operation representing editing Text. Most of the same as
 * Edit, but with additional style properties, attributes.
 */
class EditOperation extends Operation {
    constructor(parentCreatedAt, fromPos, toPos, maxCreatedAtMapByActor, content, attributes, executedAt) {
        super(parentCreatedAt, executedAt);
        this.fromPos = fromPos;
        this.toPos = toPos;
        this.maxCreatedAtMapByActor = maxCreatedAtMapByActor;
        this.content = content;
        this.attributes = attributes;
    }
    /**
     * `create` creates a new instance of EditOperation.
     */
    static create(parentCreatedAt, fromPos, toPos, maxCreatedAtMapByActor, content, attributes, executedAt) {
        return new EditOperation(parentCreatedAt, fromPos, toPos, maxCreatedAtMapByActor, content, attributes, executedAt);
    }
    /**
     * `execute` executes this operation on the given `CRDTRoot`.
     */
    execute(root) {
        const parentObject = root.findByCreatedAt(this.getParentCreatedAt());
        if (!parentObject) {
            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);
        }
        if (!(parentObject instanceof CRDTText)) {
            logger.fatal(`fail to execute, only Text can execute edit`);
        }
        const text = parentObject;
        const [, changes] = text.edit([this.fromPos, this.toPos], this.content, this.getExecutedAt(), Object.fromEntries(this.attributes), this.maxCreatedAtMapByActor);
        if (!this.fromPos.equals(this.toPos)) {
            root.registerElementHasRemovedNodes(text);
        }
        return {
            opInfos: changes.map(({ from, to, value }) => {
                return {
                    type: 'edit',
                    from,
                    to,
                    value,
                    path: root.createPath(this.getParentCreatedAt()),
                };
            }),
        };
    }
    /**
     * `getEffectedCreatedAt` returns the creation time of the effected element.
     */
    getEffectedCreatedAt() {
        return this.getParentCreatedAt();
    }
    /**
     * `toTestString` returns a string containing the meta data.
     */
    toTestString() {
        const parent = this.getParentCreatedAt().toTestString();
        const fromPos = this.fromPos.toTestString();
        const toPos = this.toPos.toTestString();
        const content = this.content;
        return `${parent}.EDIT(${fromPos},${toPos},${content})`;
    }
    /**
     * `getFromPos` returns the start point of the editing range.
     */
    getFromPos() {
        return this.fromPos;
    }
    /**
     * `getToPos` returns the end point of the editing range.
     */
    getToPos() {
        return this.toPos;
    }
    /**
     * `getContent` returns the content of Edit.
     */
    getContent() {
        return this.content;
    }
    /**
     * `getAttributes` returns the attributes of this Edit.
     */
    getAttributes() {
        return this.attributes || new Map();
    }
    /**
     * `getMaxCreatedAtMapByActor` returns the map that stores the latest creation time
     * by actor for the nodes included in the editing range.
     */
    getMaxCreatedAtMapByActor() {
        return this.maxCreatedAtMapByActor;
    }
}

;// CONCATENATED MODULE: ./src/document/operation/style_operation.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 *  `StyleOperation` is an operation applies the style of the given range to Text.
 */
class StyleOperation extends Operation {
    constructor(parentCreatedAt, fromPos, toPos, maxCreatedAtMapByActor, attributes, executedAt) {
        super(parentCreatedAt, executedAt);
        this.fromPos = fromPos;
        this.toPos = toPos;
        this.maxCreatedAtMapByActor = maxCreatedAtMapByActor;
        this.attributes = attributes;
    }
    /**
     * `create` creates a new instance of StyleOperation.
     */
    static create(parentCreatedAt, fromPos, toPos, maxCreatedAtMapByActor, attributes, executedAt) {
        return new StyleOperation(parentCreatedAt, fromPos, toPos, maxCreatedAtMapByActor, attributes, executedAt);
    }
    /**
     * `execute` executes this operation on the given `CRDTRoot`.
     */
    execute(root) {
        const parentObject = root.findByCreatedAt(this.getParentCreatedAt());
        if (!parentObject) {
            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);
        }
        if (!(parentObject instanceof CRDTText)) {
            logger.fatal(`fail to execute, only Text can execute edit`);
        }
        const text = parentObject;
        const [, changes] = text.setStyle([this.fromPos, this.toPos], this.attributes ? Object.fromEntries(this.attributes) : {}, this.getExecutedAt(), this.maxCreatedAtMapByActor);
        return {
            opInfos: changes.map(({ from, to, value }) => {
                return {
                    type: 'style',
                    from,
                    to,
                    value,
                    path: root.createPath(this.getParentCreatedAt()),
                };
            }),
        };
    }
    /**
     * `getEffectedCreatedAt` returns the creation time of the effected element.
     */
    getEffectedCreatedAt() {
        return this.getParentCreatedAt();
    }
    /**
     * `toTestString` returns a string containing the meta data.
     */
    toTestString() {
        const parent = this.getParentCreatedAt().toTestString();
        const fromPos = this.fromPos.toTestString();
        const toPos = this.toPos.toTestString();
        const attributes = this.attributes;
        return `${parent}.STYL(${fromPos},${toPos},${JSON.stringify(attributes)})`;
    }
    /**
     * `getFromPos` returns the start point of the editing range.
     */
    getFromPos() {
        return this.fromPos;
    }
    /**
     * `getToPos` returns the end point of the editing range.
     */
    getToPos() {
        return this.toPos;
    }
    /**
     * `getAttributes` returns the attributes of this operation.
     */
    getAttributes() {
        return this.attributes;
    }
    /**
     * `getMaxCreatedAtMapByActor` returns the map that stores the latest creation time
     * by actor for the nodes included in the editing range.
     */
    getMaxCreatedAtMapByActor() {
        return this.maxCreatedAtMapByActor;
    }
}

;// CONCATENATED MODULE: ./src/util/index_tree.ts
/*
 * Copyright 2023 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * About `index`, `path`, `size` and `TreePos` in crdt.IndexTree.
 *
 * `index` of crdt.IndexTree represents a absolute position of a node in the tree.
 * `size` is used to calculate the relative index of nodes in the tree.
 * `index` in yorkie.IndexTree inspired by ProseMirror's index.
 *
 * For example, empty paragraph's size is 0 and index 0 is the position of the:
 *    0
 * <p> </p>,                                p.size = 0
 *
 * If a paragraph has <i>, its size becomes 2 and there are 3 indexes:
 *     0   1    2
 *  <p> <i> </i> </p>                       p.size = 2, i.size = 0
 *
 * If the paragraph has <i> and <b>, its size becomes 4:
 *     0   1    2   3   4
 *  <p> <i> </i> <b> </b> </p>              p.size = 4, i.size = 0, b.size = 0
 *     0   1    2   3    4    5   6
 *  <p> <i> </i> <b> </b> <s> </s> </p>     p.size = 6, i.size = 0, b.size = 0, s.size = 0
 *
 * If a paragraph has text, its size becomes length of the characters:
 *     0 1 2 3
 *  <p> A B C </p>                          p.size = 3,   text.size = 3
 *
 * So the size of a node is the sum of the size and type of its children:
 *  `size = children(element type).length * 2 + children.reduce((child, acc) => child.size + acc, 0)`
 *
 * `TreePos` is also used to represent the position in the tree. It contains node and offset.
 * `TreePos` can be converted to `index` and vice versa.
 *
 * For example, if a paragraph has <i>, there are 3 indexes:
 *     0   1    2
 *  <p> <i> </i> </p>                       p.size = 2, i.size = 0
 *
 * In this case, index of TreePos(p, 0) is 0, index of TreePos(p, 1) is 2.
 * Index 1 can be converted to TreePos(i, 0).
 *
 * `path` of crdt.IndexTree represents a position like `index` in crdt.IndexTree.
 * It contains offsets of each node from the root node as elements except the last.
 * The last element of the path represents the position in the parent node.
 *
 * Let's say we have a tree like this:
 *                     0 1 2
 * <p> <i> a b </i> <b> c d </b> </p>
 *
 * The path of the position between 'c' and 'd' is [1, 1]. The first element of the
 * path is the offset of the <b> in <p> and the second element represents the position
 * between 'c' and 'd' in <b>.
 */
/**
 * `ElementPaddingSize` is the size of an element node as a child of another element node.
 * Because an element node could be considered as a pair of open and close tags.
 */
const ElementPaddingSize = 2;
/**
 * `DefaultRootType` is the default type of the root node.
 * It is used when the type of the root node is not specified.
 */
const DefaultRootType = 'root';
/**
 * `DefaultTextType` is the default type of the text node.
 * It is used when the type of the text node is not specified.
 */
const DefaultTextType = 'text';
/**
 * `addSizeOfLeftSiblings` returns the size of left siblings of the given offset.
 */
function addSizeOfLeftSiblings(parent, offset) {
    let acc = 0;
    const siblings = parent.children;
    for (let i = 0; i < offset; i++) {
        const leftSibling = siblings[i];
        if (!leftSibling || leftSibling.isRemoved) {
            continue;
        }
        acc += leftSibling.paddedSize;
    }
    return acc;
}
/**
 * `IndexTreeNode` is the node of IndexTree. It is used to represent the
 * document of text-based editors.
 */
class IndexTreeNode {
    constructor(type, children = []) {
        this.type = type;
        this.size = 0;
        this._children = children;
        if (this.isText && this._children.length > 0) {
            throw new Error(`Text node cannot have children: ${this.type}`);
        }
    }
    /**
     * `updateAncestorsSize` updates the size of the ancestors.
     */
    updateAncestorsSize() {
        let parent = this.parent;
        const sign = this.isRemoved ? -1 : 1;
        while (parent) {
            parent.size += this.paddedSize * sign;
            parent = parent.parent;
        }
    }
    /**
     * `isText` returns true if the node is a text node.
     */
    get isText() {
        // TODO(hackerwins): We need to get the type of text node from user.
        // Consider the use schema to get the type of text node.
        return this.type === DefaultTextType;
    }
    /**
     * `paddedSize` returns the size of the node including padding size.
     */
    get paddedSize() {
        return this.size + (this.isText ? 0 : ElementPaddingSize);
    }
    /**
     * `isAncenstorOf` returns true if the node is an ancestor of the given node.
     */
    isAncestorOf(node) {
        return ancestorOf(this, node);
    }
    /**
     * `nextSibling` returns the next sibling of the node.
     */
    get nextSibling() {
        const offset = this.parent.findOffset(this);
        const sibling = this.parent.children[offset + 1];
        if (sibling) {
            return sibling;
        }
        return undefined;
    }
    /**
     * `split` splits the node at the given offset.
     */
    split(offset, absOffset) {
        if (this.isText) {
            return this.splitText(offset, absOffset);
        }
        return this.splitElement(offset);
    }
    /**
     * `splitText` splits the given node at the given offset.
     */
    splitText(offset, absOffset) {
        if (offset === 0 || offset === this.size) {
            return;
        }
        const leftValue = this.value.slice(0, offset);
        const rightValue = this.value.slice(offset);
        if (!rightValue.length) {
            return;
        }
        this.value = leftValue;
        const rightNode = this.clone(offset + absOffset);
        rightNode.value = rightValue;
        this.parent.insertAfterInternal(rightNode, this);
        return rightNode;
    }
    /**
     * `children` returns the children of the node.
     */
    get children() {
        // Tombstone nodes remain awhile in the tree during editing.
        // They will be removed after the editing is done.
        // So, we need to filter out the tombstone nodes to get the real children.
        return this._children.filter((child) => !child.isRemoved);
    }
    /**
     * `allChildren` returns all the children of the node including tombstone nodes.
     * It returns the shallow copy of the children.
     */
    get allChildren() {
        return [...this._children];
    }
    /**
     * `hasTextChild` returns true if the node has an text child.
     */
    hasTextChild() {
        return this.children.some((child) => child.isText);
    }
    /**
     * `append` appends the given nodes to the children.
     */
    append(...newNode) {
        if (this.isText) {
            throw new Error('Text node cannot have children');
        }
        this._children.push(...newNode);
        for (const node of newNode) {
            node.parent = this;
            node.updateAncestorsSize();
        }
    }
    /**
     * `prepend` prepends the given nodes to the children.
     */
    prepend(...newNode) {
        if (this.isText) {
            throw new Error('Text node cannot have children');
        }
        this._children.unshift(...newNode);
        for (const node of newNode) {
            node.parent = this;
            if (!node.isRemoved) {
                node.updateAncestorsSize();
            }
        }
    }
    /**
     * `insertBefore` inserts the given node before the given child.
     */
    insertBefore(newNode, referenceNode) {
        if (this.isText) {
            throw new Error('Text node cannot have children');
        }
        const offset = this._children.indexOf(referenceNode);
        if (offset === -1) {
            throw new Error('child not found');
        }
        this.insertAtInternal(newNode, offset);
        newNode.updateAncestorsSize();
    }
    /**
     * `insertAfter` inserts the given node after the given child.
     */
    insertAfter(newNode, referenceNode) {
        if (this.isText) {
            throw new Error('Text node cannot have children');
        }
        const offset = this._children.indexOf(referenceNode);
        if (offset === -1) {
            throw new Error('child not found');
        }
        this.insertAtInternal(newNode, offset + 1);
        newNode.updateAncestorsSize();
    }
    /**
     * `insertAt` inserts the given node at the given offset.
     */
    insertAt(newNode, offset) {
        if (this.isText) {
            throw new Error('Text node cannot have children');
        }
        this.insertAtInternal(newNode, offset);
        newNode.updateAncestorsSize();
    }
    /**
     * `removeChild` removes the given child.
     */
    removeChild(child) {
        if (this.isText) {
            throw new Error('Text node cannot have children');
        }
        const offset = this._children.indexOf(child);
        if (offset === -1) {
            throw new Error('child not found');
        }
        this._children.splice(offset, 1);
        child.parent = undefined;
    }
    /**
     * `splitElement` splits the given element at the given offset.
     */
    splitElement(offset) {
        const clone = this.clone(offset);
        this.parent.insertAfterInternal(clone, this);
        clone.updateAncestorsSize();
        const leftChildren = this.children.slice(0, offset);
        const rightChildren = this.children.slice(offset);
        this._children = leftChildren;
        clone._children = rightChildren;
        this.size = this._children.reduce((acc, child) => acc + child.paddedSize, 0);
        clone.size = clone._children.reduce((acc, child) => acc + child.paddedSize, 0);
        for (const child of clone._children) {
            child.parent = clone;
        }
        return clone;
    }
    /**
     * `insertAfterInternal` inserts the given node after the given child.
     * This method does not update the size of the ancestors.
     */
    insertAfterInternal(newNode, referenceNode) {
        if (this.isText) {
            throw new Error('Text node cannot have children');
        }
        const offset = this._children.indexOf(referenceNode);
        if (offset === -1) {
            throw new Error('child not found');
        }
        this.insertAtInternal(newNode, offset + 1);
    }
    /**
     * `insertAtInternal` inserts the given node at the given index.
     * This method does not update the size of the ancestors.
     */
    insertAtInternal(newNode, offset) {
        if (this.isText) {
            throw new Error('Text node cannot have children');
        }
        this._children.splice(offset, 0, newNode);
        newNode.parent = this;
    }
    /**
     * findOffset returns the offset of the given node in the children.
     * It excludes the removed nodes.
     */
    findOffset(node) {
        if (this.isText) {
            throw new Error('Text node cannot have children');
        }
        if (node.isRemoved) {
            const index = this._children.indexOf(node);
            // If nodes are removed, the offset of the removed node is the number of
            // nodes before the node excluding the removed nodes.
            const refined = this.allChildren
                .splice(0, index)
                .filter((node) => !node.isRemoved).length;
            return refined;
        }
        return this.children.indexOf(node);
    }
    /**
     * `findBranchOffset` returns offset of the given descendant node in this node.
     * If the given node is not a descendant of this node, it returns -1.
     */
    findBranchOffset(node) {
        if (this.isText) {
            throw new Error('Text node cannot have children');
        }
        let current = node;
        while (current) {
            const offset = this._children.indexOf(current);
            if (offset !== -1) {
                return offset;
            }
            current = current.parent;
        }
        return -1;
    }
}
/**
 * `ancestorOf` returns true if the given node is an ancestor of the other node.
 */
function ancestorOf(ancestor, node) {
    if (ancestor === node) {
        return false;
    }
    while (node.parent) {
        if (node.parent === ancestor) {
            return true;
        }
        node = node.parent;
    }
    return false;
}
// TagContained represents whether the opening or closing tag of a element is selected.
var TagContained;
(function (TagContained) {
    // All represents that both opening and closing tag of a element are selected.
    TagContained["All"] = "All";
    // Opening represents that only the opening tag is selected.
    TagContained["Opening"] = "Opening";
    // Closing represents that only the closing tag is selected.
    TagContained["Closing"] = "Closing";
})(TagContained || (TagContained = {}));
/**
 * `nodesBetween` iterates the nodes between the given range.
 * If the given range is collapsed, the callback is not called.
 * It traverses the tree with postorder traversal.
 * NOTE(sejongk): Nodes should not be removed in callback, because it leads wrong behaviors.
 */
function nodesBetween(root, from, to, callback) {
    if (from > to) {
        throw new Error(`from is greater than to: ${from} > ${to}`);
    }
    if (from > root.size) {
        throw new Error(`from is out of range: ${from} > ${root.size}`);
    }
    if (to > root.size) {
        throw new Error(`to is out of range: ${to} > ${root.size}`);
    }
    if (from === to) {
        return;
    }
    let pos = 0;
    for (const child of root.children) {
        // If the child is an element node, the size of the child.
        if (from - child.paddedSize < pos && pos < to) {
            // If the child is an element node, the range of the child
            // is from - 1 to to - 1. Because the range of the element node is from
            // the open tag to the close tag.
            const fromChild = child.isText ? from - pos : from - pos - 1;
            const toChild = child.isText ? to - pos : to - pos - 1;
            nodesBetween(child, Math.max(0, fromChild), Math.min(toChild, child.size), callback);
            // If the range spans outside the child,
            // the callback is called with the child.
            if (fromChild < 0 || toChild > child.size || child.isText) {
                let contain;
                if ((fromChild < 0 && toChild > child.size) || child.isText) {
                    contain = TagContained.All;
                }
                else if (fromChild < 0) {
                    contain = TagContained.Opening;
                }
                else {
                    contain = TagContained.Closing;
                }
                callback(child, contain);
            }
        }
        pos += child.paddedSize;
    }
}
/**
 * `traverse` traverses the tree with postorder traversal.
 */
function traverse(node, callback, depth = 0) {
    for (const child of node.children) {
        traverse(child, callback, depth + 1);
    }
    callback(node, depth);
}
/**
 * `traverseAll` traverses the whole tree (include tombstones) with postorder traversal.
 */
function traverseAll(node, callback, depth = 0) {
    for (const child of node._children) {
        traverseAll(child, callback, depth + 1);
    }
    callback(node, depth);
}
/**
 * `findTreePos` finds the position of the given index in the given node.
 */
function findTreePos(node, index, preferText = true) {
    if (index > node.size) {
        throw new Error(`index is out of range: ${index} > ${node.size}`);
    }
    if (node.isText) {
        return { node, offset: index };
    }
    // offset is the index of the child node.
    // pos is the window of the index in the given node.
    let offset = 0;
    let pos = 0;
    for (const child of node.children) {
        // The pos is in bothsides of the text node, we should traverse
        // inside of the text node if preferText is true.
        if (preferText && child.isText && child.size >= index - pos) {
            return findTreePos(child, index - pos, preferText);
        }
        // The position is in leftside of the element node.
        if (index === pos) {
            return { node, offset };
        }
        // The position is in rightside of the element node and preferText is false.
        if (!preferText && child.paddedSize === index - pos) {
            return { node, offset: offset + 1 };
        }
        // The position is in middle the element node.
        if (child.paddedSize > index - pos) {
            // If we traverse inside of the element node, we should skip the open.
            const skipOpenSize = 1;
            return findTreePos(child, index - pos - skipOpenSize, preferText);
        }
        pos += child.paddedSize;
        offset += 1;
    }
    // The position is in rightmost of the given node.
    return { node, offset };
}
/**
 * `getAncestors` returns the ancestors of the given node.
 */
function getAncestors(node) {
    const ancestors = [];
    let parent = node.parent;
    while (parent) {
        ancestors.unshift(parent);
        parent = parent.parent;
    }
    return ancestors;
}
/**
 * `findCommonAncestor` finds the lowest common ancestor of the given nodes.
 */
function findCommonAncestor(nodeA, nodeB) {
    if (nodeA === nodeB) {
        return nodeA;
    }
    const ancestorsOfA = getAncestors(nodeA);
    const ancestorsOfB = getAncestors(nodeB);
    let commonAncestor;
    for (let i = 0; i < ancestorsOfA.length; i++) {
        const ancestorOfA = ancestorsOfA[i];
        const ancestorOfB = ancestorsOfB[i];
        if (ancestorOfA !== ancestorOfB) {
            break;
        }
        commonAncestor = ancestorOfA;
    }
    return commonAncestor;
}
/**
 * `findLeftmost` finds the leftmost node of the given tree.
 */
function findLeftmost(node) {
    if (node.isText || node.children.length === 0) {
        return node;
    }
    return findLeftmost(node.children[0]);
}
/**
 * `findTextPos` returns the tree position of the given path element.
 */
function findTextPos(node, pathElement) {
    if (node.size < pathElement) {
        throw new Error('unacceptable path');
    }
    for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (child.size < pathElement) {
            pathElement -= child.size;
        }
        else {
            node = child;
            break;
        }
    }
    return { node, offset: pathElement };
}
/**
 * `IndexTree` is a tree structure for linear indexing.
 */
class IndexTree {
    constructor(root) {
        this.root = root;
    }
    /**
     * `nodeBetween` returns the nodes between the given range.
     */
    nodesBetween(from, to, callback) {
        nodesBetween(this.root, from, to, callback);
    }
    /**
     * `traverse` traverses the tree with postorder traversal.
     */
    traverse(callback) {
        traverse(this.root, callback, 0);
    }
    /**
     * `traverseAll` traverses the whole tree (include tombstones) with postorder traversal.
     */
    traverseAll(callback) {
        traverseAll(this.root, callback, 0);
    }
    /**
     * `split` splits the node at the given index.
     */
    split(index, depth = 1) {
        const treePos = findTreePos(this.root, index, true);
        let node = treePos.node;
        let offset = treePos.offset;
        for (let i = 0; i < depth && node && node !== this.root; i++) {
            node.split(offset, 0);
            const nextOffset = node.parent.findOffset(node);
            offset = offset === 0 ? nextOffset : nextOffset + 1;
            node = node.parent;
        }
        return treePos;
    }
    /**
     * findTreePos finds the position of the given index in the tree.
     */
    findTreePos(index, preferText = true) {
        return findTreePos(this.root, index, preferText);
    }
    /**
     * `treePosToPath` returns path from given treePos
     */
    treePosToPath(treePos) {
        const path = [];
        let node = treePos.node;
        if (node.isText) {
            const offset = node.parent.findOffset(node);
            if (offset === -1) {
                throw new Error('invalid treePos');
            }
            const sizeOfLeftSiblings = addSizeOfLeftSiblings(node.parent, offset);
            node = node.parent;
            path.push(sizeOfLeftSiblings + treePos.offset);
        }
        else {
            path.push(treePos.offset);
        }
        while (node.parent) {
            const offset = node.parent.findOffset(node);
            if (offset === -1) {
                throw new Error('invalid treePos');
            }
            path.push(offset);
            node = node.parent;
        }
        return path.reverse();
    }
    /**
     * `pathToIndex` returns index from given path
     */
    pathToIndex(path) {
        const treePos = this.pathToTreePos(path);
        return this.indexOf(treePos);
    }
    /**
     * `pathToTreePos` returns treePos from given path
     */
    pathToTreePos(path) {
        if (!path.length) {
            throw new Error('unacceptable path');
        }
        let node = this.root;
        for (let i = 0; i < path.length - 1; i++) {
            const pathElement = path[i];
            node = node.children[pathElement];
            if (!node) {
                throw new Error('unacceptable path');
            }
        }
        if (node.hasTextChild()) {
            return findTextPos(node, path[path.length - 1]);
        }
        if (node.children.length < path[path.length - 1]) {
            throw new Error('unacceptable path');
        }
        return {
            node,
            offset: path[path.length - 1],
        };
    }
    /**
     * `getRoot` returns the root node of the tree.
     */
    getRoot() {
        return this.root;
    }
    /**
     * `getSize` returns the size of the tree.
     */
    get size() {
        return this.root.size;
    }
    /**
     * `findPostorderRight` finds right node of the given tree position with
     *  postorder traversal.
     */
    findPostorderRight(treePos) {
        const { node, offset } = treePos;
        if (node.isText) {
            if (node.size === offset) {
                const nextSibling = node.nextSibling;
                if (nextSibling) {
                    return nextSibling;
                }
                return node.parent;
            }
            return node;
        }
        if (node.children.length === offset) {
            return node;
        }
        return findLeftmost(node.children[offset]);
    }
    /**
     * `indexOf` returns the index of the given tree position.
     */
    indexOf(pos) {
        let { node } = pos;
        const { offset } = pos;
        let size = 0;
        let depth = 1;
        if (node.isText) {
            size += offset;
            const parent = node.parent;
            const offsetOfNode = parent.findOffset(node);
            if (offsetOfNode === -1) {
                throw new Error('invalid pos');
            }
            size += addSizeOfLeftSiblings(parent, offsetOfNode);
            node = node.parent;
        }
        else {
            size += addSizeOfLeftSiblings(node, offset);
        }
        while (node === null || node === void 0 ? void 0 : node.parent) {
            const parent = node.parent;
            const offsetOfNode = parent.findOffset(node);
            if (offsetOfNode === -1) {
                throw new Error('invalid pos');
            }
            size += addSizeOfLeftSiblings(parent, offsetOfNode);
            depth++;
            node = node.parent;
        }
        return size + depth - 1;
    }
    /**
     * `indexToPath` returns the path of the given index.
     */
    indexToPath(index) {
        const treePos = this.findTreePos(index);
        return this.treePosToPath(treePos);
    }
}

;// CONCATENATED MODULE: ./src/util/comparator.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
const DefaultComparator = (a, b) => {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
};

;// CONCATENATED MODULE: ./src/util/llrb_tree.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * `LLRBNode` is node of LLRBTree.
 */
class LLRBNode {
    constructor(key, value, isRed) {
        this.key = key;
        this.value = value;
        this.isRed = isRed;
    }
}
/**
 * `SortedMapIterator` is a interator for traversing LLRBTree.
 */
class SortedMapIterator {
    constructor(root) {
        this.stack = [];
        this.traverseInorder(root);
    }
    // TODO: Replace with iterative approach, if we encounter performance problem.
    traverseInorder(node) {
        if (!node) {
            return;
        }
        this.traverseInorder(node.left);
        this.stack.push({
            key: node.key,
            value: node.value,
        });
        this.traverseInorder(node.right);
    }
}
/**
 * LLRBTree is an implementation of Left-learning Red-Black Tree.
 *
 * Original paper on Left-leaning Red-Black Trees:
 * @see http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf
 *
 * Invariant 1: No red node has a red child
 * Invariant 2: Every leaf path has the same number of black nodes
 * Invariant 3: Only the left child can be red (left leaning)
 */
class LLRBTree {
    constructor(comparator) {
        this.comparator =
            typeof comparator !== 'undefined' ? comparator : DefaultComparator;
        this.counter = 0;
    }
    /**
     * `put` puts the value of the given key.
     */
    put(key, value) {
        this.root = this.putInternal(key, value, this.root);
        this.root.isRed = false;
        return value;
    }
    /**
     * `get` gets a value of the given key.
     */
    get(key) {
        const node = this.getInternal(key, this.root);
        return node ? node.value : undefined;
    }
    /**
     * `remove` removes a element of key.
     */
    remove(key) {
        if (!this.isRed(this.root.left) && !this.isRed(this.root.right)) {
            this.root.isRed = true;
        }
        this.root = this.removeInternal(this.root, key);
        if (this.root) {
            this.root.isRed = false;
        }
    }
    /**
     * `getIterator` returns a new instance of SortedMapIterator.
     */
    getIterator() {
        return new SortedMapIterator(this.root);
    }
    /**
     * `values` returns value array of LLRBTree.
     */
    values() {
        const values = [];
        for (const entry of this.getIterator().stack) {
            values.push(entry.value);
        }
        return values;
    }
    /**
     * `floorEntry` returns the entry for the greatest key less than or equal to the
     *  given key. If there is no such key, returns `undefined`.
     */
    floorEntry(key) {
        let node = this.root;
        while (node) {
            const compare = this.comparator(key, node.key);
            if (compare > 0) {
                if (node.right) {
                    node.right.parent = node;
                    node = node.right;
                }
                else {
                    return node;
                }
            }
            else if (compare < 0) {
                if (node.left) {
                    node.left.parent = node;
                    node = node.left;
                }
                else {
                    let parent = node.parent;
                    let childNode = node;
                    while (parent && childNode === parent.left) {
                        childNode = parent;
                        parent = parent.parent;
                    }
                    return parent;
                }
            }
            else {
                return node;
            }
        }
        return;
    }
    /**
     * `lastEntry` returns last entry of LLRBTree.
     */
    lastEntry() {
        if (!this.root) {
            return this.root;
        }
        let node = this.root;
        while (node.right) {
            node = node.right;
        }
        return node;
    }
    /**
     * `size` is a size of LLRBTree.
     */
    size() {
        return this.counter;
    }
    /**
     * `isEmpty` checks if size is empty.
     */
    isEmpty() {
        return this.counter === 0;
    }
    getInternal(key, node) {
        while (node) {
            const compare = this.comparator(key, node.key);
            if (compare === 0) {
                return node;
            }
            else if (compare < 0) {
                node = node.left;
            }
            else if (compare > 0) {
                node = node.right;
            }
        }
        return;
    }
    putInternal(key, value, node) {
        if (!node) {
            this.counter += 1;
            return new LLRBNode(key, value, true);
        }
        const compare = this.comparator(key, node.key);
        if (compare < 0) {
            node.left = this.putInternal(key, value, node.left);
        }
        else if (compare > 0) {
            node.right = this.putInternal(key, value, node.right);
        }
        else {
            node.value = value;
        }
        if (this.isRed(node.right) && !this.isRed(node.left)) {
            node = this.rotateLeft(node);
        }
        if (this.isRed(node.left) && this.isRed(node.left.left)) {
            node = this.rotateRight(node);
        }
        if (this.isRed(node.left) && this.isRed(node.right)) {
            this.flipColors(node);
        }
        return node;
    }
    removeInternal(node, key) {
        if (this.comparator(key, node.key) < 0) {
            if (!this.isRed(node.left) && !this.isRed(node.left.left)) {
                node = this.moveRedLeft(node);
            }
            node.left = this.removeInternal(node.left, key);
        }
        else {
            if (this.isRed(node.left)) {
                node = this.rotateRight(node);
            }
            if (this.comparator(key, node.key) === 0 && !node.right) {
                this.counter -= 1;
                return;
            }
            if (!this.isRed(node.right) && !this.isRed(node.right.left)) {
                node = this.moveRedRight(node);
            }
            if (this.comparator(key, node.key) === 0) {
                this.counter -= 1;
                const smallest = this.min(node.right);
                node.value = smallest.value;
                node.key = smallest.key;
                node.right = this.removeMin(node.right);
            }
            else {
                node.right = this.removeInternal(node.right, key);
            }
        }
        return this.fixUp(node);
    }
    min(node) {
        if (!node.left) {
            return node;
        }
        else {
            return this.min(node.left);
        }
    }
    removeMin(node) {
        if (!node.left) {
            return;
        }
        if (!this.isRed(node.left) && !this.isRed(node.left.left)) {
            node = this.moveRedLeft(node);
        }
        node.left = this.removeMin(node.left);
        return this.fixUp(node);
    }
    fixUp(node) {
        if (this.isRed(node.right)) {
            node = this.rotateLeft(node);
        }
        if (this.isRed(node.left) && this.isRed(node.left.left)) {
            node = this.rotateRight(node);
        }
        if (this.isRed(node.left) && this.isRed(node.right)) {
            this.flipColors(node);
        }
        return node;
    }
    moveRedLeft(node) {
        this.flipColors(node);
        if (this.isRed(node.right.left)) {
            node.right = this.rotateRight(node.right);
            node = this.rotateLeft(node);
            this.flipColors(node);
        }
        return node;
    }
    moveRedRight(node) {
        this.flipColors(node);
        if (this.isRed(node.left.left)) {
            node = this.rotateRight(node);
            this.flipColors(node);
        }
        return node;
    }
    isRed(node) {
        return node && node.isRed;
    }
    rotateLeft(node) {
        const x = node.right;
        node.right = x.left;
        x.left = node;
        x.isRed = x.left.isRed;
        x.left.isRed = true;
        return x;
    }
    rotateRight(node) {
        const x = node.left;
        node.left = x.right;
        x.right = node;
        x.isRed = x.right.isRed;
        x.right.isRed = true;
        return x;
    }
    flipColors(node) {
        node.isRed = !node.isRed;
        node.left.isRed = !node.left.isRed;
        node.right.isRed = !node.right.isRed;
    }
}

;// CONCATENATED MODULE: ./src/document/crdt/tree.ts
/*
 * Copyright 2023 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * `TreeChangeType` represents the type of change in the tree.
 */
var TreeChangeType;
(function (TreeChangeType) {
    TreeChangeType["Content"] = "content";
    TreeChangeType["Style"] = "style";
})(TreeChangeType || (TreeChangeType = {}));
/**
 * `CRDTTreePos` represent a position in the tree. It is used to identify a
 * position in the tree. It is composed of the parent ID and the left sibling
 * ID. If there's no left sibling in parent's children, then left sibling is
 * parent.
 */
class CRDTTreePos {
    constructor(parentID, leftSiblingID) {
        this.parentID = parentID;
        this.leftSiblingID = leftSiblingID;
    }
    /**
     * `of` creates a new instance of CRDTTreePos.
     */
    static of(parentID, leftSiblingID) {
        return new CRDTTreePos(parentID, leftSiblingID);
    }
    /**
     * `fromTreePos` creates a new instance of CRDTTreePos from the given TreePos.
     */
    static fromTreePos(pos) {
        const { offset } = pos;
        let { node } = pos;
        let leftSibling;
        if (node.isText) {
            if (node.parent.children[0] === node && offset === 0) {
                leftSibling = node.parent;
            }
            else {
                leftSibling = node;
            }
            node = node.parent;
        }
        else {
            if (offset === 0) {
                leftSibling = node;
            }
            else {
                leftSibling = node.children[offset - 1];
            }
        }
        return CRDTTreePos.of(node.id, CRDTTreeNodeID.of(leftSibling.getCreatedAt(), leftSibling.getOffset() + offset));
    }
    /**
     * `getParentID` returns the parent ID.
     */
    getParentID() {
        return this.parentID;
    }
    /**
     * `fromStruct` creates a new instance of CRDTTreeNodeID from the given struct.
     */
    static fromStruct(struct) {
        return CRDTTreePos.of(CRDTTreeNodeID.of(TimeTicket.fromStruct(struct.parentID.createdAt), struct.parentID.offset), CRDTTreeNodeID.of(TimeTicket.fromStruct(struct.leftSiblingID.createdAt), struct.leftSiblingID.offset));
    }
    /**
     * `toStruct` returns the structure of this position.
     */
    toStruct() {
        return {
            parentID: {
                createdAt: this.getParentID().getCreatedAt().toStruct(),
                offset: this.getParentID().getOffset(),
            },
            leftSiblingID: {
                createdAt: this.getLeftSiblingID().getCreatedAt().toStruct(),
                offset: this.getLeftSiblingID().getOffset(),
            },
        };
    }
    /**
     * `toTreeNodes` converts the pos to parent and left sibling nodes.
     */
    toTreeNodes(tree) {
        const parentID = this.getParentID();
        const leftSiblingID = this.getLeftSiblingID();
        const parentNode = tree.findFloorNode(parentID);
        let leftNode = tree.findFloorNode(leftSiblingID);
        if (!parentNode || !leftNode) {
            throw new Error(`cannot find node at ${this}`);
        }
        if (leftSiblingID.getOffset() > 0 &&
            leftSiblingID.getOffset() === leftNode.id.getOffset() &&
            leftNode.insPrevID) {
            leftNode = tree.findFloorNode(leftNode.insPrevID) || leftNode;
        }
        return [parentNode, leftNode];
    }
    /**
     * `getLeftSiblingID` returns the left sibling ID.
     */
    getLeftSiblingID() {
        return this.leftSiblingID;
    }
    /**
     * `equals` returns whether the given pos equals to this or not.
     */
    equals(other) {
        return (this.getParentID()
            .getCreatedAt()
            .equals(other.getParentID().getCreatedAt()) &&
            this.getParentID().getOffset() === other.getParentID().getOffset() &&
            this.getLeftSiblingID()
                .getCreatedAt()
                .equals(other.getLeftSiblingID().getCreatedAt()) &&
            this.getLeftSiblingID().getOffset() ===
                other.getLeftSiblingID().getOffset());
    }
}
/**
 * `CRDTTreeNodeID` represent an ID of a node in the tree. It is used to
 * identify a node in the tree. It is composed of the creation time of the node
 * and the offset from the beginning of the node if the node is split.
 *
 * Some of replicas may have nodes that are not split yet. In this case, we can
 * use `map.floorEntry()` to find the adjacent node.
 */
class CRDTTreeNodeID {
    constructor(createdAt, offset) {
        this.createdAt = createdAt;
        this.offset = offset;
    }
    /**
     * `of` creates a new instance of CRDTTreeNodeID.
     */
    static of(createdAt, offset) {
        return new CRDTTreeNodeID(createdAt, offset);
    }
    /**
     * `fromStruct` creates a new instance of CRDTTreeNodeID from the given struct.
     */
    static fromStruct(struct) {
        return CRDTTreeNodeID.of(TimeTicket.fromStruct(struct.createdAt), struct.offset);
    }
    /**
     * `createComparator` creates a comparator for CRDTTreeNodeID.
     */
    static createComparator() {
        return (idA, idB) => {
            const compare = idA.getCreatedAt().compare(idB.getCreatedAt());
            if (compare !== 0) {
                return compare;
            }
            if (idA.getOffset() > idB.getOffset()) {
                return 1;
            }
            else if (idA.getOffset() < idB.getOffset()) {
                return -1;
            }
            return 0;
        };
    }
    /**
     * `getCreatedAt` returns the creation time of the node.
     */
    getCreatedAt() {
        return this.createdAt;
    }
    /**
     * `equals` returns whether given ID equals to this ID or not.
     */
    equals(other) {
        return (this.createdAt.compare(other.createdAt) === 0 &&
            this.offset === other.offset);
    }
    /**
     * `getOffset` returns returns the offset of the node.
     */
    getOffset() {
        return this.offset;
    }
    /**
     * `setOffset` sets the offset of the node.
     */
    setOffset(offset) {
        this.offset = offset;
    }
    /**
     * `toStruct` returns the structure of this position.
     */
    toStruct() {
        return {
            createdAt: this.createdAt.toStruct(),
            offset: this.offset,
        };
    }
    /**
     * `toIDString` returns a string that can be used as an ID for this position.
     */
    toIDString() {
        return `${this.createdAt.toIDString()}:${this.offset}`;
    }
}
/**
 * `CRDTTreeNode` is a node of CRDTTree. It is includes the logical clock and
 * links to other nodes to resolve conflicts.
 */
class CRDTTreeNode extends IndexTreeNode {
    constructor(id, type, opts, attributes, removedAt) {
        super(type);
        this._value = '';
        this.id = id;
        this.removedAt = removedAt;
        attributes && (this.attrs = attributes);
        if (typeof opts === 'string') {
            this.value = opts;
        }
        else if (Array.isArray(opts)) {
            this._children = opts;
        }
    }
    /**
     * `create` creates a new instance of CRDTTreeNode.
     */
    static create(id, type, opts, attributes) {
        return new CRDTTreeNode(id, type, opts, attributes);
    }
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy() {
        var _a;
        const clone = new CRDTTreeNode(this.id, this.type);
        clone.removedAt = this.removedAt;
        clone._value = this._value;
        clone.size = this.size;
        clone.attrs = (_a = this.attrs) === null || _a === void 0 ? void 0 : _a.deepcopy();
        clone._children = this._children.map((child) => {
            const childClone = child.deepcopy();
            childClone.parent = clone;
            return childClone;
        });
        return clone;
    }
    /**
     * `value` returns the value of the node.
     */
    get value() {
        if (!this.isText) {
            throw new Error(`cannot get value of element node: ${this.type}`);
        }
        return this._value;
    }
    /**
     * `value` sets the value of the node.
     */
    set value(v) {
        if (!this.isText) {
            throw new Error(`cannot set value of element node: ${this.type}`);
        }
        this._value = v;
        this.size = v.length;
    }
    /**
     * `isRemoved` returns whether the node is removed or not.
     */
    get isRemoved() {
        return !!this.removedAt;
    }
    /**
     * `remove` marks the node as removed.
     */
    remove(removedAt) {
        const alived = !this.removedAt;
        if (!this.removedAt || this.removedAt.compare(removedAt) > 0) {
            this.removedAt = removedAt;
        }
        if (alived) {
            this.updateAncestorsSize();
        }
    }
    /**
     * `clone` clones this node with the given offset.
     */
    clone(offset) {
        return new CRDTTreeNode(CRDTTreeNodeID.of(this.id.getCreatedAt(), offset), this.type, undefined, undefined, this.removedAt);
    }
    /**
     * `getCreatedAt` returns the creation time of this element.
     */
    getCreatedAt() {
        return this.id.getCreatedAt();
    }
    /**
     * `getOffset` returns the offset of a pos.
     */
    getOffset() {
        return this.id.getOffset();
    }
    /**
     * `canDelete` checks if node is able to delete.
     */
    canDelete(editedAt, latestCreatedAt) {
        return (!this.getCreatedAt().after(latestCreatedAt) &&
            (!this.removedAt || editedAt.after(this.removedAt)));
    }
}
/**
 * toTreeNode converts the given CRDTTreeNode to TreeNode.
 */
function toTreeNode(node) {
    var _a;
    if (node.isText) {
        const currentNode = node;
        return {
            type: currentNode.type,
            value: currentNode.value,
        };
    }
    return {
        type: node.type,
        children: node.children.map(toTreeNode),
        attributes: node.attrs
            ? parseObjectValues((_a = node.attrs) === null || _a === void 0 ? void 0 : _a.toObject())
            : undefined,
    };
}
/**
 * toXML converts the given CRDTNode to XML string.
 */
function toXML(node) {
    var _a;
    if (node.isText) {
        const currentNode = node;
        return currentNode.value;
    }
    return `<${node.type}${((_a = node.attrs) === null || _a === void 0 ? void 0 : _a.toXML()) || ''}>${node.children
        .map((child) => toXML(child))
        .join('')}</${node.type}>`;
}
/**
 * `toTestTreeNode` converts the given CRDTNode JSON for debugging.
 */
function toTestTreeNode(node) {
    if (node.isText) {
        const currentNode = node;
        return {
            type: currentNode.type,
            value: currentNode.value,
            size: currentNode.size,
            isRemoved: currentNode.isRemoved,
        };
    }
    return {
        type: node.type,
        children: node.children.map(toTestTreeNode),
        size: node.size,
        isRemoved: node.isRemoved,
    };
}
/**
 * `CRDTTree` is a CRDT implementation of a tree.
 */
class CRDTTree extends CRDTGCElement {
    constructor(root, createdAt) {
        super(createdAt);
        this.indexTree = new IndexTree(root);
        this.nodeMapByID = new LLRBTree(CRDTTreeNodeID.createComparator());
        this.removedNodeMap = new Map();
        this.indexTree.traverse((node) => {
            this.nodeMapByID.put(node.id, node);
        });
    }
    /**
     * `create` creates a new instance of `CRDTTree`.
     */
    static create(root, ticket) {
        return new CRDTTree(root, ticket);
    }
    /**
     * `findFloorNode` finds node of given id.
     */
    findFloorNode(id) {
        const entry = this.nodeMapByID.floorEntry(id);
        if (!entry || !entry.key.getCreatedAt().equals(id.getCreatedAt())) {
            return;
        }
        return entry.value;
    }
    /**
     * `findNodesAndSplit` finds `TreePos` of the given `CRDTTreeNodeID` and
     * splits nodes for the given split level.
     *
     * The ids of the given `pos` are the ids of the node in the CRDT perspective.
     * This is different from `TreePos` which is a position of the tree in the
     * physical perspective.
     */
    findNodesAndSplit(pos, editedAt) {
        // 01. Find the parent and left sibling node of the given position.
        const [parent, leftSibling] = pos.toTreeNodes(this);
        let leftNode = leftSibling;
        // 02. Split nodes for the given split level.
        if (leftNode.isText) {
            const absOffset = leftNode.id.getOffset();
            const split = leftNode.split(pos.getLeftSiblingID().getOffset() - absOffset, absOffset);
            if (split) {
                split.insPrevID = leftNode.id;
                if (leftNode.insNextID) {
                    const insNext = this.findFloorNode(leftNode.insNextID);
                    insNext.insPrevID = split.id;
                    split.insNextID = leftNode.insNextID;
                }
                leftNode.insNextID = split.id;
                this.nodeMapByID.put(split.id, split);
            }
        }
        // 03. Find the appropriate left node. If some nodes are inserted at the
        // same position concurrently, then we need to find the appropriate left
        // node. This is similar to RGA.
        const allChildren = parent.allChildren;
        const index = parent === leftNode ? 0 : allChildren.indexOf(leftNode) + 1;
        for (let i = index; i < parent.allChildren.length; i++) {
            const next = allChildren[i];
            if (!next.id.getCreatedAt().after(editedAt)) {
                break;
            }
            leftNode = next;
        }
        return [parent, leftNode];
    }
    /**
     * `style` applies the given attributes of the given range.
     */
    style(range, attributes, editedAt) {
        const [fromParent, fromLeft] = this.findNodesAndSplit(range[0], editedAt);
        const [toParent, toLeft] = this.findNodesAndSplit(range[1], editedAt);
        const changes = [];
        changes.push({
            type: TreeChangeType.Style,
            from: this.toIndex(fromParent, fromLeft),
            to: this.toIndex(toParent, toLeft),
            fromPath: this.toPath(fromParent, fromLeft),
            toPath: this.toPath(toParent, toLeft),
            actor: editedAt.getActorID(),
            value: attributes ? parseObjectValues(attributes) : undefined,
        });
        this.traverseInPosRange(fromParent, fromLeft, toParent, toLeft, (node) => {
            if (!node.isRemoved && !node.isText && attributes) {
                if (!node.attrs) {
                    node.attrs = new RHT();
                }
                for (const [key, value] of Object.entries(attributes)) {
                    node.attrs.set(key, value, editedAt);
                }
            }
        });
        return changes;
    }
    /**
     * `edit` edits the tree with the given range and content.
     * If the content is undefined, the range will be removed.
     */
    edit(range, contents, editedAt, latestCreatedAtMapByActor) {
        // 01. split text nodes at the given range if needed.
        const [fromParent, fromLeft] = this.findNodesAndSplit(range[0], editedAt);
        const [toParent, toLeft] = this.findNodesAndSplit(range[1], editedAt);
        // TODO(hackerwins): If concurrent deletion happens, we need to seperate the
        // range(from, to) into multiple ranges.
        const changes = [];
        changes.push({
            type: TreeChangeType.Content,
            from: this.toIndex(fromParent, fromLeft),
            to: this.toIndex(toParent, toLeft),
            fromPath: this.toPath(fromParent, fromLeft),
            toPath: this.toPath(toParent, toLeft),
            actor: editedAt.getActorID(),
            value: (contents === null || contents === void 0 ? void 0 : contents.length)
                ? contents.map((content) => toTreeNode(content))
                : undefined,
        });
        const toBeRemoveds = [];
        const toBeMovedToFromParents = [];
        const latestCreatedAtMap = new Map();
        this.traverseInPosRange(fromParent, fromLeft, toParent, toLeft, (node, contain) => {
            // NOTE(hackerwins): If the node overlaps as a closing tag with the
            // range then we need to keep the node.
            if (!node.isText && contain == TagContained.Closing) {
                return;
            }
            // NOTE(hackerwins): If the node overlaps as an opening tag with the
            // range then we need to move the remaining children to fromParent.
            if (!node.isText && contain == TagContained.Opening) {
                // TODO(hackerwins): Define more clearly merge-able rules
                // between two parents. For now, we only merge two parents are
                // both element nodes having text children.
                // e.g. <p>a|b</p><p>c|d</p> -> <p>a|d</p>
                if (!fromParent.hasTextChild() || !toParent.hasTextChild()) {
                    return;
                }
                for (const child of node.children) {
                    if (toBeRemoveds.includes(child)) {
                        continue;
                    }
                    toBeMovedToFromParents.push(child);
                }
            }
            const actorID = node.getCreatedAt().getActorID();
            const latestCreatedAt = latestCreatedAtMapByActor
                ? latestCreatedAtMapByActor.has(actorID)
                    ? latestCreatedAtMapByActor.get(actorID)
                    : InitialTimeTicket
                : MaxTimeTicket;
            if (node.canDelete(editedAt, latestCreatedAt)) {
                const latestCreatedAt = latestCreatedAtMap.get(actorID);
                const createdAt = node.getCreatedAt();
                if (!latestCreatedAt || createdAt.after(latestCreatedAt)) {
                    latestCreatedAtMap.set(actorID, createdAt);
                }
                toBeRemoveds.push(node);
            }
        });
        for (const node of toBeRemoveds) {
            node.remove(editedAt);
            if (node.isRemoved) {
                this.removedNodeMap.set(node.id.toIDString(), node);
            }
        }
        for (const node of toBeMovedToFromParents) {
            fromParent.append(node);
        }
        // 03. insert the given node at the given position.
        if (contents === null || contents === void 0 ? void 0 : contents.length) {
            let leftInChildren = fromLeft; // tree
            for (const content of contents) {
                // 03-1. insert the content nodes to the tree.
                if (leftInChildren === fromParent) {
                    // 03-1-1. when there's no leftSibling, then insert content into very front of parent's children List
                    fromParent.insertAt(content, 0);
                }
                else {
                    // 03-1-2. insert after leftSibling
                    fromParent.insertAfter(content, leftInChildren);
                }
                leftInChildren = content;
                traverseAll(content, (node) => {
                    // if insertion happens during concurrent editing and parent node has been removed,
                    // make new nodes as tombstone immediately
                    if (fromParent.isRemoved) {
                        node.remove(editedAt);
                        this.removedNodeMap.set(node.id.toIDString(), node);
                    }
                    this.nodeMapByID.put(node.id, node);
                });
            }
        }
        return [changes, latestCreatedAtMap];
    }
    /**
     * `editT` edits the given range with the given value.
     * This method uses indexes instead of a pair of TreePos for testing.
     */
    editT(range, contents, editedAt) {
        const fromPos = this.findPos(range[0]);
        const toPos = this.findPos(range[1]);
        this.edit([fromPos, toPos], contents, editedAt);
    }
    /**
     * `move` move the given source range to the given target range.
     */
    move(target, source, ticket) {
        // TODO(hackerwins, easylogic): Implement this with keeping references of the nodes.
        throw new Error(`not implemented: ${target}, ${source}, ${ticket}`);
    }
    /**
     * `purgeRemovedNodesBefore` physically purges nodes that have been removed.
     */
    purgeRemovedNodesBefore(ticket) {
        var _a;
        const nodesToBeRemoved = new Set();
        let count = 0;
        for (const [, node] of this.removedNodeMap) {
            if (node.removedAt && ticket.compare(node.removedAt) >= 0) {
                nodesToBeRemoved.add(node);
                count++;
            }
        }
        for (const node of nodesToBeRemoved) {
            (_a = node.parent) === null || _a === void 0 ? void 0 : _a.removeChild(node);
            this.nodeMapByID.remove(node.id);
            this.purge(node);
            this.removedNodeMap.delete(node.id.toIDString());
        }
        return count;
    }
    /**
     * `purge` physically purges the given node from RGATreeSplit.
     */
    purge(node) {
        const insPrevID = node.insPrevID;
        const insNextID = node.insNextID;
        if (insPrevID) {
            const insPrev = this.findFloorNode(insPrevID);
            insPrev.insNextID = insNextID;
        }
        if (insNextID) {
            const insNext = this.findFloorNode(insNextID);
            insNext.insPrevID = insPrevID;
        }
        node.insPrevID = undefined;
        node.insNextID = undefined;
    }
    /**
     * `findPos` finds the position of the given index in the tree.
     */
    findPos(index, preferText = true) {
        const treePos = this.indexTree.findTreePos(index, preferText);
        return CRDTTreePos.fromTreePos(treePos);
    }
    /**
     * `getRemovedNodesLen` returns size of removed nodes.
     */
    getRemovedNodesLen() {
        return this.removedNodeMap.size;
    }
    /**
     * `pathToPosRange` converts the given path of the node to the range of the position.
     */
    pathToPosRange(path) {
        const fromIdx = this.pathToIndex(path);
        return [this.findPos(fromIdx), this.findPos(fromIdx + 1)];
    }
    /**
     * `pathToPos` finds the position of the given index in the tree by path.
     */
    pathToPos(path) {
        const index = this.indexTree.pathToIndex(path);
        return this.findPos(index);
    }
    /**
     * `getRoot` returns the root node of the tree.
     */
    getRoot() {
        return this.indexTree.getRoot();
    }
    /**
     * `getSize` returns the size of the tree.
     */
    getSize() {
        return this.indexTree.size;
    }
    /**
     * `getIndexTree` returns the index tree.
     */
    getIndexTree() {
        return this.indexTree;
    }
    /**
     * toXML returns the XML encoding of this tree.
     */
    toXML() {
        return toXML(this.indexTree.getRoot());
    }
    /**
     * `toJSON` returns the JSON encoding of this tree.
     */
    toJSON() {
        return JSON.stringify(this.getRootTreeNode());
    }
    /**
     * `toJSForTest` returns value with meta data for testing.
     */
    toJSForTest() {
        return {
            id: this.getCreatedAt().toTestString(),
            value: JSON.parse(this.toJSON()),
            type: 'YORKIE_TREE',
        };
    }
    /**
     * `getRootTreeNode` returns the converted value of this tree to TreeNode.
     */
    getRootTreeNode() {
        return toTreeNode(this.indexTree.getRoot());
    }
    /**
     * `toTestTreeNode` returns the JSON of this tree for debugging.
     */
    toTestTreeNode() {
        return toTestTreeNode(this.indexTree.getRoot());
    }
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this tree.
     */
    toSortedJSON() {
        return this.toJSON();
    }
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy() {
        const root = this.getRoot();
        return new CRDTTree(root.deepcopy(), this.getCreatedAt());
    }
    /**
     * `toPath` converts the given CRDTTreeNodeID to the path of the tree.
     */
    toPath(parentNode, leftSiblingNode) {
        const treePos = this.toTreePos(parentNode, leftSiblingNode);
        if (!treePos) {
            return [];
        }
        return this.indexTree.treePosToPath(treePos);
    }
    /**
     * `toIndex` converts the given CRDTTreeNodeID to the index of the tree.
     */
    toIndex(parentNode, leftSiblingNode) {
        const treePos = this.toTreePos(parentNode, leftSiblingNode);
        if (!treePos) {
            return -1;
        }
        return this.indexTree.indexOf(treePos);
    }
    /**
     * `indexToPath` converts the given tree index to path.
     */
    indexToPath(index) {
        return this.indexTree.indexToPath(index);
    }
    /**
     * `pathToIndex` converts the given path to index.
     */
    pathToIndex(path) {
        return this.indexTree.pathToIndex(path);
    }
    /**
     * `indexRangeToPosRange` returns the position range from the given index range.
     */
    indexRangeToPosRange(range) {
        const fromPos = this.findPos(range[0]);
        if (range[0] === range[1]) {
            return [fromPos, fromPos];
        }
        return [fromPos, this.findPos(range[1])];
    }
    /**
     * `indexRangeToPosStructRange` converts the integer index range into the Tree position range structure.
     */
    indexRangeToPosStructRange(range) {
        const [fromIdx, toIdx] = range;
        const fromPos = this.findPos(fromIdx);
        if (fromIdx === toIdx) {
            return [fromPos.toStruct(), fromPos.toStruct()];
        }
        return [fromPos.toStruct(), this.findPos(toIdx).toStruct()];
    }
    /**
     * `posRangeToPathRange` converts the given position range to the path range.
     */
    posRangeToPathRange(range, timeTicket) {
        const [fromParent, fromLeft] = this.findNodesAndSplit(range[0], timeTicket);
        const [toParent, toLeft] = this.findNodesAndSplit(range[1], timeTicket);
        return [this.toPath(fromParent, fromLeft), this.toPath(toParent, toLeft)];
    }
    /**
     * `posRangeToIndexRange` converts the given position range to the path range.
     */
    posRangeToIndexRange(range, timeTicket) {
        const [fromParent, fromLeft] = this.findNodesAndSplit(range[0], timeTicket);
        const [toParent, toLeft] = this.findNodesAndSplit(range[1], timeTicket);
        return [this.toIndex(fromParent, fromLeft), this.toIndex(toParent, toLeft)];
    }
    /**
     * `traverseInPosRange` traverses the tree in the given position range.
     */
    traverseInPosRange(fromParent, fromLeft, toParent, toLeft, callback) {
        const fromIdx = this.toIndex(fromParent, fromLeft);
        const toIdx = this.toIndex(toParent, toLeft);
        return this.indexTree.nodesBetween(fromIdx, toIdx, callback);
    }
    /**
     * `toTreePos` converts the given nodes to the position of the IndexTree.
     */
    toTreePos(parentNode, leftSiblingNode) {
        if (!parentNode || !leftSiblingNode) {
            return;
        }
        if (parentNode.isRemoved) {
            let childNode;
            while (parentNode.isRemoved) {
                childNode = parentNode;
                parentNode = childNode.parent;
            }
            const offset = parentNode.findOffset(childNode);
            return {
                node: parentNode,
                offset,
            };
        }
        if (parentNode === leftSiblingNode) {
            return {
                node: parentNode,
                offset: 0,
            };
        }
        let offset = parentNode.findOffset(leftSiblingNode);
        if (!leftSiblingNode.isRemoved) {
            if (leftSiblingNode.isText) {
                return {
                    node: leftSiblingNode,
                    offset: leftSiblingNode.paddedSize,
                };
            }
            offset++;
        }
        return {
            node: parentNode,
            offset,
        };
    }
}

;// CONCATENATED MODULE: ./src/document/operation/tree_edit_operation.ts
/*
 * Copyright 2023 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * `TreeEditOperation` is an operation representing Tree editing.
 */
class TreeEditOperation extends Operation {
    constructor(parentCreatedAt, fromPos, toPos, maxCreatedAtMapByActor, contents, executedAt) {
        super(parentCreatedAt, executedAt);
        this.fromPos = fromPos;
        this.toPos = toPos;
        this.contents = contents;
        this.maxCreatedAtMapByActor = maxCreatedAtMapByActor;
    }
    /**
     * `create` creates a new instance of EditOperation.
     */
    static create(parentCreatedAt, fromPos, toPos, maxCreatedAtMapByActor, contents, executedAt) {
        return new TreeEditOperation(parentCreatedAt, fromPos, toPos, maxCreatedAtMapByActor, contents, executedAt);
    }
    /**
     * `execute` executes this operation on the given `CRDTRoot`.
     */
    execute(root) {
        var _a;
        const parentObject = root.findByCreatedAt(this.getParentCreatedAt());
        if (!parentObject) {
            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);
        }
        if (!(parentObject instanceof CRDTTree)) {
            logger.fatal(`fail to execute, only Tree can execute edit`);
        }
        const tree = parentObject;
        // TODO(hackerwins): Implement splitLevels.
        const [changes] = tree.edit([this.fromPos, this.toPos], (_a = this.contents) === null || _a === void 0 ? void 0 : _a.map((content) => content.deepcopy()), this.getExecutedAt(), this.maxCreatedAtMapByActor);
        if (!this.fromPos.equals(this.toPos)) {
            root.registerElementHasRemovedNodes(tree);
        }
        return {
            opInfos: changes.map(({ from, to, value, fromPath, toPath }) => {
                return {
                    type: 'tree-edit',
                    from,
                    to,
                    value,
                    fromPath,
                    toPath,
                    path: root.createPath(this.getParentCreatedAt()),
                };
            }),
        };
    }
    /**
     * `getEffectedCreatedAt` returns the creation time of the effected element.
     */
    getEffectedCreatedAt() {
        return this.getParentCreatedAt();
    }
    /**
     * `toTestString` returns a string containing the meta data.
     */
    toTestString() {
        const parent = this.getParentCreatedAt().toTestString();
        const fromPos = `${this.fromPos
            .getLeftSiblingID()
            .getCreatedAt()
            .toTestString()}:${this.fromPos.getLeftSiblingID().getOffset()}`;
        const toPos = `${this.toPos
            .getLeftSiblingID()
            .getCreatedAt()
            .toTestString()}:${this.toPos.getLeftSiblingID().getOffset()}`;
        const contents = this.contents;
        return `${parent}.EDIT(${fromPos},${toPos},${contents === null || contents === void 0 ? void 0 : contents.join('')})`;
    }
    /**
     * `getFromPos` returns the start point of the editing range.
     */
    getFromPos() {
        return this.fromPos;
    }
    /**
     * `getToPos` returns the end point of the editing range.
     */
    getToPos() {
        return this.toPos;
    }
    /**
     * `getContent` returns the content of Edit.
     */
    getContents() {
        return this.contents;
    }
    /**
     * `getMaxCreatedAtMapByActor` returns the map that stores the latest creation time
     * by actor for the nodes included in the editing range.
     */
    getMaxCreatedAtMapByActor() {
        return this.maxCreatedAtMapByActor;
    }
}

;// CONCATENATED MODULE: ./src/document/change/change_id.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * `ChangeID` is for identifying the Change. This is immutable.
 */
class ChangeID {
    constructor(clientSeq, lamport, actor) {
        this.clientSeq = clientSeq;
        this.lamport = lamport;
        this.actor = actor;
    }
    /**
     * `of` creates a new instance of ChangeID.
     */
    static of(clientSeq, lamport, actor) {
        return new ChangeID(clientSeq, lamport, actor);
    }
    /**
     * `next` creates a next ID of this ID.
     */
    next() {
        return new ChangeID(this.clientSeq + 1, this.lamport.add(1), this.actor);
    }
    /**
     * `syncLamport` syncs lamport timestamp with the given ID.
     *
     * {@link https://en.wikipedia.org/wiki/Lamport_timestamps#Algorithm}
     */
    syncLamport(otherLamport) {
        if (otherLamport.greaterThan(this.lamport)) {
            return new ChangeID(this.clientSeq, otherLamport, this.actor);
        }
        return new ChangeID(this.clientSeq, this.lamport.add(1), this.actor);
    }
    /**
     * `createTimeTicket` creates a ticket of the given delimiter.
     */
    createTimeTicket(delimiter) {
        return TimeTicket.of(this.lamport, delimiter, this.actor);
    }
    /**
     * `setActor` sets the given actor.
     */
    setActor(actorID) {
        return new ChangeID(this.clientSeq, this.lamport, actorID);
    }
    /**
     * `getClientSeq` returns the client sequence of this ID.
     */
    getClientSeq() {
        return this.clientSeq;
    }
    /**
     * `getLamport` returns the lamport clock of this ID.
     */
    getLamport() {
        return this.lamport;
    }
    /**
     * `getLamportAsString` returns the lamport clock of this ID as a string.
     */
    getLamportAsString() {
        return this.lamport.toString();
    }
    /**
     * `getActorID` returns the actor of this ID.
     */
    getActorID() {
        return this.actor;
    }
    /**
     * `toTestString` returns a string containing the meta data of this ID.
     */
    toTestString() {
        if (!this.actor) {
            return `${this.lamport.toString()}:nil:${this.clientSeq}`;
        }
        return `${this.lamport.toString()}:${this.actor.substring(22, 24)}:${this.clientSeq}`;
    }
}
/**
 * `InitialChangeID` represents the initial state ID. Usually this is used to
 * represent a state where nothing has been edited.
 */
const InitialChangeID = new ChangeID(0, node_modules_long.fromInt(0, true), InitialActorID);

;// CONCATENATED MODULE: ./src/document/change/change.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * `Change` represents a unit of modification in the document.
 */
class Change {
    constructor({ id, operations, presenceChange, message, }) {
        this.id = id;
        this.operations = operations || [];
        this.presenceChange = presenceChange;
        this.message = message;
    }
    /**
     * `create` creates a new instance of Change.
     */
    static create({ id, operations, presenceChange, message, }) {
        return new Change({ id, operations, presenceChange, message });
    }
    /**
     * `getID` returns the ID of this change.
     */
    getID() {
        return this.id;
    }
    /**
     * `getMessage` returns the message of this change.
     */
    getMessage() {
        return this.message;
    }
    /**
     * `hasOperations` returns whether this change has operations or not.
     */
    hasOperations() {
        return this.operations.length > 0;
    }
    /**
     * `getOperations` returns the operations of this change.
     */
    getOperations() {
        return this.operations;
    }
    /**
     * `setActor` sets the given actor.
     */
    setActor(actorID) {
        for (const operation of this.operations) {
            operation.setActor(actorID);
        }
        this.id = this.id.setActor(actorID);
    }
    /**
     * `hasPresenceChange` returns whether this change has presence change or not.
     */
    hasPresenceChange() {
        return this.presenceChange !== undefined;
    }
    /**
     * `getPresenceChange` returns the presence change of this change.
     */
    getPresenceChange() {
        return this.presenceChange;
    }
    /**
     * `execute` executes the operations of this change to the given root.
     */
    execute(root, presences, source) {
        const changeOpInfos = [];
        const reverseOps = [];
        if (false) {}
        for (const operation of this.operations) {
            const executionResult = operation.execute(root, source);
            // NOTE(hackerwins): If the element was removed while executing undo/redo,
            // the operation is not executed and executionResult is undefined.
            if (!executionResult)
                continue;
            const { opInfos, reverseOp } = executionResult;
            changeOpInfos.push(...opInfos);
            // TODO(hackerwins): This condition should be removed after implementing
            // all reverse operations.
            if (reverseOp) {
                reverseOps.unshift(reverseOp);
            }
        }
        if (this.presenceChange) {
            if (this.presenceChange.type === PresenceChangeType.Put) {
                presences.set(this.id.getActorID(), deepcopy(this.presenceChange.presence));
            }
            else {
                presences.delete(this.id.getActorID());
            }
        }
        return { opInfos: changeOpInfos, reverseOps };
    }
    /**
     * `toTestString` returns a string containing the meta data of this change.
     */
    toTestString() {
        return `${this.operations
            .map((operation) => operation.toTestString())
            .join(',')}`;
    }
}

;// CONCATENATED MODULE: ./src/document/change/change_pack.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * `ChangePack` is a unit for delivering changes in a document to the remote.
 *
 */
class ChangePack {
    constructor(key, checkpoint, isRemoved, changes, snapshot, minSyncedTicket) {
        this.documentKey = key;
        this.checkpoint = checkpoint;
        this.isRemoved = isRemoved;
        this.changes = changes;
        this.snapshot = snapshot;
        this.minSyncedTicket = minSyncedTicket;
    }
    /**
     * `create` creates a new instance of ChangePack.
     */
    static create(key, checkpoint, isRemoved, changes, snapshot, minSyncedTicket) {
        return new ChangePack(key, checkpoint, isRemoved, changes, snapshot, minSyncedTicket);
    }
    /**
     * `getKey` returns the document key of this pack.
     */
    getDocumentKey() {
        return this.documentKey;
    }
    /**
     * `getCheckpoint` returns the checkpoint of this pack.
     */
    getCheckpoint() {
        return this.checkpoint;
    }
    /**
     * `getIsRemoved` returns the whether this document is removed.
     */
    getIsRemoved() {
        return this.isRemoved;
    }
    /**
     * `getChanges` returns the changes of this pack.
     */
    getChanges() {
        return this.changes;
    }
    /**
     * `hasChanges` returns the whether this pack has changes or not.
     */
    hasChanges() {
        return this.changes.length > 0;
    }
    /**
     * `getChangeSize` returns the size of changes this pack has.
     */
    getChangeSize() {
        return this.changes.length;
    }
    /**
     * `hasSnapshot` returns the whether this pack has a snapshot or not.
     */
    hasSnapshot() {
        return !!this.snapshot && !!this.snapshot.length;
    }
    /**
     * `getSnapshot` returns the snapshot of this pack.
     */
    getSnapshot() {
        return this.snapshot;
    }
    /**
     * `getMinSyncedTicket` returns the minimum synced ticket of this pack.
     */
    getMinSyncedTicket() {
        return this.minSyncedTicket;
    }
}

;// CONCATENATED MODULE: ./src/document/change/checkpoint.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * `Checkpoint` is used to determine the changes sent and received by the
 * client. This is immutable.
 *
 **/
class Checkpoint {
    constructor(serverSeq, clientSeq) {
        this.serverSeq = serverSeq;
        this.clientSeq = clientSeq;
    }
    /**
     * `of` creates a new instance of Checkpoint.
     */
    static of(serverSeq, clientSeq) {
        return new Checkpoint(serverSeq, clientSeq);
    }
    /**
     * `increaseClientSeq` creates a new instance with increased client sequence.
     */
    increaseClientSeq(inc) {
        if (inc === 0) {
            return this;
        }
        return new Checkpoint(this.serverSeq, this.clientSeq + inc);
    }
    /**
     * `forward` creates a new instance with the given checkpoint if it is
     * greater than the values of internal properties.
     */
    forward(other) {
        if (this.equals(other)) {
            return this;
        }
        const serverSeq = this.serverSeq.greaterThan(other.serverSeq)
            ? this.serverSeq
            : other.serverSeq;
        const clientSeq = Math.max(this.clientSeq, other.clientSeq);
        return Checkpoint.of(serverSeq, clientSeq);
    }
    /**
     * `getServerSeqAsString` returns the server seq of this checkpoint as a
     * string.
     */
    getServerSeqAsString() {
        return this.serverSeq.toString();
    }
    /**
     * `getClientSeq` returns the client seq of this checkpoint.
     */
    getClientSeq() {
        return this.clientSeq;
    }
    /**
     * `getServerSeq` returns the server seq of this checkpoint.
     */
    getServerSeq() {
        return this.serverSeq;
    }
    /**
     * `equals` returns whether the given checkpoint is equal to this checkpoint
     * or not.
     */
    equals(other) {
        return (this.clientSeq === other.clientSeq &&
            this.serverSeq.equals(other.serverSeq));
    }
    /**
     * `toTestString` returns a string containing the meta data of this
     * checkpoint.
     */
    toTestString() {
        return `serverSeq=${this.serverSeq}, clientSeq=${this.clientSeq}`;
    }
}
/**
 * `InitialCheckpoint` is the initial value of the checkpoint.
 */
const InitialCheckpoint = new Checkpoint(node_modules_long.fromInt(0, true), 0);

;// CONCATENATED MODULE: ./src/document/crdt/rga_tree_split.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * `RGATreeSplitNodeID` is an ID of RGATreeSplitNode.
 */
class RGATreeSplitNodeID {
    constructor(createdAt, offset) {
        this.createdAt = createdAt;
        this.offset = offset;
    }
    /**
     * `of` creates a instance of RGATreeSplitNodeID.
     */
    static of(createdAt, offset) {
        return new RGATreeSplitNodeID(createdAt, offset);
    }
    /**
     * `fromStruct` creates a instance of RGATreeSplitNodeID from the struct.
     */
    static fromStruct(struct) {
        return RGATreeSplitNodeID.of(TimeTicket.fromStruct(struct.createdAt), struct.offset);
    }
    /**
     * `getCreatedAt` returns the creation time of this ID.
     */
    getCreatedAt() {
        return this.createdAt;
    }
    /**
     * `getOffset` returns returns the offset of this ID.
     */
    getOffset() {
        return this.offset;
    }
    /**
     * `equals` returns whether given ID equals to this ID or not.
     */
    equals(other) {
        return (this.createdAt.compare(other.createdAt) === 0 &&
            this.offset === other.offset);
    }
    /**
     * `hasSameCreatedAt` returns whether given ID has same creation time with this ID.
     */
    hasSameCreatedAt(other) {
        return this.createdAt.compare(other.createdAt) === 0;
    }
    /**
     * `split` creates a new ID with an offset from this ID.
     */
    split(offset) {
        return new RGATreeSplitNodeID(this.createdAt, this.offset + offset);
    }
    /**
     * `toStruct` returns the structure of this node id.
     */
    toStruct() {
        return {
            createdAt: this.createdAt.toStruct(),
            offset: this.offset,
        };
    }
    /**
     * `toTestString` returns a String containing
     * the meta data of the node id for debugging purpose.
     */
    toTestString() {
        return `${this.createdAt.toTestString()}:${this.offset}`;
    }
    /**
     * `toIDString` returns a string that can be used as an ID for this node id.
     */
    toIDString() {
        return `${this.createdAt.toIDString()}:${this.offset}`;
    }
}
const InitialRGATreeSplitNodeID = RGATreeSplitNodeID.of(InitialTimeTicket, 0);
/**
 * `RGATreeSplitPos` is the position of the text inside the node.
 */
class RGATreeSplitPos {
    constructor(id, relativeOffset) {
        this.id = id;
        this.relativeOffset = relativeOffset;
    }
    /**
     * `of` creates a instance of RGATreeSplitPos.
     */
    static of(id, relativeOffset) {
        return new RGATreeSplitPos(id, relativeOffset);
    }
    /**
     * `fromStruct` creates a instance of RGATreeSplitPos from the struct.
     */
    static fromStruct(struct) {
        const id = RGATreeSplitNodeID.fromStruct(struct.id);
        return RGATreeSplitPos.of(id, struct.relativeOffset);
    }
    /**
     * `getID` returns the ID of this RGATreeSplitPos.
     */
    getID() {
        return this.id;
    }
    /**
     * `getRelativeOffset` returns the relative offset of this RGATreeSplitPos.
     */
    getRelativeOffset() {
        return this.relativeOffset;
    }
    /**
     * `getAbsoluteID` returns the absolute id of this RGATreeSplitPos.
     */
    getAbsoluteID() {
        return RGATreeSplitNodeID.of(this.id.getCreatedAt(), this.id.getOffset() + this.relativeOffset);
    }
    /**
     *`toTestString` returns a String containing
     * the meta data of the position for debugging purpose.
     */
    toTestString() {
        return `${this.id.toTestString()}:${this.relativeOffset}`;
    }
    /**
     * `toStruct` returns the structure of this node pos.
     */
    toStruct() {
        return {
            id: this.id.toStruct(),
            relativeOffset: this.relativeOffset,
        };
    }
    /**
     * `equals` returns whether given pos equal to this pos or not.
     */
    equals(other) {
        if (!this.id.equals(other.id)) {
            return false;
        }
        return this.relativeOffset === other.relativeOffset;
    }
}
/**
 * `RGATreeSplitNode` is a node of RGATreeSplit.
 */
class RGATreeSplitNode extends SplayNode {
    constructor(id, value, removedAt) {
        super(value);
        this.id = id;
        this.removedAt = removedAt;
    }
    /**
     * `create` creates a instance of RGATreeSplitNode.
     */
    static create(id, value) {
        return new RGATreeSplitNode(id, value);
    }
    /**
     * `createComparator` creates a function to compare two RGATreeSplitNodeID.
     */
    static createComparator() {
        return (p1, p2) => {
            const compare = p1.getCreatedAt().compare(p2.getCreatedAt());
            if (compare !== 0) {
                return compare;
            }
            if (p1.getOffset() > p2.getOffset()) {
                return 1;
            }
            else if (p1.getOffset() < p2.getOffset()) {
                return -1;
            }
            return 0;
        };
    }
    /**
     * `getID` returns the ID of this RGATreeSplitNode.
     */
    getID() {
        return this.id;
    }
    /**
     * `getCreatedAt` returns creation time of the Id of RGATreeSplitNode.
     */
    getCreatedAt() {
        return this.id.getCreatedAt();
    }
    /**
     * `getLength` returns the length of this node.
     */
    getLength() {
        if (this.removedAt) {
            return 0;
        }
        return this.getContentLength();
    }
    /**
     * `getContentLength` returns the length of this value.
     */
    getContentLength() {
        return (this.value && this.value.length) || 0;
    }
    /**
     * `getPrev` returns a previous node of this node.
     */
    getPrev() {
        return this.prev;
    }
    /**
     * `getNext` returns a next node of this node.
     */
    getNext() {
        return this.next;
    }
    /**
     * `getInsPrev` returns a previous node of this node insertion.
     */
    getInsPrev() {
        return this.insPrev;
    }
    /**
     * `getInsNext` returns a next node of this node insertion.
     */
    getInsNext() {
        return this.insNext;
    }
    /**
     * `getInsPrevID` returns a ID of previous node insertion.
     */
    getInsPrevID() {
        return this.insPrev.getID();
    }
    /**
     * `setPrev` sets previous node of this node.
     */
    setPrev(node) {
        this.prev = node;
        if (node) {
            node.next = this;
        }
    }
    /**
     * `setNext` sets next node of this node.
     */
    setNext(node) {
        this.next = node;
        if (node) {
            node.prev = this;
        }
    }
    /**
     * `setInsPrev` sets previous node of this node insertion.
     */
    setInsPrev(node) {
        this.insPrev = node;
        if (node) {
            node.insNext = this;
        }
    }
    /**
     * `setInsNext` sets next node of this node insertion.
     */
    setInsNext(node) {
        this.insNext = node;
        if (node) {
            node.insPrev = this;
        }
    }
    /**
     * `hasNext` checks if next node exists.
     */
    hasNext() {
        return !!this.next;
    }
    /**
     * `hasInsPrev` checks if previous insertion node exists.
     */
    hasInsPrev() {
        return !!this.insPrev;
    }
    /**
     * `isRemoved` checks if removed time exists.
     */
    isRemoved() {
        return !!this.removedAt;
    }
    /**
     * `getRemovedAt` returns the remove time of this node.
     */
    getRemovedAt() {
        return this.removedAt;
    }
    /**
     * `split` creates a new split node of the given offset.
     */
    split(offset) {
        return new RGATreeSplitNode(this.id.split(offset), this.splitValue(offset), this.removedAt);
    }
    /**
     * `canDelete` checks if node is able to delete.
     */
    canDelete(editedAt, latestCreatedAt) {
        return (!this.getCreatedAt().after(latestCreatedAt) &&
            (!this.removedAt || editedAt.after(this.removedAt)));
    }
    /**
     * `canStyle` checks if node is able to set style.
     */
    canStyle(editedAt, latestCreatedAt) {
        return (!this.getCreatedAt().after(latestCreatedAt) &&
            (!this.removedAt || editedAt.after(this.removedAt)));
    }
    /**
     * `remove` removes node of given edited time.
     */
    remove(editedAt) {
        this.removedAt = editedAt;
    }
    /**
     * `createRange` creates ranges of RGATreeSplitPos.
     */
    createPosRange() {
        return [
            RGATreeSplitPos.of(this.id, 0),
            RGATreeSplitPos.of(this.id, this.getLength()),
        ];
    }
    /**
     * `deepcopy` returns a new instance of this RGATreeSplitNode without structural info.
     */
    deepcopy() {
        return new RGATreeSplitNode(this.id, this.value, this.removedAt);
    }
    /**
     * `toTestString` returns a String containing
     * the meta data of the node for debugging purpose.
     */
    toTestString() {
        return `${this.id.toTestString()} ${this.value ? this.value : ''}`;
    }
    splitValue(offset) {
        const value = this.value;
        this.value = value.substring(0, offset);
        return value.substring(offset, value.length);
    }
}
/**
 * `RGATreeSplit` is a block-based list with improved index-based lookup in RGA.
 * The difference from RGATreeList is that it has data on a block basis to
 * reduce the size of CRDT metadata. When an edit occurs on a block,
 * the block is split.
 *
 */
class RGATreeSplit {
    constructor() {
        this.head = RGATreeSplitNode.create(InitialRGATreeSplitNodeID);
        this.treeByIndex = new SplayTree();
        this.treeByID = new LLRBTree(RGATreeSplitNode.createComparator());
        this.removedNodeMap = new Map();
        this.treeByIndex.insert(this.head);
        this.treeByID.put(this.head.getID(), this.head);
    }
    /**
     * `create` creates a instance RGATreeSplit.
     */
    static create() {
        return new RGATreeSplit();
    }
    /**
     * `edit` does following steps
     * 1. split nodes with from and to
     * 2. delete between from and to
     * 3. insert a new node
     * 4. add removed node
     * @param range - range of RGATreeSplitNode
     * @param editedAt - edited time
     * @param value - value
     * @param latestCreatedAtMapByActor - latestCreatedAtMapByActor
     * @returns `[RGATreeSplitPos, Map<string, TimeTicket>, Array<Change>]`
     */
    edit(range, editedAt, value, latestCreatedAtMapByActor) {
        // 01. split nodes with from and to
        const [toLeft, toRight] = this.findNodeWithSplit(range[1], editedAt);
        const [fromLeft, fromRight] = this.findNodeWithSplit(range[0], editedAt);
        // 02. delete between from and to
        const nodesToDelete = this.findBetween(fromRight, toRight);
        const [changes, latestCreatedAtMap, removedNodeMapByNodeKey] = this.deleteNodes(nodesToDelete, editedAt, latestCreatedAtMapByActor);
        const caretID = toRight ? toRight.getID() : toLeft.getID();
        let caretPos = RGATreeSplitPos.of(caretID, 0);
        // 03. insert a new node
        if (value) {
            const idx = this.posToIndex(fromLeft.createPosRange()[1], true);
            const inserted = this.insertAfter(fromLeft, RGATreeSplitNode.create(RGATreeSplitNodeID.of(editedAt, 0), value));
            if (changes.length && changes[changes.length - 1].from === idx) {
                changes[changes.length - 1].value = value;
            }
            else {
                changes.push({
                    actor: editedAt.getActorID(),
                    from: idx,
                    to: idx,
                    value,
                });
            }
            caretPos = RGATreeSplitPos.of(inserted.getID(), inserted.getContentLength());
        }
        // 04. add removed node
        for (const [key, removedNode] of removedNodeMapByNodeKey) {
            this.removedNodeMap.set(key, removedNode);
        }
        return [caretPos, latestCreatedAtMap, changes];
    }
    /**
     * `indexToPos` finds RGATreeSplitPos of given offset.
     */
    indexToPos(idx) {
        const [node, offset] = this.treeByIndex.find(idx);
        const splitNode = node;
        return RGATreeSplitPos.of(splitNode.getID(), offset);
    }
    /**
     * `findIndexesFromRange` finds indexes based on range.
     */
    findIndexesFromRange(range) {
        const [fromPos, toPos] = range;
        return [this.posToIndex(fromPos, false), this.posToIndex(toPos, true)];
    }
    /**
     * `posToIndex` converts the given position to index.
     */
    posToIndex(pos, preferToLeft) {
        const absoluteID = pos.getAbsoluteID();
        const node = preferToLeft
            ? this.findFloorNodePreferToLeft(absoluteID)
            : this.findFloorNode(absoluteID);
        if (!node) {
            logger.fatal(`the node of the given id should be found: ${absoluteID.toTestString()}`);
        }
        const index = this.treeByIndex.indexOf(node);
        const offset = node.isRemoved()
            ? 0
            : absoluteID.getOffset() - node.getID().getOffset();
        return index + offset;
    }
    /**
     * `findNode` finds node of given id.
     */
    findNode(id) {
        return this.findFloorNode(id);
    }
    /**
     * `length` returns size of RGATreeSplit.
     */
    get length() {
        return this.treeByIndex.length;
    }
    /**
     * `checkWeight` returns false when there is an incorrect weight node.
     * for debugging purpose.
     */
    checkWeight() {
        return this.treeByIndex.checkWeight();
    }
    /**
     * `toString` returns the string encoding of this RGATreeSplit.
     */
    toString() {
        const str = [];
        for (const node of this) {
            if (!node.isRemoved()) {
                str.push(node.getValue());
            }
        }
        return str.join('');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    *[Symbol.iterator]() {
        let node = this.head.getNext();
        while (node) {
            yield node;
            node = node.getNext();
        }
    }
    /**
     * `getHead` returns head of RGATreeSplitNode.
     */
    getHead() {
        return this.head;
    }
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy() {
        const clone = new RGATreeSplit();
        let node = this.head.getNext();
        let prev = clone.head;
        let current;
        while (node) {
            current = clone.insertAfter(prev, node.deepcopy());
            if (node.hasInsPrev()) {
                const insPrevNode = clone.findNode(node.getInsPrevID());
                current.setInsPrev(insPrevNode);
            }
            prev = current;
            node = node.getNext();
        }
        return clone;
    }
    /**
     * `toTestString` returns a String containing the meta data of the node
     * for debugging purpose.
     */
    toTestString() {
        const result = [];
        let node = this.head;
        while (node) {
            if (node.isRemoved()) {
                result.push(`{${node.toTestString()}}`);
            }
            else {
                result.push(`[${node.toTestString()}]`);
            }
            node = node.getNext();
        }
        return result.join('');
    }
    /**
     * `insertAfter` inserts the given node after the given previous node.
     */
    insertAfter(prevNode, newNode) {
        const next = prevNode.getNext();
        newNode.setPrev(prevNode);
        if (next) {
            next.setPrev(newNode);
        }
        this.treeByID.put(newNode.getID(), newNode);
        this.treeByIndex.insertAfter(prevNode, newNode);
        return newNode;
    }
    /**
     * `findNodeWithSplit` splits and return nodes of the given position.
     */
    findNodeWithSplit(pos, editedAt) {
        const absoluteID = pos.getAbsoluteID();
        let node = this.findFloorNodePreferToLeft(absoluteID);
        const relativeOffset = absoluteID.getOffset() - node.getID().getOffset();
        this.splitNode(node, relativeOffset);
        while (node.hasNext() && node.getNext().getCreatedAt().after(editedAt)) {
            node = node.getNext();
        }
        return [node, node.getNext()];
    }
    findFloorNodePreferToLeft(id) {
        let node = this.findFloorNode(id);
        if (!node) {
            logger.fatal(`the node of the given id should be found: ${id.toTestString()}`);
        }
        if (id.getOffset() > 0 && node.getID().getOffset() == id.getOffset()) {
            // NOTE: InsPrev may not be present due to GC.
            if (!node.hasInsPrev()) {
                return node;
            }
            node = node.getInsPrev();
        }
        return node;
    }
    findFloorNode(id) {
        const entry = this.treeByID.floorEntry(id);
        if (!entry) {
            return;
        }
        if (!entry.key.equals(id) && !entry.key.hasSameCreatedAt(id)) {
            return;
        }
        return entry.value;
    }
    /**
     * `findBetween` returns nodes between fromNode and toNode.
     */
    findBetween(fromNode, toNode) {
        const nodes = [];
        let current = fromNode;
        while (current && current !== toNode) {
            nodes.push(current);
            current = current.getNext();
        }
        return nodes;
    }
    splitNode(node, offset) {
        if (offset > node.getContentLength()) {
            logger.fatal('offset should be less than or equal to length');
        }
        if (offset === 0) {
            return node;
        }
        else if (offset === node.getContentLength()) {
            return node.getNext();
        }
        const splitNode = node.split(offset);
        this.treeByIndex.updateWeight(splitNode);
        this.insertAfter(node, splitNode);
        const insNext = node.getInsNext();
        if (insNext) {
            insNext.setInsPrev(splitNode);
        }
        splitNode.setInsPrev(node);
        return splitNode;
    }
    deleteNodes(candidates, editedAt, latestCreatedAtMapByActor) {
        if (!candidates.length) {
            return [[], new Map(), new Map()];
        }
        // There are 2 types of nodes in `candidates`: should delete, should not delete.
        // `nodesToKeep` contains nodes should not delete,
        // then is used to find the boundary of the range to be deleted.
        const [nodesToDelete, nodesToKeep] = this.filterNodes(candidates, editedAt, latestCreatedAtMapByActor);
        const createdAtMapByActor = new Map();
        const removedNodeMap = new Map();
        // First we need to collect indexes for change.
        const changes = this.makeChanges(nodesToKeep, editedAt);
        for (const node of nodesToDelete) {
            // Then make nodes be tombstones and map that.
            const actorID = node.getCreatedAt().getActorID();
            if (!createdAtMapByActor.has(actorID) ||
                node.getID().getCreatedAt().after(createdAtMapByActor.get(actorID))) {
                createdAtMapByActor.set(actorID, node.getID().getCreatedAt());
            }
            removedNodeMap.set(node.getID().toIDString(), node);
            node.remove(editedAt);
        }
        // Finally remove index nodes of tombstones.
        this.deleteIndexNodes(nodesToKeep);
        return [changes, createdAtMapByActor, removedNodeMap];
    }
    filterNodes(candidates, editedAt, latestCreatedAtMapByActor) {
        const isRemote = !!latestCreatedAtMapByActor;
        const nodesToDelete = [];
        const nodesToKeep = [];
        const [leftEdge, rightEdge] = this.findEdgesOfCandidates(candidates);
        nodesToKeep.push(leftEdge);
        for (const node of candidates) {
            const actorID = node.getCreatedAt().getActorID();
            const latestCreatedAt = isRemote
                ? latestCreatedAtMapByActor.has(actorID)
                    ? latestCreatedAtMapByActor.get(actorID)
                    : InitialTimeTicket
                : MaxTimeTicket;
            if (node.canDelete(editedAt, latestCreatedAt)) {
                nodesToDelete.push(node);
            }
            else {
                nodesToKeep.push(node);
            }
        }
        nodesToKeep.push(rightEdge);
        return [nodesToDelete, nodesToKeep];
    }
    /**
     * `findEdgesOfCandidates` finds the edges outside `candidates`,
     * (which has not already been deleted, or be undefined but not yet implemented)
     * right edge is undefined means `candidates` contains the end of text.
     */
    findEdgesOfCandidates(candidates) {
        return [
            candidates[0].getPrev(),
            candidates[candidates.length - 1].getNext(),
        ];
    }
    makeChanges(boundaries, editedAt) {
        const changes = [];
        let fromIdx, toIdx;
        for (let i = 0; i < boundaries.length - 1; i++) {
            const leftBoundary = boundaries[i];
            const rightBoundary = boundaries[i + 1];
            if (leftBoundary.getNext() == rightBoundary) {
                continue;
            }
            [fromIdx] = this.findIndexesFromRange(leftBoundary.getNext().createPosRange());
            if (rightBoundary) {
                [, toIdx] = this.findIndexesFromRange(rightBoundary.getPrev().createPosRange());
            }
            else {
                toIdx = this.treeByIndex.length;
            }
            if (fromIdx < toIdx) {
                changes.push({
                    actor: editedAt.getActorID(),
                    from: fromIdx,
                    to: toIdx,
                });
            }
        }
        return changes.reverse();
    }
    /**
     * `deleteIndexNodes` clears the index nodes of the given deletion boundaries.
     * The boundaries mean the nodes that will not be deleted in the range.
     */
    deleteIndexNodes(boundaries) {
        for (let i = 0; i < boundaries.length - 1; i++) {
            const leftBoundary = boundaries[i];
            const rightBoundary = boundaries[i + 1];
            // If there is no node to delete between boundaries, do notting.
            if (leftBoundary.getNext() != rightBoundary) {
                this.treeByIndex.deleteRange(leftBoundary, rightBoundary);
            }
        }
    }
    /**
     * `getRemovedNodesLen` returns size of removed nodes.
     */
    getRemovedNodesLen() {
        return this.removedNodeMap.size;
    }
    /**
     * `purgeRemovedNodesBefore` physically purges nodes that have been removed.
     */
    purgeRemovedNodesBefore(ticket) {
        let count = 0;
        for (const [, node] of this.removedNodeMap) {
            if (node.getRemovedAt() && ticket.compare(node.getRemovedAt()) >= 0) {
                this.treeByIndex.delete(node);
                this.purge(node);
                this.treeByID.remove(node.getID());
                this.removedNodeMap.delete(node.getID().toIDString());
                count++;
            }
        }
        return count;
    }
    /**
     * `purge` physically purges the given node from RGATreeSplit.
     */
    purge(node) {
        const prev = node.getPrev();
        const next = node.getNext();
        const insPrev = node.getInsPrev();
        const insNext = node.getInsNext();
        if (prev) {
            prev.setNext(next);
        }
        if (next) {
            next.setPrev(prev);
        }
        node.setPrev(undefined);
        node.setNext(undefined);
        if (insPrev) {
            insPrev.setInsNext(insNext);
        }
        if (insNext) {
            insNext.setInsPrev(insPrev);
        }
        node.setInsPrev(undefined);
        node.setInsNext(undefined);
    }
}

;// CONCATENATED MODULE: ./src/util/number.ts
/*
 * Copyright 2023 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 `removeDecimal` returns a number with the decimal part removed.
 */
const removeDecimal = (number) => number < 0 ? Math.ceil(number) : Math.floor(number);

;// CONCATENATED MODULE: ./src/document/crdt/counter.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var CounterType;
(function (CounterType) {
    CounterType[CounterType["IntegerCnt"] = 0] = "IntegerCnt";
    CounterType[CounterType["LongCnt"] = 1] = "LongCnt";
})(CounterType || (CounterType = {}));
/**
 * `CRDTCounter` is a CRDT implementation of a counter. It is used to represent
 * a number that can be incremented or decremented.
 *
 * @internal
 */
class CRDTCounter extends CRDTElement {
    constructor(valueType, value, createdAt) {
        super(createdAt);
        this.valueType = valueType;
        switch (valueType) {
            case CounterType.IntegerCnt:
                if (typeof value === 'number') {
                    if (value > Math.pow(2, 31) - 1 || value < -Math.pow(2, 31)) {
                        this.value = node_modules_long.fromNumber(value).toInt();
                    }
                    else {
                        this.value = removeDecimal(value);
                    }
                }
                else {
                    this.value = value.toInt();
                }
                break;
            case CounterType.LongCnt:
                if (typeof value === 'number') {
                    this.value = node_modules_long.fromNumber(value);
                }
                else {
                    this.value = value;
                }
                break;
            default:
                throw new YorkieError(Code.Unimplemented, `unimplemented type: ${valueType}`);
        }
    }
    /**
     * `of` creates a new instance of Counter.
     */
    static create(valueType, value, createdAt) {
        return new CRDTCounter(valueType, value, createdAt);
    }
    /**
     * `valueFromBytes` parses the given bytes into value.
     */
    static valueFromBytes(counterType, bytes) {
        switch (counterType) {
            case CounterType.IntegerCnt:
                return bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);
            case CounterType.LongCnt:
                return node_modules_long.fromBytesLE(Array.from(bytes));
            default:
                throw new YorkieError(Code.Unimplemented, `unimplemented type: ${counterType}`);
        }
    }
    /**
     * `toJSON` returns the JSON encoding of the value.
     */
    toJSON() {
        return `${this.value}`;
    }
    /**
     * `toSortedJSON` returns the sorted JSON encoding of the value.
     */
    toSortedJSON() {
        return this.toJSON();
    }
    /**
     * `toJSForTest` returns value with meta data for testing.
     */
    toJSForTest() {
        return {
            id: this.getCreatedAt().toTestString(),
            value: this.value,
            type: 'YORKIE_COUNTER',
        };
    }
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy() {
        const counter = CRDTCounter.create(this.valueType, this.value, this.getCreatedAt());
        counter.setMovedAt(this.getMovedAt());
        return counter;
    }
    /**
     * `getType` returns the type of the value.
     */
    getType() {
        return this.valueType;
    }
    /**
     * `getCounterType` returns counter type of given value.
     */
    static getCounterType(value) {
        switch (typeof value) {
            case 'object':
                if (value instanceof node_modules_long) {
                    return CounterType.LongCnt;
                }
                else {
                    return;
                }
            case 'number':
                if (value > Math.pow(2, 31) - 1 || value < -Math.pow(2, 31)) {
                    return CounterType.LongCnt;
                }
                else {
                    return CounterType.IntegerCnt;
                }
            default:
                return;
        }
    }
    /**
     * `isSupport` check if there is a counter type of given value.
     */
    static isSupport(value) {
        return !!CRDTCounter.getCounterType(value);
    }
    /**
     * `isInteger` checks if the num is integer.
     */
    static isInteger(num) {
        return num % 1 === 0;
    }
    /**
     * `isNumericType` check numeric type by JSONCounter.
     */
    isNumericType() {
        const t = this.valueType;
        return t === CounterType.IntegerCnt || t === CounterType.LongCnt;
    }
    /**
     * `getValueType` get counter value type.
     */
    getValueType() {
        return this.valueType;
    }
    /**
     * `getValue` get counter value.
     */
    getValue() {
        return this.value;
    }
    /**
     * `toBytes` creates an array representing the value.
     */
    toBytes() {
        switch (this.valueType) {
            case CounterType.IntegerCnt: {
                const intVal = this.value;
                return new Uint8Array([
                    intVal & 0xff,
                    (intVal >> 8) & 0xff,
                    (intVal >> 16) & 0xff,
                    (intVal >> 24) & 0xff,
                ]);
            }
            case CounterType.LongCnt: {
                const longVal = this.value;
                const longToBytes = longVal.toBytesLE();
                return Uint8Array.from(longToBytes);
            }
            default:
                throw new YorkieError(Code.Unimplemented, `unimplemented type: ${this.valueType}`);
        }
    }
    /**
     * `increase` increases numeric data.
     */
    increase(v) {
        /**
         * `checkNumericType` checks if the given target is a numeric type.
         */
        function checkNumericType(target) {
            if (!target.isNumericType()) {
                throw new TypeError(`Unsupported type of value: ${typeof target.getValue()}`);
            }
        }
        checkNumericType(this);
        checkNumericType(v);
        if (this.valueType === CounterType.LongCnt) {
            this.value = this.value.add(v.getValue());
        }
        else {
            if (v.getType() === PrimitiveType.Long) {
                this.value = this.value + v.getValue().toInt();
            }
            else {
                this.value = node_modules_long.fromNumber(this.value + removeDecimal(v.getValue())).toInt();
            }
        }
        return this;
    }
}

;// CONCATENATED MODULE: ./src/document/operation/increase_operation.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * `IncreaseOperation` represents an operation that increments a numeric value to Counter.
 * Among Primitives, numeric types Integer, Long are used as values.
 */
class IncreaseOperation extends Operation {
    constructor(parentCreatedAt, value, executedAt) {
        super(parentCreatedAt, executedAt);
        this.value = value;
    }
    /**
     * `create` creates a new instance of IncreaseOperation.
     */
    static create(parentCreatedAt, value, executedAt) {
        return new IncreaseOperation(parentCreatedAt, value, executedAt);
    }
    /**
     * `execute` executes this operation on the given `CRDTRoot`.
     */
    execute(root) {
        const parentObject = root.findByCreatedAt(this.getParentCreatedAt());
        if (!parentObject) {
            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);
        }
        if (!(parentObject instanceof CRDTCounter)) {
            logger.fatal(`fail to execute, only Counter can execute increase`);
        }
        const counter = parentObject;
        const value = this.value.deepcopy();
        counter.increase(value);
        return {
            opInfos: [
                {
                    type: 'increase',
                    path: root.createPath(this.getParentCreatedAt()),
                    value: value.getValue(),
                },
            ],
            reverseOp: this.toReverseOperation(),
        };
    }
    /**
     * `toReverseOperation` returns the reverse operation of this operation.
     */
    toReverseOperation() {
        const primitiveValue = this.value.deepcopy();
        const valueType = primitiveValue.getType();
        const value = valueType === PrimitiveType.Long
            ? primitiveValue.getValue().multiply(-1)
            : primitiveValue.getValue() * -1;
        const reverseOp = IncreaseOperation.create(this.getParentCreatedAt(), Primitive.of(value, primitiveValue.getCreatedAt()));
        return reverseOp;
    }
    /**
     * `getEffectedCreatedAt` returns the creation time of the effected element.
     */
    getEffectedCreatedAt() {
        return this.getParentCreatedAt();
    }
    /**
     * `toTestString` returns a string containing the meta data.
     */
    toTestString() {
        return `${this.getParentCreatedAt().toTestString()}.INCREASE.${this.value.toJSON()}`;
    }
    /**
     * `getValue` returns the value of this operation.
     */
    getValue() {
        return this.value;
    }
}

;// CONCATENATED MODULE: ./src/document/operation/tree_style_operation.ts
/*
 * Copyright 2023 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * `TreeStyleOperation` represents an operation that modifies the style of the
 * node in the Tree.
 */
class TreeStyleOperation extends Operation {
    constructor(parentCreatedAt, fromPos, toPos, attributes, executedAt) {
        super(parentCreatedAt, executedAt);
        this.fromPos = fromPos;
        this.toPos = toPos;
        this.attributes = attributes;
    }
    /**
     * `create` creates a new instance of TreeStyleOperation.
     */
    static create(parentCreatedAt, fromPos, toPos, attributes, executedAt) {
        return new TreeStyleOperation(parentCreatedAt, fromPos, toPos, attributes, executedAt);
    }
    /**
     * `execute` executes this operation on the given `CRDTRoot`.
     */
    execute(root) {
        const parentObject = root.findByCreatedAt(this.getParentCreatedAt());
        if (!parentObject) {
            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);
        }
        if (!(parentObject instanceof CRDTTree)) {
            logger.fatal(`fail to execute, only Tree can execute edit`);
        }
        const attributes = {};
        [...this.attributes].forEach(([key, value]) => (attributes[key] = value));
        const tree = parentObject;
        const changes = tree.style([this.fromPos, this.toPos], attributes, this.getExecutedAt());
        return {
            opInfos: changes.map(({ from, to, value, fromPath }) => {
                return {
                    type: 'tree-style',
                    from,
                    to,
                    value,
                    fromPath,
                    path: root.createPath(this.getParentCreatedAt()),
                };
            }),
        };
    }
    /**
     * `getEffectedCreatedAt` returns the creation time of the effected element.
     */
    getEffectedCreatedAt() {
        return this.getParentCreatedAt();
    }
    /**
     * `toTestString` returns a string containing the meta data.
     */
    toTestString() {
        const parent = this.getParentCreatedAt().toTestString();
        const fromPos = `${this.fromPos
            .getLeftSiblingID()
            .getCreatedAt()
            .toTestString()}:${this.fromPos.getLeftSiblingID().getOffset()}`;
        const toPos = `${this.toPos
            .getLeftSiblingID()
            .getCreatedAt()
            .toTestString()}:${this.toPos.getLeftSiblingID().getOffset()}`;
        return `${parent}.STYLE(${fromPos},${toPos},${Object.entries(this.attributes || {})
            .map(([k, v]) => `${k}:"${v}"`)
            .join(' ')})`;
    }
    /**
     * `getFromPos` returns the start point of the editing range.
     */
    getFromPos() {
        return this.fromPos;
    }
    /**
     * `getToPos` returns the end point of the editing range.
     */
    getToPos() {
        return this.toPos;
    }
    /**
     * `getAttributes` returns the attributes of Style.
     */
    getAttributes() {
        return this.attributes;
    }
}

;// CONCATENATED MODULE: ./src/api/converter.ts
/*
 * Copyright 2023 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






























/**
 * `toPresence` converts the given model to Protobuf format.
 */
function toPresence(presence) {
    const pbPresence = new resources_pb.Presence();
    const pbDataMap = pbPresence.getDataMap();
    for (const [key, value] of Object.entries(presence)) {
        pbDataMap.set(key, JSON.stringify(value));
    }
    return pbPresence;
}
/**
 * `toPresenceChange` converts the given model to Protobuf format.
 */
function toPresenceChange(presenceChange) {
    const pbPresenceChange = new resources_pb.PresenceChange();
    if (presenceChange.type === PresenceChangeType.Put) {
        pbPresenceChange.setType(resources_pb.PresenceChange.ChangeType.CHANGE_TYPE_PUT);
        pbPresenceChange.setPresence(toPresence(presenceChange.presence));
    }
    else if (presenceChange.type === PresenceChangeType.Clear) {
        pbPresenceChange.setType(resources_pb.PresenceChange.ChangeType.CHANGE_TYPE_CLEAR);
    }
    return pbPresenceChange;
}
/**
 * `toCheckpoint` converts the given model to Protobuf format.
 */
function toCheckpoint(checkpoint) {
    const pbCheckpoint = new resources_pb.Checkpoint();
    pbCheckpoint.setServerSeq(checkpoint.getServerSeqAsString());
    pbCheckpoint.setClientSeq(checkpoint.getClientSeq());
    return pbCheckpoint;
}
/**
 * `toChangeID` converts the given model to Protobuf format.
 */
function toChangeID(changeID) {
    const pbChangeID = new resources_pb.ChangeID();
    pbChangeID.setClientSeq(changeID.getClientSeq());
    pbChangeID.setLamport(changeID.getLamportAsString());
    pbChangeID.setActorId(toUint8Array(changeID.getActorID()));
    return pbChangeID;
}
/**
 * `toTimeTicket` converts the given model to Protobuf format.
 */
function toTimeTicket(ticket) {
    if (!ticket) {
        return;
    }
    const pbTimeTicket = new resources_pb.TimeTicket();
    pbTimeTicket.setLamport(ticket.getLamportAsString());
    pbTimeTicket.setDelimiter(ticket.getDelimiter());
    pbTimeTicket.setActorId(toUint8Array(ticket.getActorID()));
    return pbTimeTicket;
}
/**
 * `toValueType` converts the given model to Protobuf format.
 */
function toValueType(valueType) {
    switch (valueType) {
        case PrimitiveType.Null:
            return resources_pb.ValueType.VALUE_TYPE_NULL;
        case PrimitiveType.Boolean:
            return resources_pb.ValueType.VALUE_TYPE_BOOLEAN;
        case PrimitiveType.Integer:
            return resources_pb.ValueType.VALUE_TYPE_INTEGER;
        case PrimitiveType.Long:
            return resources_pb.ValueType.VALUE_TYPE_LONG;
        case PrimitiveType.Double:
            return resources_pb.ValueType.VALUE_TYPE_DOUBLE;
        case PrimitiveType.String:
            return resources_pb.ValueType.VALUE_TYPE_STRING;
        case PrimitiveType.Bytes:
            return resources_pb.ValueType.VALUE_TYPE_BYTES;
        case PrimitiveType.Date:
            return resources_pb.ValueType.VALUE_TYPE_DATE;
        default:
            throw new YorkieError(Code.Unsupported, `unsupported type: ${valueType}`);
    }
}
/**
 * `toCounterType` converts the given model to Protobuf format.
 */
function toCounterType(valueType) {
    switch (valueType) {
        case CounterType.IntegerCnt:
            return resources_pb.ValueType.VALUE_TYPE_INTEGER_CNT;
        case CounterType.LongCnt:
            return resources_pb.ValueType.VALUE_TYPE_LONG_CNT;
        default:
            throw new YorkieError(Code.Unsupported, `unsupported type: ${valueType}`);
    }
}
/**
 * `toElementSimple` converts the given model to Protobuf format.
 */
function toElementSimple(element) {
    const pbElementSimple = new resources_pb.JSONElementSimple();
    if (element instanceof CRDTObject) {
        pbElementSimple.setType(resources_pb.ValueType.VALUE_TYPE_JSON_OBJECT);
        pbElementSimple.setCreatedAt(toTimeTicket(element.getCreatedAt()));
        pbElementSimple.setValue(objectToBytes(element));
    }
    else if (element instanceof CRDTArray) {
        pbElementSimple.setType(resources_pb.ValueType.VALUE_TYPE_JSON_ARRAY);
        pbElementSimple.setCreatedAt(toTimeTicket(element.getCreatedAt()));
        pbElementSimple.setValue(arrayToBytes(element));
    }
    else if (element instanceof CRDTText) {
        pbElementSimple.setType(resources_pb.ValueType.VALUE_TYPE_TEXT);
        pbElementSimple.setCreatedAt(toTimeTicket(element.getCreatedAt()));
    }
    else if (element instanceof Primitive) {
        const primitive = element;
        pbElementSimple.setType(toValueType(primitive.getType()));
        pbElementSimple.setCreatedAt(toTimeTicket(element.getCreatedAt()));
        pbElementSimple.setValue(element.toBytes());
    }
    else if (element instanceof CRDTCounter) {
        const counter = element;
        pbElementSimple.setType(toCounterType(counter.getType()));
        pbElementSimple.setCreatedAt(toTimeTicket(element.getCreatedAt()));
        pbElementSimple.setValue(element.toBytes());
    }
    else if (element instanceof CRDTTree) {
        const tree = element;
        pbElementSimple.setType(resources_pb.ValueType.VALUE_TYPE_TREE);
        pbElementSimple.setCreatedAt(toTimeTicket(element.getCreatedAt()));
        pbElementSimple.setValue(treeToBytes(tree));
    }
    else {
        throw new YorkieError(Code.Unimplemented, `unimplemented element`);
    }
    return pbElementSimple;
}
/**
 * `toTextNodeID` converts the given model to Protobuf format.
 */
function toTextNodeID(id) {
    const pbTextNodeID = new resources_pb.TextNodeID();
    pbTextNodeID.setCreatedAt(toTimeTicket(id.getCreatedAt()));
    pbTextNodeID.setOffset(id.getOffset());
    return pbTextNodeID;
}
/**
 * `toTextNodePos` converts the given model to Protobuf format.
 */
function toTextNodePos(pos) {
    const pbTextNodePos = new resources_pb.TextNodePos();
    pbTextNodePos.setCreatedAt(toTimeTicket(pos.getID().getCreatedAt()));
    pbTextNodePos.setOffset(pos.getID().getOffset());
    pbTextNodePos.setRelativeOffset(pos.getRelativeOffset());
    return pbTextNodePos;
}
/**
 * `toTreePos` converts the given model to Protobuf format.
 */
function toTreePos(pos) {
    const pbTreePos = new resources_pb.TreePos();
    pbTreePos.setParentId(toTreeNodeID(pos.getParentID()));
    pbTreePos.setLeftSiblingId(toTreeNodeID(pos.getLeftSiblingID()));
    return pbTreePos;
}
/**
 * `toTreeNodeID` converts the given model to Protobuf format.
 */
function toTreeNodeID(treeNodeID) {
    const pbTreeNodeID = new resources_pb.TreeNodeID();
    pbTreeNodeID.setCreatedAt(toTimeTicket(treeNodeID.getCreatedAt()));
    pbTreeNodeID.setOffset(treeNodeID.getOffset());
    return pbTreeNodeID;
}
/**
 * `toOperation` converts the given model to Protobuf format.
 */
function toOperation(operation) {
    const pbOperation = new resources_pb.Operation();
    if (operation instanceof SetOperation) {
        const setOperation = operation;
        const pbSetOperation = new resources_pb.Operation.Set();
        pbSetOperation.setParentCreatedAt(toTimeTicket(setOperation.getParentCreatedAt()));
        pbSetOperation.setKey(setOperation.getKey());
        pbSetOperation.setValue(toElementSimple(setOperation.getValue()));
        pbSetOperation.setExecutedAt(toTimeTicket(setOperation.getExecutedAt()));
        pbOperation.setSet(pbSetOperation);
    }
    else if (operation instanceof AddOperation) {
        const addOperation = operation;
        const pbAddOperation = new resources_pb.Operation.Add();
        pbAddOperation.setParentCreatedAt(toTimeTicket(addOperation.getParentCreatedAt()));
        pbAddOperation.setPrevCreatedAt(toTimeTicket(addOperation.getPrevCreatedAt()));
        pbAddOperation.setValue(toElementSimple(addOperation.getValue()));
        pbAddOperation.setExecutedAt(toTimeTicket(addOperation.getExecutedAt()));
        pbOperation.setAdd(pbAddOperation);
    }
    else if (operation instanceof MoveOperation) {
        const moveOperation = operation;
        const pbMoveOperation = new resources_pb.Operation.Move();
        pbMoveOperation.setParentCreatedAt(toTimeTicket(moveOperation.getParentCreatedAt()));
        pbMoveOperation.setPrevCreatedAt(toTimeTicket(moveOperation.getPrevCreatedAt()));
        pbMoveOperation.setCreatedAt(toTimeTicket(moveOperation.getCreatedAt()));
        pbMoveOperation.setExecutedAt(toTimeTicket(moveOperation.getExecutedAt()));
        pbOperation.setMove(pbMoveOperation);
    }
    else if (operation instanceof RemoveOperation) {
        const removeOperation = operation;
        const pbRemoveOperation = new resources_pb.Operation.Remove();
        pbRemoveOperation.setParentCreatedAt(toTimeTicket(removeOperation.getParentCreatedAt()));
        pbRemoveOperation.setCreatedAt(toTimeTicket(removeOperation.getCreatedAt()));
        pbRemoveOperation.setExecutedAt(toTimeTicket(removeOperation.getExecutedAt()));
        pbOperation.setRemove(pbRemoveOperation);
    }
    else if (operation instanceof EditOperation) {
        const editOperation = operation;
        const pbEditOperation = new resources_pb.Operation.Edit();
        pbEditOperation.setParentCreatedAt(toTimeTicket(editOperation.getParentCreatedAt()));
        pbEditOperation.setFrom(toTextNodePos(editOperation.getFromPos()));
        pbEditOperation.setTo(toTextNodePos(editOperation.getToPos()));
        const pbCreatedAtMapByActor = pbEditOperation.getCreatedAtMapByActorMap();
        for (const [key, value] of editOperation.getMaxCreatedAtMapByActor()) {
            pbCreatedAtMapByActor.set(key, toTimeTicket(value));
        }
        pbEditOperation.setContent(editOperation.getContent());
        const pbAttributes = pbEditOperation.getAttributesMap();
        for (const [key, value] of editOperation.getAttributes()) {
            pbAttributes.set(key, value);
        }
        pbEditOperation.setExecutedAt(toTimeTicket(editOperation.getExecutedAt()));
        pbOperation.setEdit(pbEditOperation);
    }
    else if (operation instanceof StyleOperation) {
        const styleOperation = operation;
        const pbStyleOperation = new resources_pb.Operation.Style();
        pbStyleOperation.setParentCreatedAt(toTimeTicket(styleOperation.getParentCreatedAt()));
        pbStyleOperation.setFrom(toTextNodePos(styleOperation.getFromPos()));
        pbStyleOperation.setTo(toTextNodePos(styleOperation.getToPos()));
        const pbCreatedAtMapByActor = pbStyleOperation.getCreatedAtMapByActorMap();
        for (const [key, value] of styleOperation.getMaxCreatedAtMapByActor()) {
            pbCreatedAtMapByActor.set(key, toTimeTicket(value));
        }
        const pbAttributes = pbStyleOperation.getAttributesMap();
        for (const [key, value] of styleOperation.getAttributes()) {
            pbAttributes.set(key, value);
        }
        pbStyleOperation.setExecutedAt(toTimeTicket(styleOperation.getExecutedAt()));
        pbOperation.setStyle(pbStyleOperation);
    }
    else if (operation instanceof IncreaseOperation) {
        const increaseOperation = operation;
        const pbIncreaseOperation = new resources_pb.Operation.Increase();
        pbIncreaseOperation.setParentCreatedAt(toTimeTicket(increaseOperation.getParentCreatedAt()));
        pbIncreaseOperation.setValue(toElementSimple(increaseOperation.getValue()));
        pbIncreaseOperation.setExecutedAt(toTimeTicket(increaseOperation.getExecutedAt()));
        pbOperation.setIncrease(pbIncreaseOperation);
    }
    else if (operation instanceof TreeEditOperation) {
        const treeEditOperation = operation;
        const pbTreeEditOperation = new resources_pb.Operation.TreeEdit();
        const pbCreatedAtMapByActor = pbTreeEditOperation.getCreatedAtMapByActorMap();
        for (const [key, value] of treeEditOperation.getMaxCreatedAtMapByActor()) {
            pbCreatedAtMapByActor.set(key, toTimeTicket(value));
        }
        pbTreeEditOperation.setParentCreatedAt(toTimeTicket(treeEditOperation.getParentCreatedAt()));
        pbTreeEditOperation.setFrom(toTreePos(treeEditOperation.getFromPos()));
        pbTreeEditOperation.setTo(toTreePos(treeEditOperation.getToPos()));
        pbTreeEditOperation.setContentsList(toTreeNodesWhenEdit(treeEditOperation.getContents()));
        pbTreeEditOperation.setExecutedAt(toTimeTicket(treeEditOperation.getExecutedAt()));
        pbOperation.setTreeEdit(pbTreeEditOperation);
    }
    else if (operation instanceof TreeStyleOperation) {
        const treeStyleOperation = operation;
        const pbTreeStyleOperation = new resources_pb.Operation.TreeStyle();
        pbTreeStyleOperation.setParentCreatedAt(toTimeTicket(treeStyleOperation.getParentCreatedAt()));
        pbTreeStyleOperation.setFrom(toTreePos(treeStyleOperation.getFromPos()));
        pbTreeStyleOperation.setTo(toTreePos(treeStyleOperation.getToPos()));
        const attributesMap = pbTreeStyleOperation.getAttributesMap();
        for (const [key, value] of treeStyleOperation.getAttributes()) {
            attributesMap.set(key, value);
        }
        pbTreeStyleOperation.setExecutedAt(toTimeTicket(treeStyleOperation.getExecutedAt()));
        pbOperation.setTreeStyle(pbTreeStyleOperation);
    }
    else {
        throw new YorkieError(Code.Unimplemented, 'unimplemented operation');
    }
    return pbOperation;
}
/**
 * `toOperations` converts the given model to Protobuf format.
 */
function toOperations(operations) {
    const pbOperations = [];
    for (const operation of operations) {
        pbOperations.push(toOperation(operation));
    }
    return pbOperations;
}
/**
 * `toChange` converts the given model to Protobuf format.
 */
function toChange(change) {
    const pbChange = new resources_pb.Change();
    pbChange.setId(toChangeID(change.getID()));
    pbChange.setMessage(change.getMessage());
    if (change.hasOperations()) {
        pbChange.setOperationsList(toOperations(change.getOperations()));
    }
    if (change.hasPresenceChange()) {
        pbChange.setPresenceChange(toPresenceChange(change.getPresenceChange()));
    }
    return pbChange;
}
/**
 * `toChanges` converts the given model to Protobuf format.
 */
function toChanges(changes) {
    const pbChanges = [];
    for (const change of changes) {
        pbChanges.push(toChange(change));
    }
    return pbChanges;
}
/**
 * `toRHTNodes` converts the given model to Protobuf format.
 */
function toRHTNodes(rht) {
    const pbRHTNodes = [];
    for (const rhtNode of rht) {
        const pbRHTNode = new resources_pb.RHTNode();
        pbRHTNode.setKey(rhtNode.getStrKey());
        // eslint-disable-next-line
        pbRHTNode.setElement(toElement(rhtNode.getValue()));
        pbRHTNodes.push(pbRHTNode);
    }
    return pbRHTNodes;
}
/**
 * `toRGANodes` converts the given model to Protobuf format.
 */
function toRGANodes(rgaTreeList) {
    const pbRGANodes = [];
    for (const rgaTreeListNode of rgaTreeList) {
        const pbRGANode = new resources_pb.RGANode();
        // eslint-disable-next-line
        pbRGANode.setElement(toElement(rgaTreeListNode.getValue()));
        pbRGANodes.push(pbRGANode);
    }
    return pbRGANodes;
}
/**
 * `toTextNodes` converts the given model to Protobuf format.
 */
function toTextNodes(rgaTreeSplit) {
    const pbTextNodes = [];
    for (const textNode of rgaTreeSplit) {
        const pbTextNode = new resources_pb.TextNode();
        pbTextNode.setId(toTextNodeID(textNode.getID()));
        pbTextNode.setValue(textNode.getValue().getContent());
        pbTextNode.setRemovedAt(toTimeTicket(textNode.getRemovedAt()));
        const pbNodeAttrsMap = pbTextNode.getAttributesMap();
        const attrs = textNode.getValue().getAttrs();
        for (const attr of attrs) {
            const pbNodeAttr = new resources_pb.NodeAttr();
            pbNodeAttr.setValue(attr.getValue());
            pbNodeAttr.setUpdatedAt(toTimeTicket(attr.getUpdatedAt()));
            pbNodeAttrsMap.set(attr.getKey(), pbNodeAttr);
        }
        pbTextNodes.push(pbTextNode);
    }
    return pbTextNodes;
}
/**
 * `toTreeNodesWhenEdit` converts the given model to Protobuf format.
 */
function toTreeNodesWhenEdit(nodes) {
    const pbTreeNodesList = [];
    if (!nodes || !nodes.length) {
        return pbTreeNodesList;
    }
    nodes.forEach((node) => {
        const pbTreeNodes = new resources_pb.TreeNodes();
        pbTreeNodes.setContentList(toTreeNodes(node));
        pbTreeNodesList.push(pbTreeNodes);
    });
    return pbTreeNodesList;
}
/**
 * `toTreeNodes` converts the given model to Protobuf format.
 */
function toTreeNodes(node) {
    if (!node) {
        return [];
    }
    const pbTreeNodes = [];
    traverse(node, (n, depth) => {
        const pbTreeNode = new resources_pb.TreeNode();
        pbTreeNode.setId(toTreeNodeID(n.id));
        pbTreeNode.setType(n.type);
        if (n.isText) {
            pbTreeNode.setValue(n.value);
        }
        if (n.insPrevID) {
            pbTreeNode.setInsPrevId(toTreeNodeID(n.insPrevID));
        }
        if (n.insNextID) {
            pbTreeNode.setInsNextId(toTreeNodeID(n.insNextID));
        }
        pbTreeNode.setRemovedAt(toTimeTicket(n.removedAt));
        pbTreeNode.setDepth(depth);
        if (n.attrs) {
            const pbNodeAttrsMap = pbTreeNode.getAttributesMap();
            for (const attr of n.attrs) {
                const pbNodeAttr = new resources_pb.NodeAttr();
                pbNodeAttr.setValue(attr.getValue());
                pbNodeAttr.setUpdatedAt(toTimeTicket(attr.getUpdatedAt()));
                pbNodeAttrsMap.set(attr.getKey(), pbNodeAttr);
            }
        }
        pbTreeNodes.push(pbTreeNode);
    });
    return pbTreeNodes;
}
/**
 * `toObject` converts the given model to Protobuf format.
 */
function toObject(obj) {
    const pbObject = new resources_pb.JSONElement.JSONObject();
    pbObject.setNodesList(toRHTNodes(obj.getRHT()));
    pbObject.setCreatedAt(toTimeTicket(obj.getCreatedAt()));
    pbObject.setMovedAt(toTimeTicket(obj.getMovedAt()));
    pbObject.setRemovedAt(toTimeTicket(obj.getRemovedAt()));
    const pbElement = new resources_pb.JSONElement();
    pbElement.setJsonObject(pbObject);
    return pbElement;
}
/**
 * `toArray` converts the given model to Protobuf format.
 */
function toArray(arr) {
    const pbArray = new resources_pb.JSONElement.JSONArray();
    pbArray.setNodesList(toRGANodes(arr.getElements()));
    pbArray.setCreatedAt(toTimeTicket(arr.getCreatedAt()));
    pbArray.setMovedAt(toTimeTicket(arr.getMovedAt()));
    pbArray.setRemovedAt(toTimeTicket(arr.getRemovedAt()));
    const pbElement = new resources_pb.JSONElement();
    pbElement.setJsonArray(pbArray);
    return pbElement;
}
/**
 * `toPrimitive` converts the given model to Protobuf format.
 */
function toPrimitive(primitive) {
    const pbPrimitive = new resources_pb.JSONElement.Primitive();
    pbPrimitive.setType(toValueType(primitive.getType()));
    pbPrimitive.setValue(primitive.toBytes());
    pbPrimitive.setCreatedAt(toTimeTicket(primitive.getCreatedAt()));
    pbPrimitive.setMovedAt(toTimeTicket(primitive.getMovedAt()));
    pbPrimitive.setRemovedAt(toTimeTicket(primitive.getRemovedAt()));
    const pbElement = new resources_pb.JSONElement();
    pbElement.setPrimitive(pbPrimitive);
    return pbElement;
}
/**
 * `toText` converts the given model to Protobuf format.
 */
function toText(text) {
    const pbText = new resources_pb.JSONElement.Text();
    pbText.setNodesList(toTextNodes(text.getRGATreeSplit()));
    pbText.setCreatedAt(toTimeTicket(text.getCreatedAt()));
    pbText.setMovedAt(toTimeTicket(text.getMovedAt()));
    pbText.setRemovedAt(toTimeTicket(text.getRemovedAt()));
    const pbElement = new resources_pb.JSONElement();
    pbElement.setText(pbText);
    return pbElement;
}
/**
 * `toCounter` converts the given model to Protobuf format.
 */
function toCounter(counter) {
    const pbCounter = new resources_pb.JSONElement.Counter();
    pbCounter.setType(toCounterType(counter.getType()));
    pbCounter.setValue(counter.toBytes());
    pbCounter.setCreatedAt(toTimeTicket(counter.getCreatedAt()));
    pbCounter.setMovedAt(toTimeTicket(counter.getMovedAt()));
    pbCounter.setRemovedAt(toTimeTicket(counter.getRemovedAt()));
    const pbElement = new resources_pb.JSONElement();
    pbElement.setCounter(pbCounter);
    return pbElement;
}
/**
 * `toTree` converts the given model to Protobuf format.
 */
function toTree(tree) {
    const pbTree = new resources_pb.JSONElement.Tree();
    pbTree.setNodesList(toTreeNodes(tree.getRoot()));
    pbTree.setCreatedAt(toTimeTicket(tree.getCreatedAt()));
    pbTree.setMovedAt(toTimeTicket(tree.getMovedAt()));
    pbTree.setRemovedAt(toTimeTicket(tree.getRemovedAt()));
    const pbElement = new resources_pb.JSONElement();
    pbElement.setTree(pbTree);
    return pbElement;
}
/**
 * `toElement` converts the given model to Protobuf format.
 */
function toElement(element) {
    if (element instanceof CRDTObject) {
        return toObject(element);
    }
    else if (element instanceof CRDTArray) {
        return toArray(element);
    }
    else if (element instanceof Primitive) {
        return toPrimitive(element);
    }
    else if (element instanceof CRDTText) {
        return toText(element);
    }
    else if (element instanceof CRDTCounter) {
        return toCounter(element);
    }
    else if (element instanceof CRDTTree) {
        return toTree(element);
    }
    else {
        throw new YorkieError(Code.Unimplemented, `unimplemented element`);
    }
}
/**
 * `toChangePack` converts the given model to Protobuf format.
 */
function toChangePack(pack) {
    const pbChangePack = new resources_pb.ChangePack();
    pbChangePack.setDocumentKey(pack.getDocumentKey());
    pbChangePack.setCheckpoint(toCheckpoint(pack.getCheckpoint()));
    pbChangePack.setIsRemoved(pack.getIsRemoved());
    pbChangePack.setChangesList(toChanges(pack.getChanges()));
    pbChangePack.setSnapshot(pack.getSnapshot());
    pbChangePack.setMinSyncedTicket(toTimeTicket(pack.getMinSyncedTicket()));
    return pbChangePack;
}
/**
 * `fromChangeID` converts the given Protobuf format to model format.
 */
function fromChangeID(pbChangeID) {
    return ChangeID.of(pbChangeID.getClientSeq(), node_modules_long.fromString(pbChangeID.getLamport(), true), toHexString(pbChangeID.getActorId_asU8()));
}
/**
 * `fromTimeTicket` converts the given Protobuf format to model format.
 */
function fromTimeTicket(pbTimeTicket) {
    if (!pbTimeTicket) {
        return;
    }
    return TimeTicket.of(node_modules_long.fromString(pbTimeTicket.getLamport(), true), pbTimeTicket.getDelimiter(), toHexString(pbTimeTicket.getActorId_asU8()));
}
/**
 * `fromPresence` converts the given Protobuf format to model format.
 */
function fromPresence(pbPresence) {
    const data = {};
    pbPresence.getDataMap().forEach((value, key) => {
        data[key] = JSON.parse(value);
    });
    return data;
}
/**
 * `fromPresenceChange` converts the given Protobuf format to model format.
 */
function fromPresenceChange(pbPresenceChange) {
    const type = pbPresenceChange.getType();
    if (type === resources_pb.PresenceChange.ChangeType.CHANGE_TYPE_PUT) {
        const presence = fromPresence(pbPresenceChange.getPresence());
        return {
            type: PresenceChangeType.Put,
            presence,
        };
    }
    else if (type === resources_pb.PresenceChange.ChangeType.CHANGE_TYPE_CLEAR) {
        return {
            type: PresenceChangeType.Clear,
        };
    }
    else {
        throw new YorkieError(Code.Unsupported, `unsupported type: ${type}`);
    }
}
/**
 * `fromPresences` converts the given Protobuf format to model format.
 */
function fromPresences(pbPresences) {
    const presences = new Map();
    pbPresences.forEach((pbPresence, actorID) => {
        presences.set(actorID, fromPresence(pbPresence));
    });
    return presences;
}
/**
 * `fromValueType` converts the given Protobuf format to model format.
 */
function fromValueType(pbValueType) {
    switch (pbValueType) {
        case resources_pb.ValueType.VALUE_TYPE_NULL:
            return PrimitiveType.Null;
        case resources_pb.ValueType.VALUE_TYPE_BOOLEAN:
            return PrimitiveType.Boolean;
        case resources_pb.ValueType.VALUE_TYPE_INTEGER:
            return PrimitiveType.Integer;
        case resources_pb.ValueType.VALUE_TYPE_LONG:
            return PrimitiveType.Long;
        case resources_pb.ValueType.VALUE_TYPE_DOUBLE:
            return PrimitiveType.Double;
        case resources_pb.ValueType.VALUE_TYPE_STRING:
            return PrimitiveType.String;
        case resources_pb.ValueType.VALUE_TYPE_BYTES:
            return PrimitiveType.Bytes;
        case resources_pb.ValueType.VALUE_TYPE_DATE:
            return PrimitiveType.Date;
    }
    throw new YorkieError(Code.Unimplemented, `unimplemented value type: ${pbValueType}`);
}
/**
 * `fromCounterType` converts the given Protobuf format to model format.
 */
function fromCounterType(pbValueType) {
    switch (pbValueType) {
        case resources_pb.ValueType.VALUE_TYPE_INTEGER_CNT:
            return CounterType.IntegerCnt;
        case resources_pb.ValueType.VALUE_TYPE_LONG_CNT:
            return CounterType.LongCnt;
    }
    throw new YorkieError(Code.Unimplemented, `unimplemented value type: ${pbValueType}`);
}
/**
 * `fromElementSimple` converts the given Protobuf format to model format.
 */
function fromElementSimple(pbElementSimple) {
    switch (pbElementSimple.getType()) {
        case resources_pb.ValueType.VALUE_TYPE_JSON_OBJECT:
            if (!pbElementSimple.getValue()) {
                return CRDTObject.create(fromTimeTicket(pbElementSimple.getCreatedAt()));
            }
            return bytesToObject(pbElementSimple.getValue_asU8());
        case resources_pb.ValueType.VALUE_TYPE_JSON_ARRAY:
            if (!pbElementSimple.getValue()) {
                return CRDTArray.create(fromTimeTicket(pbElementSimple.getCreatedAt()));
            }
            return bytesToArray(pbElementSimple.getValue_asU8());
        case resources_pb.ValueType.VALUE_TYPE_TEXT:
            return CRDTText.create(RGATreeSplit.create(), fromTimeTicket(pbElementSimple.getCreatedAt()));
        case resources_pb.ValueType.VALUE_TYPE_TREE:
            return bytesToTree(pbElementSimple.getValue_asU8());
        case resources_pb.ValueType.VALUE_TYPE_NULL:
        case resources_pb.ValueType.VALUE_TYPE_BOOLEAN:
        case resources_pb.ValueType.VALUE_TYPE_INTEGER:
        case resources_pb.ValueType.VALUE_TYPE_LONG:
        case resources_pb.ValueType.VALUE_TYPE_DOUBLE:
        case resources_pb.ValueType.VALUE_TYPE_STRING:
        case resources_pb.ValueType.VALUE_TYPE_BYTES:
        case resources_pb.ValueType.VALUE_TYPE_DATE:
            return Primitive.of(Primitive.valueFromBytes(fromValueType(pbElementSimple.getType()), pbElementSimple.getValue_asU8()), fromTimeTicket(pbElementSimple.getCreatedAt()));
        case resources_pb.ValueType.VALUE_TYPE_INTEGER_CNT:
        case resources_pb.ValueType.VALUE_TYPE_LONG_CNT:
            return CRDTCounter.create(fromCounterType(pbElementSimple.getType()), CRDTCounter.valueFromBytes(fromCounterType(pbElementSimple.getType()), pbElementSimple.getValue_asU8()), fromTimeTicket(pbElementSimple.getCreatedAt()));
    }
}
/**
 * `fromTextNodePos` converts the given Protobuf format to model format.
 */
function fromTextNodePos(pbTextNodePos) {
    return RGATreeSplitPos.of(RGATreeSplitNodeID.of(fromTimeTicket(pbTextNodePos.getCreatedAt()), pbTextNodePos.getOffset()), pbTextNodePos.getRelativeOffset());
}
/**
 * `fromTextNodeID` converts the given Protobuf format to model format.
 */
function fromTextNodeID(pbTextNodeID) {
    return RGATreeSplitNodeID.of(fromTimeTicket(pbTextNodeID.getCreatedAt()), pbTextNodeID.getOffset());
}
/**
 * `fromTextNode` converts the given Protobuf format to model format.
 */
function fromTextNode(pbTextNode) {
    const textValue = CRDTTextValue.create(pbTextNode.getValue());
    pbTextNode.getAttributesMap().forEach((value, key) => {
        textValue.setAttr(key, value.getValue(), fromTimeTicket(value.getUpdatedAt()));
    });
    const textNode = RGATreeSplitNode.create(fromTextNodeID(pbTextNode.getId()), textValue);
    textNode.remove(fromTimeTicket(pbTextNode.getRemovedAt()));
    return textNode;
}
/**
 * `fromTreePos` converts the given Protobuf format to model format.
 */
function fromTreePos(pbTreePos) {
    return CRDTTreePos.of(fromTreeNodeID(pbTreePos.getParentId()), fromTreeNodeID(pbTreePos.getLeftSiblingId()));
}
/**
 * `fromTreeNodeID` converts the given Protobuf format to model format.
 */
function fromTreeNodeID(pbTreeNodeID) {
    return CRDTTreeNodeID.of(fromTimeTicket(pbTreeNodeID.getCreatedAt()), pbTreeNodeID.getOffset());
}
/**
 * `fromTreeNodesWhenEdit` converts the given Protobuf format to model format.
 */
function fromTreeNodesWhenEdit(pbTreeNodes) {
    if (!pbTreeNodes.length) {
        return;
    }
    const treeNodes = [];
    pbTreeNodes.forEach((node) => {
        const treeNode = fromTreeNodes(node.getContentList());
        treeNodes.push(treeNode);
    });
    return treeNodes;
}
/**
 * `fromTreeNodes` converts the given Protobuf format to model format.
 */
function fromTreeNodes(pbTreeNodes) {
    if (pbTreeNodes.length === 0) {
        return;
    }
    const nodes = [];
    for (const pbTreeNode of pbTreeNodes) {
        nodes.push(fromTreeNode(pbTreeNode));
    }
    const root = nodes[nodes.length - 1];
    for (let i = nodes.length - 2; i >= 0; i--) {
        let parent;
        for (let j = i + 1; j < nodes.length; j++) {
            if (pbTreeNodes[i].getDepth() - 1 === pbTreeNodes[j].getDepth()) {
                parent = nodes[j];
                break;
            }
        }
        parent.prepend(nodes[i]);
    }
    // build CRDTTree from the root to construct the links between nodes.
    return CRDTTree.create(root, InitialTimeTicket).getRoot();
}
/**
 * `fromTreeNode` converts the given Protobuf format to model format.
 */
function fromTreeNode(pbTreeNode) {
    const id = fromTreeNodeID(pbTreeNode.getId());
    const node = CRDTTreeNode.create(id, pbTreeNode.getType());
    if (node.isText) {
        node.value = pbTreeNode.getValue();
    }
    else {
        const attrs = RHT.create();
        pbTreeNode.getAttributesMap().forEach((value, key) => {
            attrs.set(key, value.getValue(), fromTimeTicket(value.getUpdatedAt()));
        });
        node.attrs = attrs;
    }
    if (pbTreeNode.hasInsPrevId()) {
        node.insPrevID = fromTreeNodeID(pbTreeNode.getInsPrevId());
    }
    if (pbTreeNode.hasInsNextId()) {
        node.insNextID = fromTreeNodeID(pbTreeNode.getInsNextId());
    }
    node.removedAt = fromTimeTicket(pbTreeNode.getRemovedAt());
    return node;
}
/**
 * `fromOperations` converts the given Protobuf format to model format.
 */
function fromOperations(pbOperations) {
    const operations = [];
    for (const pbOperation of pbOperations) {
        let operation;
        if (pbOperation.hasSet()) {
            const pbSetOperation = pbOperation.getSet();
            operation = SetOperation.create(pbSetOperation.getKey(), fromElementSimple(pbSetOperation.getValue()), fromTimeTicket(pbSetOperation.getParentCreatedAt()), fromTimeTicket(pbSetOperation.getExecutedAt()));
        }
        else if (pbOperation.hasAdd()) {
            const pbAddOperation = pbOperation.getAdd();
            operation = AddOperation.create(fromTimeTicket(pbAddOperation.getParentCreatedAt()), fromTimeTicket(pbAddOperation.getPrevCreatedAt()), fromElementSimple(pbAddOperation.getValue()), fromTimeTicket(pbAddOperation.getExecutedAt()));
        }
        else if (pbOperation.hasMove()) {
            const pbMoveOperation = pbOperation.getMove();
            operation = MoveOperation.create(fromTimeTicket(pbMoveOperation.getParentCreatedAt()), fromTimeTicket(pbMoveOperation.getPrevCreatedAt()), fromTimeTicket(pbMoveOperation.getCreatedAt()), fromTimeTicket(pbMoveOperation.getExecutedAt()));
        }
        else if (pbOperation.hasRemove()) {
            const pbRemoveOperation = pbOperation.getRemove();
            operation = RemoveOperation.create(fromTimeTicket(pbRemoveOperation.getParentCreatedAt()), fromTimeTicket(pbRemoveOperation.getCreatedAt()), fromTimeTicket(pbRemoveOperation.getExecutedAt()));
        }
        else if (pbOperation.hasEdit()) {
            const pbEditOperation = pbOperation.getEdit();
            const createdAtMapByActor = new Map();
            pbEditOperation.getCreatedAtMapByActorMap().forEach((value, key) => {
                createdAtMapByActor.set(key, fromTimeTicket(value));
            });
            const attributes = new Map();
            pbEditOperation.getAttributesMap().forEach((value, key) => {
                attributes.set(key, value);
            });
            operation = EditOperation.create(fromTimeTicket(pbEditOperation.getParentCreatedAt()), fromTextNodePos(pbEditOperation.getFrom()), fromTextNodePos(pbEditOperation.getTo()), createdAtMapByActor, pbEditOperation.getContent(), attributes, fromTimeTicket(pbEditOperation.getExecutedAt()));
        }
        else if (pbOperation.hasStyle()) {
            const pbStyleOperation = pbOperation.getStyle();
            const createdAtMapByActor = new Map();
            pbStyleOperation.getCreatedAtMapByActorMap().forEach((value, key) => {
                createdAtMapByActor.set(key, fromTimeTicket(value));
            });
            const attributes = new Map();
            pbStyleOperation.getAttributesMap().forEach((value, key) => {
                attributes.set(key, value);
            });
            operation = StyleOperation.create(fromTimeTicket(pbStyleOperation.getParentCreatedAt()), fromTextNodePos(pbStyleOperation.getFrom()), fromTextNodePos(pbStyleOperation.getTo()), createdAtMapByActor, attributes, fromTimeTicket(pbStyleOperation.getExecutedAt()));
        }
        else if (pbOperation.hasSelect()) {
            // TODO(hackerwins): Select is deprecated.
            continue;
        }
        else if (pbOperation.hasIncrease()) {
            const pbIncreaseOperation = pbOperation.getIncrease();
            operation = IncreaseOperation.create(fromTimeTicket(pbIncreaseOperation.getParentCreatedAt()), fromElementSimple(pbIncreaseOperation.getValue()), fromTimeTicket(pbIncreaseOperation.getExecutedAt()));
        }
        else if (pbOperation.hasTreeEdit()) {
            const pbTreeEditOperation = pbOperation.getTreeEdit();
            const createdAtMapByActor = new Map();
            pbTreeEditOperation.getCreatedAtMapByActorMap().forEach((value, key) => {
                createdAtMapByActor.set(key, fromTimeTicket(value));
            });
            operation = TreeEditOperation.create(fromTimeTicket(pbTreeEditOperation.getParentCreatedAt()), fromTreePos(pbTreeEditOperation.getFrom()), fromTreePos(pbTreeEditOperation.getTo()), createdAtMapByActor, fromTreeNodesWhenEdit(pbTreeEditOperation.getContentsList()), fromTimeTicket(pbTreeEditOperation.getExecutedAt()));
        }
        else if (pbOperation.hasTreeStyle()) {
            const pbTreeStyleOperation = pbOperation.getTreeStyle();
            const attributes = new Map();
            pbTreeStyleOperation.getAttributesMap().forEach((value, key) => {
                attributes.set(key, value);
            });
            operation = TreeStyleOperation.create(fromTimeTicket(pbTreeStyleOperation.getParentCreatedAt()), fromTreePos(pbTreeStyleOperation.getFrom()), fromTreePos(pbTreeStyleOperation.getTo()), attributes, fromTimeTicket(pbTreeStyleOperation.getExecutedAt()));
        }
        else {
            throw new YorkieError(Code.Unimplemented, `unimplemented operation`);
        }
        operations.push(operation);
    }
    return operations;
}
/**
 * `fromChanges` converts the given Protobuf format to model format.
 */
function fromChanges(pbChanges) {
    const changes = [];
    for (const pbChange of pbChanges) {
        changes.push(Change.create({
            id: fromChangeID(pbChange.getId()),
            operations: fromOperations(pbChange.getOperationsList()),
            presenceChange: pbChange.hasPresenceChange()
                ? fromPresenceChange(pbChange.getPresenceChange())
                : undefined,
            message: pbChange.getMessage(),
        }));
    }
    return changes;
}
/**
 * `fromCheckpoint` converts the given Protobuf format to model format.
 */
function fromCheckpoint(pbCheckpoint) {
    return Checkpoint.of(node_modules_long.fromString(pbCheckpoint.getServerSeq(), true), pbCheckpoint.getClientSeq());
}
/**
 * `fromChangePack` converts the given Protobuf format to model format.
 */
function fromChangePack(pbPack) {
    return ChangePack.create(pbPack.getDocumentKey(), fromCheckpoint(pbPack.getCheckpoint()), pbPack.getIsRemoved(), fromChanges(pbPack.getChangesList()), pbPack.getSnapshot_asU8(), fromTimeTicket(pbPack.getMinSyncedTicket()));
}
/**
 * `fromObject` converts the given Protobuf format to model format.
 */
function fromObject(pbObject) {
    const rht = new ElementRHT();
    for (const pbRHTNode of pbObject.getNodesList()) {
        const value = fromElement(pbRHTNode.getElement());
        rht.set(pbRHTNode.getKey(), value, value.getPositionedAt());
    }
    const obj = new CRDTObject(fromTimeTicket(pbObject.getCreatedAt()), rht);
    obj.setMovedAt(fromTimeTicket(pbObject.getMovedAt()));
    obj.setRemovedAt(fromTimeTicket(pbObject.getRemovedAt()));
    return obj;
}
/**
 * `fromArray` converts the given Protobuf format to model format.
 */
function fromArray(pbArray) {
    const rgaTreeList = new RGATreeList();
    for (const pbRGANode of pbArray.getNodesList()) {
        // eslint-disable-next-line
        rgaTreeList.insert(fromElement(pbRGANode.getElement()));
    }
    const arr = new CRDTArray(fromTimeTicket(pbArray.getCreatedAt()), rgaTreeList);
    arr.setMovedAt(fromTimeTicket(pbArray.getMovedAt()));
    arr.setRemovedAt(fromTimeTicket(pbArray.getRemovedAt()));
    return arr;
}
/**
 * `fromPrimitive` converts the given Protobuf format to model format.
 */
function fromPrimitive(pbPrimitive) {
    const primitive = Primitive.of(Primitive.valueFromBytes(fromValueType(pbPrimitive.getType()), pbPrimitive.getValue_asU8()), fromTimeTicket(pbPrimitive.getCreatedAt()));
    primitive.setMovedAt(fromTimeTicket(pbPrimitive.getMovedAt()));
    primitive.setRemovedAt(fromTimeTicket(pbPrimitive.getRemovedAt()));
    return primitive;
}
/**
 * `fromText` converts the given Protobuf format to model format.
 */
function fromText(pbText) {
    const rgaTreeSplit = new RGATreeSplit();
    let prev = rgaTreeSplit.getHead();
    for (const pbNode of pbText.getNodesList()) {
        const current = rgaTreeSplit.insertAfter(prev, fromTextNode(pbNode));
        if (pbNode.hasInsPrevId()) {
            current.setInsPrev(rgaTreeSplit.findNode(fromTextNodeID(pbNode.getInsPrevId())));
        }
        prev = current;
    }
    const text = new CRDTText(rgaTreeSplit, fromTimeTicket(pbText.getCreatedAt()));
    text.setMovedAt(fromTimeTicket(pbText.getMovedAt()));
    text.setRemovedAt(fromTimeTicket(pbText.getRemovedAt()));
    return text;
}
/**
 * `fromCounter` converts the given Protobuf format to model format.
 */
function fromCounter(pbCounter) {
    const counter = CRDTCounter.create(fromCounterType(pbCounter.getType()), CRDTCounter.valueFromBytes(fromCounterType(pbCounter.getType()), pbCounter.getValue_asU8()), fromTimeTicket(pbCounter.getCreatedAt()));
    counter.setMovedAt(fromTimeTicket(pbCounter.getMovedAt()));
    counter.setRemovedAt(fromTimeTicket(pbCounter.getRemovedAt()));
    return counter;
}
/**
 * `fromTree` converts the given Protobuf format to model format.
 */
function fromTree(pbTree) {
    const root = fromTreeNodes(pbTree.getNodesList());
    return CRDTTree.create(root, fromTimeTicket(pbTree.getCreatedAt()));
}
/**
 * `fromElement` converts the given Protobuf format to model format.
 */
function fromElement(pbElement) {
    if (pbElement.hasJsonObject()) {
        return fromObject(pbElement.getJsonObject());
    }
    else if (pbElement.hasJsonArray()) {
        return fromArray(pbElement.getJsonArray());
    }
    else if (pbElement.hasPrimitive()) {
        return fromPrimitive(pbElement.getPrimitive());
    }
    else if (pbElement.hasText()) {
        return fromText(pbElement.getText());
    }
    else if (pbElement.hasCounter()) {
        return fromCounter(pbElement.getCounter());
    }
    else if (pbElement.hasTree()) {
        return fromTree(pbElement.getTree());
    }
    else {
        throw new YorkieError(Code.Unimplemented, `unimplemented element`);
    }
}
/**
 * `bytesToSnapshot` creates a Snapshot from the given byte array.
 */
function bytesToSnapshot(bytes) {
    if (!bytes) {
        return {
            root: CRDTObject.create(InitialTimeTicket),
            presences: new Map(),
        };
    }
    const snapshot = resources_pb.Snapshot.deserializeBinary(bytes);
    return {
        root: fromElement(snapshot.getRoot()),
        presences: fromPresences(snapshot.getPresencesMap()),
    };
}
/**
 * `bytesToObject` creates an JSONObject from the given byte array.
 */
function bytesToObject(bytes) {
    if (!bytes) {
        throw new Error('bytes is empty');
    }
    const pbElement = resources_pb.JSONElement.deserializeBinary(bytes);
    return fromObject(pbElement.getJsonObject());
}
/**
 * `objectToBytes` converts the given JSONObject to byte array.
 */
function objectToBytes(obj) {
    return toElement(obj).serializeBinary();
}
/**
 * `bytesToArray` creates an CRDTArray from the given bytes.
 */
function bytesToArray(bytes) {
    if (!bytes) {
        throw new Error('bytes is empty');
    }
    const pbElement = resources_pb.JSONElement.deserializeBinary(bytes);
    return fromArray(pbElement.getJsonArray());
}
/**
 * `arrayToBytes` converts the given CRDTArray to bytes.
 */
function arrayToBytes(array) {
    return toArray(array).serializeBinary();
}
/**
 * `bytesToTree` creates an CRDTTree from the given bytes.
 */
function bytesToTree(bytes) {
    if (!bytes) {
        throw new Error('bytes is empty');
    }
    const pbElement = resources_pb.JSONElement.deserializeBinary(bytes);
    return fromTree(pbElement.getTree());
}
/**
 * `treeToBytes` converts the given tree to bytes.
 */
function treeToBytes(tree) {
    return toTree(tree).serializeBinary();
}
/**
 * `bytesToHex` creates an hex string from the given byte array.
 */
function bytesToHex(bytes) {
    if (!bytes) {
        return '';
    }
    return Array.from(bytes)
        .map((b) => b.toString(16).padStart(2, '0'))
        .join('');
}
/**
 * `toHexString` converts the given byte array to hex string.
 */
function toHexString(bytes) {
    return bytesToHex(bytes);
}
/**
 * `hexToBytes` converts the given hex string to byte array.
 */
function hexToBytes(hex) {
    return new Uint8Array(hex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
}
/**
 * `toUnit8Array` converts the given hex string to byte array.
 */
function toUint8Array(hex) {
    return hexToBytes(hex);
}
/**
 * `converter` is a converter that converts the given model to protobuf format.
 * is also used to convert models to bytes and vice versa.
 */
const converter = {
    fromPresence,
    toChangePack,
    fromChangePack,
    fromChanges,
    objectToBytes,
    bytesToObject,
    bytesToSnapshot,
    toHexString,
    toUint8Array,
};

// EXTERNAL MODULE: ./src/api/yorkie/v1/yorkie_grpc_web_pb.js
var yorkie_grpc_web_pb = __webpack_require__(458);
;// CONCATENATED MODULE: ./src/client/attachment.ts

/**
 * `Attachment` is a class that manages the state of the document.
 */
class Attachment {
    constructor(reconnectStreamDelay, doc, docID, isRealtimeSync) {
        this.reconnectStreamDelay = reconnectStreamDelay;
        this.doc = doc;
        this.docID = docID;
        this.isRealtimeSync = isRealtimeSync;
        this.syncMode = SyncMode.PushPull;
        this.remoteChangeEventReceived = false;
    }
    /**
     * `changeRealtimeSync` changes whether to synchronize the document in realtime or not.
     */
    changeRealtimeSync(isRealtimeSync) {
        if (this.isRealtimeSync === isRealtimeSync) {
            return false;
        }
        if (isRealtimeSync) {
            this.isRealtimeSync = true;
            return true;
        }
        this.cancelWatchStream();
        this.isRealtimeSync = false;
        return true;
    }
    /**
     * `changeSyncMode` changes the sync mode of the document.
     */
    changeSyncMode(syncMode) {
        this.syncMode = syncMode;
    }
    /**
     * `needRealtimeSync` returns whether the document needs to be synced in real time.
     */
    needRealtimeSync() {
        return (this.isRealtimeSync &&
            (this.doc.hasLocalChanges() || this.remoteChangeEventReceived));
    }
    /**
     * `runWatchLoop` runs the watch loop.
     */
    async runWatchLoop(watchStreamCreator) {
        const doLoop = async () => {
            if (this.watchStream) {
                return Promise.resolve();
            }
            if (this.watchLoopTimerID) {
                clearTimeout(this.watchLoopTimerID);
                this.watchLoopTimerID = undefined;
            }
            const onDisconnect = () => {
                this.watchStream = undefined;
                this.watchLoopTimerID = setTimeout(doLoop, this.reconnectStreamDelay);
            };
            this.watchStream = await watchStreamCreator(onDisconnect);
        };
        await doLoop();
    }
    /**
     * `cancelWatchStream` cancels the watch stream.
     */
    cancelWatchStream() {
        if (this.watchStream) {
            this.watchStream.cancel();
            this.watchStream = undefined;
        }
        clearTimeout(this.watchLoopTimerID);
        this.watchLoopTimerID = undefined;
    }
}

;// CONCATENATED MODULE: ./src/document/change/context.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * `ChangeContext` is used to record the context of modification when editing
 * a document. Each time we add an operation, a new time ticket is issued.
 * Finally returns a Change after the modification has been completed.
 */
class ChangeContext {
    constructor(id, root, presence, message) {
        this.id = id;
        this.delimiter = InitialDelimiter;
        this.root = root;
        this.operations = [];
        this.previousPresence = deepcopy(presence);
        this.presenceChange = undefined;
        this.reversePresenceKeys = new Set();
        this.message = message;
    }
    /**
     * `create` creates a new instance of ChangeContext.
     */
    static create(id, root, presence, message) {
        return new ChangeContext(id, root, presence, message);
    }
    /**
     * `push` pushes the given operation to this context.
     */
    push(operation) {
        this.operations.push(operation);
    }
    /**
     * `registerElement` registers the given element to the root.
     */
    registerElement(element, parent) {
        this.root.registerElement(element, parent);
    }
    /**
     * `registerRemovedElement` register removed element for garbage collection.
     */
    registerRemovedElement(deleted) {
        this.root.registerRemovedElement(deleted);
    }
    /**
     * `registerElementHasRemovedNodes` register GC element has removed node for
     * garbage collection.
     */
    registerElementHasRemovedNodes(elem) {
        this.root.registerElementHasRemovedNodes(elem);
    }
    /**
     * `getChange` creates a new instance of Change in this context.
     */
    getChange() {
        return Change.create({
            id: this.id,
            operations: this.operations,
            presenceChange: this.presenceChange,
            message: this.message,
        });
    }
    /**
     * `hasChange` returns whether this context has change or not.
     */
    hasChange() {
        return this.operations.length > 0 || this.presenceChange !== undefined;
    }
    /**
     * `setPresenceChange` registers the presence change to this context.
     */
    setPresenceChange(presenceChange) {
        this.presenceChange = presenceChange;
    }
    /**
     * `setReversePresence` registers the previous presence to undo presence updates.
     */
    setReversePresence(presence, option) {
        for (const key of Object.keys(presence)) {
            if (option === null || option === void 0 ? void 0 : option.addToHistory) {
                this.reversePresenceKeys.add(key);
            }
            else {
                this.reversePresenceKeys.delete(key);
            }
        }
    }
    /**
     * `toReversePresence` returns the reverse presence of this context.
     */
    getReversePresence() {
        if (this.reversePresenceKeys.size === 0)
            return undefined;
        const reversePresence = {};
        for (const key of this.reversePresenceKeys) {
            reversePresence[key] = this.previousPresence[key];
        }
        return reversePresence;
    }
    /**
     * `issueTimeTicket` creates a time ticket to be used to create a new operation.
     */
    issueTimeTicket() {
        this.delimiter += 1;
        return this.id.createTimeTicket(this.delimiter);
    }
    /**
     * `getLastTimeTicket` returns the last time ticket issued in this context.
     */
    getLastTimeTicket() {
        return this.id.createTimeTicket(this.delimiter);
    }
}

;// CONCATENATED MODULE: ./src/document/crdt/root.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * `CRDTRoot` is a structure that represents the root. It has a hash table of
 * all elements to find a specific element when applying remote changes
 * received from server.
 *
 * Every element has a unique `TimeTicket` at creation, which allows us to find
 * a particular element.
 */
class CRDTRoot {
    constructor(rootObject) {
        this.rootObject = rootObject;
        this.elementPairMapByCreatedAt = new Map();
        this.removedElementSetByCreatedAt = new Set();
        this.elementHasRemovedNodesSetByCreatedAt = new Set();
        this.opsForTest = [];
        this.registerElement(rootObject, undefined);
    }
    /**
     * `create` creates a new instance of Root.
     */
    static create() {
        return new CRDTRoot(CRDTObject.create(InitialTimeTicket));
    }
    /**
     * `findByCreatedAt` returns the element of given creation time.
     */
    findByCreatedAt(createdAt) {
        const pair = this.elementPairMapByCreatedAt.get(createdAt.toIDString());
        if (!pair) {
            return;
        }
        return pair.element;
    }
    /**
     * `findElementPairByCreatedAt` returns the element and parent pair
     * of given creation time.
     */
    findElementPairByCreatedAt(createdAt) {
        return this.elementPairMapByCreatedAt.get(createdAt.toIDString());
    }
    /**
     * `createSubPaths` creates an array of the sub paths for the given element.
     */
    createSubPaths(createdAt) {
        let pair = this.elementPairMapByCreatedAt.get(createdAt.toIDString());
        if (!pair) {
            return [];
        }
        const subPaths = [];
        while (pair.parent) {
            const createdAt = pair.element.getCreatedAt();
            const subPath = pair.parent.subPathOf(createdAt);
            if (subPath === undefined) {
                logger.fatal(`cant find the given element: ${createdAt.toIDString()}`);
            }
            subPaths.unshift(subPath);
            pair = this.elementPairMapByCreatedAt.get(pair.parent.getCreatedAt().toIDString());
        }
        subPaths.unshift('$');
        return subPaths;
    }
    /**
     * `createPath` creates path of the given element.
     */
    createPath(createdAt) {
        return this.createSubPaths(createdAt).join('.');
    }
    /**
     * `registerElement` registers the given element and its descendants to hash table.
     */
    registerElement(element, parent) {
        this.elementPairMapByCreatedAt.set(element.getCreatedAt().toIDString(), {
            parent,
            element,
        });
        if (element instanceof CRDTContainer) {
            element.getDescendants((elem, parent) => {
                this.registerElement(elem, parent);
                return false;
            });
        }
    }
    /**
     * `deregisterElement` deregister the given element and its descendants from hash table.
     */
    deregisterElement(element) {
        let count = 0;
        const deregisterElementInternal = (elem) => {
            const createdAt = elem.getCreatedAt().toIDString();
            this.elementPairMapByCreatedAt.delete(createdAt);
            this.removedElementSetByCreatedAt.delete(createdAt);
            count++;
            if (elem instanceof CRDTContainer) {
                elem.getDescendants((e) => {
                    deregisterElementInternal(e);
                    return false;
                });
            }
        };
        deregisterElementInternal(element);
        return count;
    }
    /**
     * `registerRemovedElement` registers the given element to the hash set.
     */
    registerRemovedElement(element) {
        this.removedElementSetByCreatedAt.add(element.getCreatedAt().toIDString());
    }
    /**
     * `registerElementHasRemovedNodes` registers the given GC element to the
     * hash set.
     */
    registerElementHasRemovedNodes(elem) {
        this.elementHasRemovedNodesSetByCreatedAt.add(elem.getCreatedAt().toIDString());
    }
    /**
     * `getElementMapSize` returns the size of element map.
     */
    getElementMapSize() {
        return this.elementPairMapByCreatedAt.size;
    }
    /**
     * `getRemovedElementSetSize()` returns the size of removed element set.
     */
    getRemovedElementSetSize() {
        return this.removedElementSetByCreatedAt.size;
    }
    /**
     * `getObject` returns root object.
     */
    getObject() {
        return this.rootObject;
    }
    /**
     * `getGarbageLen` returns length of nodes which can be garbage collected.
     */
    getGarbageLen() {
        let count = 0;
        for (const createdAt of this.removedElementSetByCreatedAt) {
            count++;
            const pair = this.elementPairMapByCreatedAt.get(createdAt);
            if (pair.element instanceof CRDTContainer) {
                pair.element.getDescendants(() => {
                    count++;
                    return false;
                });
            }
        }
        for (const createdAt of this.elementHasRemovedNodesSetByCreatedAt) {
            const pair = this.elementPairMapByCreatedAt.get(createdAt);
            const elem = pair.element;
            count += elem.getRemovedNodesLen();
        }
        return count;
    }
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy() {
        return new CRDTRoot(this.rootObject.deepcopy());
    }
    /**
     * `garbageCollect` purges elements that were removed before the given time.
     */
    garbageCollect(ticket) {
        let count = 0;
        for (const createdAt of this.removedElementSetByCreatedAt) {
            const pair = this.elementPairMapByCreatedAt.get(createdAt);
            if (pair.element.getRemovedAt() &&
                ticket.compare(pair.element.getRemovedAt()) >= 0) {
                pair.parent.purge(pair.element);
                count += this.deregisterElement(pair.element);
            }
        }
        for (const createdAt of this.elementHasRemovedNodesSetByCreatedAt) {
            const pair = this.elementPairMapByCreatedAt.get(createdAt);
            const elem = pair.element;
            const removedNodeCnt = elem.purgeRemovedNodesBefore(ticket);
            if (removedNodeCnt > 0) {
                this.elementHasRemovedNodesSetByCreatedAt.delete(elem.getCreatedAt().toIDString());
            }
            count += removedNodeCnt;
        }
        return count;
    }
    /**
     * `toJSON` returns the JSON encoding of this root object.
     */
    toJSON() {
        return this.rootObject.toJSON();
    }
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this root object.
     */
    toSortedJSON() {
        return this.rootObject.toSortedJSON();
    }
}

;// CONCATENATED MODULE: ./src/document/json/object.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * `createJSONObject` creates a new instance of JSONObject.
 */
function createJSONObject(context, target) {
    const objectProxy = new ObjectProxy(context);
    return new Proxy(target, objectProxy.getHandlers());
}
/**
 * `ObjectProxy` is a proxy representing `Object`.
 */
class ObjectProxy {
    constructor(context) {
        this.context = context;
        this.handlers = {
            set: (target, key, value) => {
                if (logger.isEnabled(LogLevel.Trivial)) {
                    logger.trivial(`obj[${key}]=${JSON.stringify(value)}`);
                }
                ObjectProxy.setInternal(context, target, key, value);
                return true;
            },
            get: (target, keyOrMethod) => {
                if (logger.isEnabled(LogLevel.Trivial)) {
                    logger.trivial(`obj[${keyOrMethod}]`);
                }
                if (keyOrMethod === 'getID') {
                    return () => {
                        return target.getCreatedAt();
                    };
                }
                else if (keyOrMethod === 'toJSON' || keyOrMethod === 'toString') {
                    return () => {
                        return target.toJSON();
                    };
                }
                else if (keyOrMethod === 'toJS') {
                    return () => {
                        return target.toJS();
                    };
                }
                else if (keyOrMethod === 'toJSForTest') {
                    return () => {
                        return target.toJSForTest();
                    };
                }
                return toJSONElement(context, target.get(keyOrMethod));
            },
            ownKeys: (target) => {
                return target.getKeys();
            },
            getOwnPropertyDescriptor: () => {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            deleteProperty: (target, key) => {
                if (logger.isEnabled(LogLevel.Trivial)) {
                    logger.trivial(`obj[${key}]`);
                }
                ObjectProxy.deleteInternal(context, target, key);
                return true;
            },
        };
    }
    /**
     * `setInternal` sets a new Object for the given key
     */
    static setInternal(context, target, key, value) {
        if (key.includes('.')) {
            throw new YorkieError(Code.InvalidObjectKey, `key must not contain the '.'.`);
        }
        const createdAt = context.issueTimeTicket();
        const element = buildCRDTElement(context, value, createdAt);
        const removed = target.set(key, element, createdAt);
        context.registerElement(element, target);
        if (removed) {
            context.registerRemovedElement(removed);
        }
        context.push(SetOperation.create(key, element.deepcopy(), target.getCreatedAt(), createdAt));
    }
    /**
     * `buildObjectMembers` constructs an object where all values from the
     * user-provided object are transformed into CRDTElements.
     * This function takes an object and iterates through its values,
     * converting each value into a corresponding CRDTElement.
     */
    static buildObjectMembers(context, value) {
        const members = {};
        for (const [k, v] of Object.entries(value)) {
            if (k.includes('.')) {
                throw new YorkieError(Code.InvalidObjectKey, `key must not contain the '.'.`);
            }
            const createdAt = context.issueTimeTicket();
            const elem = buildCRDTElement(context, v, createdAt);
            members[k] = elem;
        }
        return members;
    }
    /**
     * `deleteInternal` deletes the value of the given key.
     */
    static deleteInternal(context, target, key) {
        const ticket = context.issueTimeTicket();
        const deleted = target.deleteByKey(key, ticket);
        if (!deleted) {
            return;
        }
        context.push(RemoveOperation.create(target.getCreatedAt(), deleted.getCreatedAt(), ticket));
        context.registerRemovedElement(deleted);
    }
    /**
     * `getHandlers` gets handlers.
     */
    getHandlers() {
        return this.handlers;
    }
}

;// CONCATENATED MODULE: ./src/document/json/array.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * `createJSONArray` creates a new instance of JSONArray.
 */
function createJSONArray(context, target) {
    const arrayProxy = new ArrayProxy(context, target);
    return new Proxy(target, arrayProxy.getHandlers());
}
/**
 * `isNumericString` checks if value is numeric string.
 */
function isNumericString(val) {
    if (typeof val === 'string' || val instanceof String) {
        return !isNaN(val);
    }
    return false;
}
/**
 * `isReadOnlyArrayMethod` checks if the method is a standard array read-only operation.
 */
function isReadOnlyArrayMethod(method) {
    return [
        'concat',
        'entries',
        'every',
        'filter',
        'find',
        'findIndex',
        'forEach',
        'join',
        'keys',
        'map',
        'reduce',
        'reduceRight',
        'slice',
        'some',
        'toLocaleString',
        'toString',
        'values',
    ].includes(method);
}
/**
 * `ArrayProxy` is a proxy for Array.
 */
class ArrayProxy {
    constructor(context, array) {
        this.context = context;
        this.array = array;
        this.handlers = {
            get: (target, method, receiver) => {
                if (method === 'getID') {
                    return () => {
                        return target.getCreatedAt();
                    };
                }
                else if (method === 'getElementByID') {
                    return (createdAt) => {
                        const elem = target.getByID(createdAt);
                        if (!elem || elem.isRemoved()) {
                            return;
                        }
                        return toWrappedElement(context, elem);
                    };
                }
                else if (method === 'getElementByIndex') {
                    return (index) => {
                        const elem = target.get(index);
                        return toWrappedElement(context, elem);
                    };
                }
                else if (method === 'getLast') {
                    return () => {
                        return toWrappedElement(context, target.getLast());
                    };
                }
                else if (method === 'deleteByID') {
                    return (createdAt) => {
                        const deleted = ArrayProxy.deleteInternalByID(context, target, createdAt);
                        return toWrappedElement(context, deleted);
                    };
                }
                else if (method === 'insertAfter') {
                    return (prevID, value) => {
                        const inserted = ArrayProxy.insertAfterInternal(context, target, prevID, value);
                        return toWrappedElement(context, inserted);
                    };
                }
                else if (method === 'insertBefore') {
                    return (nextID, value) => {
                        const inserted = ArrayProxy.insertBeforeInternal(context, target, nextID, value);
                        return toWrappedElement(context, inserted);
                    };
                }
                else if (method === 'moveBefore') {
                    return (nextID, id) => {
                        ArrayProxy.moveBeforeInternal(context, target, nextID, id);
                    };
                    // JavaScript Native API
                }
                else if (method === 'moveAfter') {
                    return (prevID, id) => {
                        ArrayProxy.moveAfterInternal(context, target, prevID, id);
                    };
                }
                else if (method === 'moveFront') {
                    return (id) => {
                        ArrayProxy.moveFrontInternal(context, target, id);
                    };
                }
                else if (method === 'moveLast') {
                    return (id) => {
                        ArrayProxy.moveLastInternal(context, target, id);
                    };
                }
                else if (isNumericString(method)) {
                    return toJSONElement(context, target.get(Number(method)));
                }
                else if (method === 'push') {
                    return (value) => {
                        return ArrayProxy.pushInternal(context, target, value);
                    };
                }
                else if (method === 'splice') {
                    return (start, deleteCount, ...items) => {
                        return ArrayProxy.splice(context, target, start, deleteCount, ...items);
                    };
                }
                else if (method === 'length') {
                    return target.length;
                }
                else if (typeof method === 'symbol' && method === Symbol.iterator) {
                    return ArrayProxy.iteratorInternal.bind(this, context, target);
                }
                else if (method === 'includes') {
                    return (searchElement, fromIndex) => {
                        return ArrayProxy.includes(context, target, searchElement, fromIndex);
                    };
                }
                else if (method === 'indexOf') {
                    return (searchElement, fromIndex) => {
                        return ArrayProxy.indexOf(context, target, searchElement, fromIndex);
                    };
                }
                else if (method === 'lastIndexOf') {
                    return (searchElement, fromIndex) => {
                        return ArrayProxy.lastIndexOf(context, target, searchElement, fromIndex);
                    };
                }
                else if (method === 'toTestString') {
                    return () => ArrayProxy.toTestString(target);
                }
                else if (typeof method === 'string' &&
                    isReadOnlyArrayMethod(method)) {
                    return (...args) => {
                        const arr = Array.from(target).map((elem) => toJSONElement(context, elem));
                        return Array.prototype[method].apply(arr, args);
                    };
                }
                // TODO we need to distinguish between the case we need to call default
                // behavior and the case where we need to call an internal method
                // throw new TypeError(`Unsupported method: ${String(method)}`);
                return Reflect.get(target, method, receiver);
            },
            deleteProperty: (target, key) => {
                if (logger.isEnabled(LogLevel.Trivial)) {
                    logger.trivial(`array[${key}]`);
                }
                ArrayProxy.deleteInternalByIndex(context, target, Number.parseInt(key));
                return true;
            },
        };
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static *iteratorInternal(change, target) {
        for (const elem of target) {
            yield toWrappedElement(change, elem);
        }
    }
    /**
     * `buildArrayElements` constructs array elements based on the user-provided array.
     */
    static buildArrayElements(context, value) {
        const elements = [];
        for (const v of value) {
            const createdAt = context.issueTimeTicket();
            const elem = buildCRDTElement(context, v, createdAt);
            elements.push(elem);
        }
        return elements;
    }
    /**
     * `pushInternal` pushes the value to the target array.
     */
    static pushInternal(context, target, value) {
        ArrayProxy.insertAfterInternal(context, target, target.getLastCreatedAt(), value);
        return target.length;
    }
    /**
     * `moveBeforeInternal` moves the given `createdAt` element
     * after the previously created element.
     */
    static moveBeforeInternal(context, target, nextCreatedAt, createdAt) {
        const ticket = context.issueTimeTicket();
        const prevCreatedAt = target.getPrevCreatedAt(nextCreatedAt);
        target.moveAfter(prevCreatedAt, createdAt, ticket);
        context.push(MoveOperation.create(target.getCreatedAt(), prevCreatedAt, createdAt, ticket));
    }
    /**
     * `moveAfterInternal` moves the given `createdAt` element
     * after the specific element.
     */
    static moveAfterInternal(context, target, prevCreatedAt, createdAt) {
        const ticket = context.issueTimeTicket();
        target.moveAfter(prevCreatedAt, createdAt, ticket);
        context.push(MoveOperation.create(target.getCreatedAt(), prevCreatedAt, createdAt, ticket));
    }
    /**
     * `moveFrontInternal` moves the given `createdAt` element
     * at the first of array.
     */
    static moveFrontInternal(context, target, createdAt) {
        const ticket = context.issueTimeTicket();
        const head = target.getHead();
        target.moveAfter(head.getCreatedAt(), createdAt, ticket);
        context.push(MoveOperation.create(target.getCreatedAt(), head.getCreatedAt(), createdAt, ticket));
    }
    /**
     * `moveLastInternal` moves the given `createdAt` element
     * at the last of array.
     */
    static moveLastInternal(context, target, createdAt) {
        const ticket = context.issueTimeTicket();
        const last = target.getLastCreatedAt();
        target.moveAfter(last, createdAt, ticket);
        context.push(MoveOperation.create(target.getCreatedAt(), last, createdAt, ticket));
    }
    /**
     * `insertAfterInternal` inserts the value after the previously created element.
     */
    static insertAfterInternal(context, target, prevCreatedAt, value) {
        const createdAt = context.issueTimeTicket();
        const element = buildCRDTElement(context, value, createdAt);
        target.insertAfter(prevCreatedAt, element);
        context.registerElement(element, target);
        context.push(AddOperation.create(target.getCreatedAt(), prevCreatedAt, element.deepcopy(), createdAt));
        return element;
    }
    /**
     * `insertBeforeInternal` inserts the value before the previously created element.
     */
    static insertBeforeInternal(context, target, nextCreatedAt, value) {
        return ArrayProxy.insertAfterInternal(context, target, target.getPrevCreatedAt(nextCreatedAt), value);
    }
    /**
     * `deleteInternalByIndex` deletes target element of given index.
     */
    static deleteInternalByIndex(context, target, index) {
        const ticket = context.issueTimeTicket();
        const deleted = target.deleteByIndex(index, ticket);
        if (!deleted) {
            return;
        }
        context.push(RemoveOperation.create(target.getCreatedAt(), deleted.getCreatedAt(), ticket));
        context.registerRemovedElement(deleted);
        return deleted;
    }
    /**
     * `deleteInternalByID` deletes the element of the given ID.
     */
    static deleteInternalByID(context, target, createdAt) {
        const ticket = context.issueTimeTicket();
        const deleted = target.delete(createdAt, ticket);
        context.push(RemoveOperation.create(target.getCreatedAt(), deleted.getCreatedAt(), ticket));
        context.registerRemovedElement(deleted);
        return deleted;
    }
    /**
     * `splice` is a method to remove elements from the array.
     */
    static splice(context, target, start, deleteCount, ...items) {
        const length = target.length;
        const from = start >= 0 ? Math.min(start, length) : Math.max(length + start, 0);
        const to = deleteCount === undefined
            ? length
            : deleteCount < 0
                ? from
                : Math.min(from + deleteCount, length);
        const removeds = [];
        for (let i = from; i < to; i++) {
            const removed = ArrayProxy.deleteInternalByIndex(context, target, from);
            if (removed) {
                const removedElem = removed.deepcopy();
                removedElem.setRemovedAt();
                removeds.push(toJSONElement(context, removedElem));
            }
        }
        if (items) {
            let previousID = from === 0 ? target.getHead().getID() : target.get(from - 1).getID();
            for (const item of items) {
                const newElem = ArrayProxy.insertAfterInternal(context, target, previousID, item);
                previousID = newElem.getID();
            }
        }
        return removeds;
    }
    /**
     * `includes` returns true if the given element is in the array.
     */
    static includes(context, target, searchElement, fromIndex) {
        var _a;
        const length = target.length;
        const from = fromIndex === undefined
            ? 0
            : fromIndex < 0
                ? Math.max(fromIndex + length, 0)
                : fromIndex;
        if (from >= length)
            return false;
        if (Primitive.isSupport(searchElement)) {
            const arr = Array.from(target).map((elem) => toJSONElement(context, elem));
            return arr.includes(searchElement, from);
        }
        for (let i = from; i < length; i++) {
            if (((_a = target.get(i)) === null || _a === void 0 ? void 0 : _a.getID()) === searchElement.getID()) {
                return true;
            }
        }
        return false;
    }
    /**
     * `indexOf` returns the index of the given element.
     */
    static indexOf(context, target, searchElement, fromIndex) {
        var _a;
        const length = target.length;
        const from = fromIndex === undefined
            ? 0
            : fromIndex < 0
                ? Math.max(fromIndex + length, 0)
                : fromIndex;
        if (from >= length)
            return -1;
        if (Primitive.isSupport(searchElement)) {
            const arr = Array.from(target).map((elem) => toJSONElement(context, elem));
            return arr.indexOf(searchElement, from);
        }
        for (let i = from; i < length; i++) {
            if (((_a = target.get(i)) === null || _a === void 0 ? void 0 : _a.getID()) === searchElement.getID()) {
                return i;
            }
        }
        return -1;
    }
    /**
     * `lastIndexOf` returns the last index of the given element.
     */
    static lastIndexOf(context, target, searchElement, fromIndex) {
        var _a;
        const length = target.length;
        const from = fromIndex === undefined || fromIndex >= length
            ? length - 1
            : fromIndex < 0
                ? fromIndex + length
                : fromIndex;
        if (from < 0)
            return -1;
        if (Primitive.isSupport(searchElement)) {
            const arr = Array.from(target).map((elem) => toJSONElement(context, elem));
            return arr.lastIndexOf(searchElement, from);
        }
        for (let i = from; i > 0; i--) {
            if (((_a = target.get(i)) === null || _a === void 0 ? void 0 : _a.getID()) === searchElement.getID()) {
                return i;
            }
        }
        return -1;
    }
    /**
     * `toTestString` returns a String containing the meta data of the node
     * for debugging purpose.
     */
    static toTestString(target) {
        return target.toTestString();
    }
    /**
     * `getHandlers` gets handlers.
     */
    getHandlers() {
        return this.handlers;
    }
}

;// CONCATENATED MODULE: ./src/document/json/text.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * `Text` is an extended data type for the contents of a text editor.
 */
class Text {
    constructor(context, text) {
        this.context = context;
        this.text = text;
    }
    /**
     * `initialize` initialize this text with context and internal text.
     * @internal
     */
    initialize(context, text) {
        this.context = context;
        this.text = text;
    }
    /**
     * `getID` returns the ID of this text.
     */
    getID() {
        return this.text.getID();
    }
    /**
     * `edit` edits this text with the given content.
     */
    edit(fromIdx, toIdx, content, attributes) {
        if (!this.context || !this.text) {
            logger.fatal('it is not initialized yet');
            return;
        }
        if (fromIdx > toIdx) {
            logger.fatal('from should be less than or equal to to');
            return;
        }
        const range = this.text.indexRangeToPosRange(fromIdx, toIdx);
        if (logger.isEnabled(LogLevel.Debug)) {
            logger.debug(`EDIT: f:${fromIdx}->${range[0].toTestString()}, t:${toIdx}->${range[1].toTestString()} c:${content}`);
        }
        const attrs = attributes ? stringifyObjectValues(attributes) : undefined;
        const ticket = this.context.issueTimeTicket();
        const [maxCreatedAtMapByActor, , rangeAfterEdit] = this.text.edit(range, content, ticket, attrs);
        this.context.push(new EditOperation(this.text.getCreatedAt(), range[0], range[1], maxCreatedAtMapByActor, content, attrs ? new Map(Object.entries(attrs)) : new Map(), ticket));
        if (!range[0].equals(range[1])) {
            this.context.registerElementHasRemovedNodes(this.text);
        }
        return this.text.findIndexesFromRange(rangeAfterEdit);
    }
    /**
     * `delete` deletes the text in the given range.
     */
    delete(fromIdx, toIdx) {
        return this.edit(fromIdx, toIdx, '');
    }
    /**
     * `empty` makes the text empty.
     */
    empty() {
        return this.edit(0, this.length, '');
    }
    /**
     * `setStyle` styles this text with the given attributes.
     */
    setStyle(fromIdx, toIdx, attributes) {
        if (!this.context || !this.text) {
            logger.fatal('it is not initialized yet');
            return false;
        }
        if (fromIdx > toIdx) {
            logger.fatal('from should be less than or equal to to');
            return false;
        }
        const range = this.text.indexRangeToPosRange(fromIdx, toIdx);
        if (logger.isEnabled(LogLevel.Debug)) {
            logger.debug(`STYL: f:${fromIdx}->${range[0].toTestString()}, t:${toIdx}->${range[1].toTestString()} a:${JSON.stringify(attributes)}`);
        }
        const attrs = stringifyObjectValues(attributes);
        const ticket = this.context.issueTimeTicket();
        const [maxCreatedAtMapByActor] = this.text.setStyle(range, attrs, ticket);
        this.context.push(new StyleOperation(this.text.getCreatedAt(), range[0], range[1], maxCreatedAtMapByActor, new Map(Object.entries(attrs)), ticket));
        return true;
    }
    /**
     * `indexRangeToPosRange` returns TextRangeStruct of the given index range.
     */
    indexRangeToPosRange(range) {
        if (!this.context || !this.text) {
            logger.fatal('it is not initialized yet');
            // @ts-ignore
            return;
        }
        const textRange = this.text.indexRangeToPosRange(range[0], range[1]);
        return [textRange[0].toStruct(), textRange[1].toStruct()];
    }
    /**
     * `posRangeToIndexRange` returns indexes of the given TextRangeStruct.
     */
    posRangeToIndexRange(range) {
        if (!this.context || !this.text) {
            logger.fatal('it is not initialized yet');
            // @ts-ignore
            return;
        }
        const textRange = this.text.findIndexesFromRange([
            RGATreeSplitPos.fromStruct(range[0]),
            RGATreeSplitPos.fromStruct(range[1]),
        ]);
        return [textRange[0], textRange[1]];
    }
    /**
     * `toTestString` returns a String containing the meta data of the node
     * for debugging purpose.
     */
    toTestString() {
        if (!this.context || !this.text) {
            logger.fatal('it is not initialized yet');
            // @ts-ignore
            return;
        }
        return this.text.toTestString();
    }
    /**
     * `values` returns values of this text.
     */
    values() {
        if (!this.context || !this.text) {
            logger.fatal('it is not initialized yet');
            // @ts-ignore
            return;
        }
        return this.text.values();
    }
    /**
     * `length` returns size of RGATreeList.
     */
    get length() {
        return this.text.length;
    }
    /**
     * `checkWeight` returns false when there is an incorrect weight node.
     * for debugging purpose.
     */
    checkWeight() {
        return this.text.checkWeight();
    }
    /**
     * `toString` returns the string representation of this text.
     */
    toString() {
        if (!this.context || !this.text) {
            logger.fatal('it is not initialized yet');
            return '';
        }
        return this.text.toString();
    }
    /**
     * `createRangeForTest` returns pair of RGATreeSplitNodePos of the given indexes
     * for testing purpose.
     */
    createRangeForTest(fromIdx, toIdx) {
        if (!this.context || !this.text) {
            logger.fatal('it is not initialized yet');
            // @ts-ignore
            return;
        }
        return this.text.indexRangeToPosRange(fromIdx, toIdx);
    }
}

;// CONCATENATED MODULE: ./src/document/json/counter.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * `Counter` is a custom data type that is used to counter.
 */
class Counter {
    constructor(valueType, value) {
        this.valueType = valueType;
        this.value = value;
    }
    /**
     * `initialize` initialize this text with context and internal text.
     * @internal
     */
    initialize(context, counter) {
        this.valueType = counter.getValueType();
        this.context = context;
        this.counter = counter;
        this.value = counter.getValue();
    }
    /**
     * `getID` returns the ID of this text.
     */
    getID() {
        return this.counter.getID();
    }
    /**
     * `getValue` returns the value of this counter;
     * @internal
     */
    getValue() {
        return this.value;
    }
    /**
     * `getValueType` returns the value type of this counter.
     */
    getValueType() {
        return this.valueType;
    }
    /**
     * `increase` increases numeric data.
     */
    increase(v) {
        if (!this.context || !this.counter) {
            logger.fatal('it is not initialized yet');
            // @ts-ignore
            return;
        }
        const ticket = this.context.issueTimeTicket();
        const value = Primitive.of(v, ticket);
        if (!value.isNumericType()) {
            throw new TypeError(`Unsupported type of value: ${typeof value.getValue()}`);
        }
        this.counter.increase(value);
        this.context.push(IncreaseOperation.create(this.counter.getCreatedAt(), value, ticket));
        return this;
    }
}

;// CONCATENATED MODULE: ./src/document/json/tree.ts
/*
 * Copyright 2023 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * `buildDescendants` builds descendants of the given tree node.
 */
function buildDescendants(treeNode, parent, context) {
    const { type } = treeNode;
    const ticket = context.issueTimeTicket();
    if (type === DefaultTextType) {
        validateTextNode(treeNode);
        const { value } = treeNode;
        const textNode = CRDTTreeNode.create(CRDTTreeNodeID.of(ticket, 0), type, value);
        parent.append(textNode);
    }
    else {
        const { children = [] } = treeNode;
        let { attributes } = treeNode;
        let attrs;
        if (typeof attributes === 'object' && !isEmpty(attributes)) {
            attributes = stringifyObjectValues(attributes);
            attrs = new RHT();
            for (const [key, value] of Object.entries(attributes)) {
                attrs.set(key, value, ticket);
            }
        }
        const elementNode = CRDTTreeNode.create(CRDTTreeNodeID.of(ticket, 0), type, undefined, attrs);
        parent.append(elementNode);
        for (const child of children) {
            buildDescendants(child, elementNode, context);
        }
    }
}
/**
 * createCRDTTreeNode returns CRDTTreeNode by given TreeNode.
 */
function createCRDTTreeNode(context, content) {
    const { type } = content;
    const ticket = context.issueTimeTicket();
    let root;
    if (content.type === DefaultTextType) {
        const { value } = content;
        root = CRDTTreeNode.create(CRDTTreeNodeID.of(ticket, 0), type, value);
    }
    else if (content) {
        const { children = [] } = content;
        let { attributes } = content;
        let attrs;
        if (typeof attributes === 'object' && !isEmpty(attributes)) {
            attributes = stringifyObjectValues(attributes);
            attrs = new RHT();
            for (const [key, value] of Object.entries(attributes)) {
                attrs.set(key, value, ticket);
            }
        }
        root = CRDTTreeNode.create(CRDTTreeNodeID.of(context.issueTimeTicket(), 0), type, undefined, attrs);
        for (const child of children) {
            buildDescendants(child, root, context);
        }
    }
    return root;
}
/**
 * `validateTextNode` ensures that a text node has a non-empty string value.
 */
function validateTextNode(textNode) {
    if (!textNode.value.length) {
        throw new Error('text node cannot have empty value');
    }
    return true;
}
/**
 * `validateTreeNodes` ensures that treeNodes consists of only one type.
 */
function validateTreeNodes(treeNodes) {
    if (!treeNodes.length) {
        return true;
    }
    const firstTreeNodeType = treeNodes[0].type;
    if (firstTreeNodeType === DefaultTextType) {
        for (const treeNode of treeNodes) {
            const { type } = treeNode;
            if (type !== DefaultTextType) {
                throw new Error('element node and text node cannot be passed together');
            }
            validateTextNode(treeNode);
        }
    }
    else {
        for (const treeNode of treeNodes) {
            const { type } = treeNode;
            if (type === DefaultTextType) {
                throw new Error('element node and text node cannot be passed together');
            }
        }
    }
    return true;
}
/**
 * `Tree` is a CRDT-based tree structure that is used to represent the document
 * tree of text-based editor such as ProseMirror.
 */
class Tree {
    constructor(initialRoot) {
        this.initialRoot = initialRoot;
    }
    /**
     * `initialize` initialize this tree with context and internal tree.
     * @internal
     */
    initialize(context, tree) {
        this.context = context;
        this.tree = tree;
    }
    /**
     * `getID` returns the ID of this tree.
     */
    getID() {
        return this.tree.getID();
    }
    /**
     * `buildRoot` builds the root of this tree with the given initial root
     * which set by the user.
     */
    buildRoot(context) {
        if (!this.initialRoot) {
            return CRDTTreeNode.create(CRDTTreeNodeID.of(context.issueTimeTicket(), 0), DefaultRootType);
        }
        // TODO(hackerwins): Need to use the ticket of operation of creating tree.
        const root = CRDTTreeNode.create(CRDTTreeNodeID.of(context.issueTimeTicket(), 0), this.initialRoot.type);
        for (const child of this.initialRoot.children) {
            buildDescendants(child, root, context);
        }
        return root;
    }
    /**
     * `getSize` returns the size of this tree.
     */
    getSize() {
        if (!this.context || !this.tree) {
            throw new Error('it is not initialized yet');
        }
        return this.tree.getSize();
    }
    /**
     * `getIndexTree` returns the index tree of this tree.
     */
    getIndexTree() {
        if (!this.context || !this.tree) {
            throw new Error('it is not initialized yet');
        }
        return this.tree.getIndexTree();
    }
    /**
     * `styleByPath` sets the attributes to the elements of the given path.
     */
    styleByPath(path, attributes) {
        if (!this.context || !this.tree) {
            throw new Error('it is not initialized yet');
        }
        if (!path.length) {
            throw new Error('path should not be empty');
        }
        const [fromPos, toPos] = this.tree.pathToPosRange(path);
        const ticket = this.context.issueTimeTicket();
        const attrs = attributes ? stringifyObjectValues(attributes) : undefined;
        this.tree.style([fromPos, toPos], attrs, ticket);
        this.context.push(TreeStyleOperation.create(this.tree.getCreatedAt(), fromPos, toPos, attrs ? new Map(Object.entries(attrs)) : new Map(), ticket));
    }
    /**
     * `style` sets the attributes to the elements of the given range.
     */
    style(fromIdx, toIdx, attributes) {
        if (!this.context || !this.tree) {
            throw new Error('it is not initialized yet');
        }
        if (fromIdx > toIdx) {
            throw new Error('from should be less than or equal to to');
        }
        const fromPos = this.tree.findPos(fromIdx);
        const toPos = this.tree.findPos(toIdx);
        const ticket = this.context.issueTimeTicket();
        const attrs = attributes ? stringifyObjectValues(attributes) : undefined;
        this.tree.style([fromPos, toPos], attrs, ticket);
        this.context.push(TreeStyleOperation.create(this.tree.getCreatedAt(), fromPos, toPos, attrs ? new Map(Object.entries(attrs)) : new Map(), ticket));
    }
    editInternal(fromPos, toPos, contents) {
        var _a;
        if (contents.length !== 0 && contents[0]) {
            validateTreeNodes(contents);
            if (contents[0].type !== DefaultTextType) {
                for (const content of contents) {
                    const { children = [] } = content;
                    validateTreeNodes(children);
                }
            }
        }
        const ticket = this.context.getLastTimeTicket();
        let crdtNodes = new Array();
        if (((_a = contents[0]) === null || _a === void 0 ? void 0 : _a.type) === DefaultTextType) {
            let compVal = '';
            for (const content of contents) {
                const { value } = content;
                compVal += value;
            }
            crdtNodes.push(CRDTTreeNode.create(CRDTTreeNodeID.of(this.context.issueTimeTicket(), 0), DefaultTextType, compVal));
        }
        else {
            crdtNodes = contents
                .map((content) => content && createCRDTTreeNode(this.context, content))
                .filter((a) => a);
        }
        // TODO(hackerwins): Implement splitLevels.
        const [, maxCreatedAtMapByActor] = this.tree.edit([fromPos, toPos], crdtNodes.length
            ? crdtNodes.map((crdtNode) => crdtNode === null || crdtNode === void 0 ? void 0 : crdtNode.deepcopy())
            : undefined, ticket);
        this.context.push(TreeEditOperation.create(this.tree.getCreatedAt(), fromPos, toPos, maxCreatedAtMapByActor, crdtNodes.length ? crdtNodes : undefined, ticket));
        if (!fromPos.equals(toPos)) {
            this.context.registerElementHasRemovedNodes(this.tree);
        }
        return true;
    }
    /**
     * `editByPath` edits this tree with the given node and path.
     */
    editByPath(fromPath, toPath, ...contents) {
        if (!this.context || !this.tree) {
            throw new Error('it is not initialized yet');
        }
        if (fromPath.length !== toPath.length) {
            throw new Error('path length should be equal');
        }
        if (!fromPath.length || !toPath.length) {
            throw new Error('path should not be empty');
        }
        const fromPos = this.tree.pathToPos(fromPath);
        const toPos = this.tree.pathToPos(toPath);
        return this.editInternal(fromPos, toPos, contents);
    }
    /**
     * `edit` edits this tree with the given nodes.
     */
    edit(fromIdx, toIdx, ...contents) {
        if (!this.context || !this.tree) {
            throw new Error('it is not initialized yet');
        }
        if (fromIdx > toIdx) {
            throw new Error('from should be less than or equal to to');
        }
        const fromPos = this.tree.findPos(fromIdx);
        const toPos = this.tree.findPos(toIdx);
        return this.editInternal(fromPos, toPos, contents);
    }
    /**
     * `toXML` returns the XML string of this tree.
     */
    toXML() {
        if (!this.context || !this.tree) {
            throw new Error('it is not initialized yet');
        }
        return this.tree.toXML();
    }
    /**
     * `toJSON` returns the JSON string of this tree.
     */
    toJSON() {
        if (!this.context || !this.tree) {
            throw new Error('it is not initialized yet');
        }
        return this.tree.toJSON();
    }
    /**
     * `getRootTreeNode` returns TreeNode of this tree.
     */
    getRootTreeNode() {
        if (!this.context || !this.tree) {
            throw new Error('it is not initialized yet');
        }
        return this.tree.getRootTreeNode();
    }
    /**
     * `indexToPath` returns the path of the given index.
     */
    indexToPath(index) {
        if (!this.context || !this.tree) {
            throw new Error('it is not initialized yet');
        }
        return this.tree.indexToPath(index);
    }
    /**
     * `pathToIndex` returns the index of given path.
     */
    pathToIndex(path) {
        if (!this.context || !this.tree) {
            throw new Error('it is not initialized yet');
        }
        return this.tree.pathToIndex(path);
    }
    /**
     * `pathRangeToPosRange` converts the path range into the position range.
     */
    pathRangeToPosRange(range) {
        if (!this.context || !this.tree) {
            logger.fatal('it is not initialized yet');
            // @ts-ignore
            return;
        }
        const indexRange = [
            this.tree.pathToIndex(range[0]),
            this.tree.pathToIndex(range[1]),
        ];
        const posRange = this.tree.indexRangeToPosRange(indexRange);
        return [posRange[0].toStruct(), posRange[1].toStruct()];
    }
    /**
     * `indexRangeToPosRange` converts the index range into the position range.
     */
    indexRangeToPosRange(range) {
        if (!this.context || !this.tree) {
            logger.fatal('it is not initialized yet');
            // @ts-ignore
            return;
        }
        return this.tree.indexRangeToPosStructRange(range);
    }
    /**
     * `posRangeToIndexRange` converts the position range into the index range.
     */
    posRangeToIndexRange(range) {
        if (!this.context || !this.tree) {
            logger.fatal('it is not initialized yet');
            // @ts-ignore
            return;
        }
        const posRange = [
            CRDTTreePos.fromStruct(range[0]),
            CRDTTreePos.fromStruct(range[1]),
        ];
        return this.tree.posRangeToIndexRange(posRange, this.context.getLastTimeTicket());
    }
    /**
     * `posRangeToPathRange` converts the position range into the path range.
     */
    posRangeToPathRange(range) {
        if (!this.context || !this.tree) {
            logger.fatal('it is not initialized yet');
            // @ts-ignore
            return;
        }
        const posRange = [
            CRDTTreePos.fromStruct(range[0]),
            CRDTTreePos.fromStruct(range[1]),
        ];
        return this.tree.posRangeToPathRange(posRange, this.context.getLastTimeTicket());
    }
}

;// CONCATENATED MODULE: ./src/document/json/element.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












/**
 * `createJSON` create a new instance of JSONObject.
 */
function createJSON(context, target) {
    return createJSONObject(context, target);
}
/**
 * `toWrappedElement` converts the CRDT type to `WrappedElement`.
 */
function toWrappedElement(context, elem) {
    if (!elem) {
        return;
    }
    else if (elem instanceof Primitive) {
        return elem;
    }
    else if (elem instanceof CRDTObject) {
        return createJSONObject(context, elem);
    }
    else if (elem instanceof CRDTArray) {
        return createJSONArray(context, elem);
    }
    else if (elem instanceof CRDTText) {
        return new Text(context, elem);
    }
    else if (elem instanceof CRDTCounter) {
        const counter = new Counter(CounterType.IntegerCnt, 0);
        counter.initialize(context, elem);
        return counter;
    }
    else if (elem instanceof CRDTTree) {
        const tree = new Tree();
        tree.initialize(context, elem);
        return tree;
    }
    throw new TypeError(`Unsupported type of element: ${typeof elem}`);
}
/**
 * `toJSONElement` converts the CRDT type to `JSONElement`.
 */
function toJSONElement(context, elem) {
    const wrappedElement = toWrappedElement(context, elem);
    if (wrappedElement instanceof Primitive) {
        return wrappedElement.getValue();
    }
    return wrappedElement;
}
/**
 * `buildCRDTElement` constructs a CRDTElement from the given value.
 */
function buildCRDTElement(context, value, createdAt) {
    let element;
    if (Primitive.isSupport(value)) {
        element = Primitive.of(value, createdAt);
    }
    else if (Array.isArray(value)) {
        element = CRDTArray.create(createdAt, ArrayProxy.buildArrayElements(context, value));
    }
    else if (typeof value === 'object') {
        if (value instanceof Text) {
            element = CRDTText.create(RGATreeSplit.create(), createdAt);
            value.initialize(context, element);
        }
        else if (value instanceof Counter) {
            element = CRDTCounter.create(value.getValueType(), value.getValue(), createdAt);
            value.initialize(context, element);
        }
        else if (value instanceof Tree) {
            element = CRDTTree.create(value.buildRoot(context), createdAt);
            value.initialize(context, element);
        }
        else {
            element = CRDTObject.create(createdAt, ObjectProxy.buildObjectMembers(context, value));
        }
    }
    else {
        throw new TypeError(`Unsupported type of value: ${typeof value}`);
    }
    return element;
}

;// CONCATENATED MODULE: ./src/document/history.ts
/**
 * `MaxUndoRedoStackDepth` is the maximum depth of undo/redo stack.
 */
const MaxUndoRedoStackDepth = 50;
/**
 * `History` is a class that stores the history of the document.
 */
class History {
    constructor() {
        this.undoStack = [];
        this.redoStack = [];
    }
    /**
     * `hasUndo` returns true if there are undo operations.
     */
    hasUndo() {
        return this.undoStack.length > 0;
    }
    /**
     * `hasRedo` returns true if there are redo operations.
     */
    hasRedo() {
        return this.redoStack.length > 0;
    }
    /**
     * `pushUndo` pushes new undo operations of a change to undo stack.
     */
    pushUndo(undoOps) {
        if (this.undoStack.length >= MaxUndoRedoStackDepth) {
            this.undoStack.shift();
        }
        this.undoStack.push(undoOps);
    }
    /**
     * `popUndo` pops the last undo operations of a change from undo stack.
     */
    popUndo() {
        return this.undoStack.pop();
    }
    /**
     * `pushRedo` pushes new redo operations of a change to redo stack.
     */
    pushRedo(redoOps) {
        if (this.redoStack.length >= MaxUndoRedoStackDepth) {
            this.redoStack.shift();
        }
        this.redoStack.push(redoOps);
    }
    /**
     * `popRedo` pops the last redo operations of a change from redo stack.
     */
    popRedo() {
        return this.redoStack.pop();
    }
    /**
     * `clearRedo` flushes remaining redo operations.
     */
    clearRedo() {
        this.redoStack = [];
    }
    /**
     * `getUndoStackForTest` returns the undo stack for test.
     */
    getUndoStackForTest() {
        return this.undoStack;
    }
    /**
     * `getRedoStackForTest` returns the redo stack for test.
     */
    getRedoStackForTest() {
        return this.redoStack;
    }
}

;// CONCATENATED MODULE: ./src/document/document.ts














/**
 * `DocumentStatus` represents the status of the document.
 * @public
 */
var DocumentStatus;
(function (DocumentStatus) {
    /**
     * Detached means that the document is not attached to the client.
     * The actor of the ticket is created without being assigned.
     */
    DocumentStatus["Detached"] = "detached";
    /**
     * Attached means that this document is attached to the client.
     * The actor of the ticket is created with being assigned by the client.
     */
    DocumentStatus["Attached"] = "attached";
    /**
     * Removed means that this document is removed. If the document is removed,
     * it cannot be edited.
     */
    DocumentStatus["Removed"] = "removed";
})(DocumentStatus || (DocumentStatus = {}));
/**
 * `DocEventType` represents the type of the event that occurs in `Document`.
 * @public
 */
var DocEventType;
(function (DocEventType) {
    /**
     * snapshot event type
     */
    DocEventType["Snapshot"] = "snapshot";
    /**
     * local document change event type
     */
    DocEventType["LocalChange"] = "local-change";
    /**
     * remote document change event type
     */
    DocEventType["RemoteChange"] = "remote-change";
    /**
     * `Initialized` means that online clients have been loaded from the server.
     */
    DocEventType["Initialized"] = "initialized";
    /**
     * `Watched` means that the client has established a connection with the server,
     * enabling real-time synchronization.
     */
    DocEventType["Watched"] = "watched";
    /**
     * `Unwatched` means that the connection has been disconnected.
     */
    DocEventType["Unwatched"] = "unwatched";
    /**
     * `PresenceChanged` means that the presences of the client has updated.
     */
    DocEventType["PresenceChanged"] = "presence-changed";
})(DocEventType || (DocEventType = {}));
/**
 * `Document` is a CRDT-based data type. We can represent the model
 * of the application and edit it even while offline.
 *
 * @public
 */
class Document {
    constructor(key, opts) {
        this.opts = opts || {};
        this.key = key;
        this.status = DocumentStatus.Detached;
        this.root = CRDTRoot.create();
        this.changeID = InitialChangeID;
        this.checkpoint = InitialCheckpoint;
        this.localChanges = [];
        this.eventStream = createObservable((observer) => {
            this.eventStreamObserver = observer;
        });
        this.onlineClients = new Set();
        this.presences = new Map();
        this.isUpdating = false;
        this.internalHistory = new History();
        this.history = {
            canUndo: this.canUndo.bind(this),
            canRedo: this.canRedo.bind(this),
            undo: this.undo.bind(this),
            redo: this.redo.bind(this),
        };
    }
    /**
     * `update` executes the given updater to update this document.
     */
    update(updater, message) {
        if (this.getStatus() === DocumentStatus.Removed) {
            throw new YorkieError(Code.DocumentRemoved, `${this.key} is removed`);
        }
        // 01. Update the clone object and create a change.
        this.ensureClone();
        const actorID = this.changeID.getActorID();
        const context = ChangeContext.create(this.changeID.next(), this.clone.root, this.clone.presences.get(actorID) || {}, message);
        try {
            const proxy = createJSON(context, this.clone.root.getObject());
            if (!this.presences.has(actorID)) {
                this.clone.presences.set(actorID, {});
            }
            // NOTE(hackerwins): The updater should not be able to call undo/redo.
            // If the updater calls undo/redo, an error will be thrown.
            this.isUpdating = true;
            updater(proxy, new Presence(context, this.clone.presences.get(actorID)));
        }
        catch (err) {
            // drop clone because it is contaminated.
            this.clone = undefined;
            logger.error(err);
            throw err;
        }
        finally {
            this.isUpdating = false;
        }
        // 02. Update the root object and presences from changes.
        if (context.hasChange()) {
            if (logger.isEnabled(LogLevel.Trivial)) {
                logger.trivial(`trying to update a local change: ${this.toJSON()}`);
            }
            const change = context.getChange();
            const { opInfos, reverseOps } = change.execute(this.root, this.presences, OpSource.Local);
            const reversePresence = context.getReversePresence();
            if (reversePresence) {
                reverseOps.push({
                    type: 'presence',
                    value: reversePresence,
                });
            }
            this.localChanges.push(change);
            if (reverseOps.length > 0) {
                this.internalHistory.pushUndo(reverseOps);
            }
            // NOTE(chacha912): Clear redo when a new local operation is applied.
            if (opInfos.length > 0) {
                this.internalHistory.clearRedo();
            }
            this.changeID = change.getID();
            // 03. Publish the document change event.
            // NOTE(chacha912): Check opInfos, which represent the actually executed operations.
            if (opInfos.length > 0) {
                this.publish({
                    type: DocEventType.LocalChange,
                    value: {
                        message: change.getMessage() || '',
                        operations: opInfos,
                        actor: actorID,
                    },
                });
            }
            if (change.hasPresenceChange()) {
                this.publish({
                    type: DocEventType.PresenceChanged,
                    value: {
                        clientID: actorID,
                        presence: this.getPresence(actorID),
                    },
                });
            }
            if (logger.isEnabled(LogLevel.Trivial)) {
                logger.trivial(`after update a local change: ${this.toJSON()}`);
            }
        }
    }
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     */
    subscribe(arg1, arg2, arg3, arg4) {
        if (typeof arg1 === 'string') {
            if (typeof arg2 !== 'function') {
                throw new Error('Second argument must be a callback function');
            }
            if (arg1 === 'presence') {
                const callback = arg2;
                return this.eventStream.subscribe((event) => {
                    if (event.type !== DocEventType.Initialized &&
                        event.type !== DocEventType.Watched &&
                        event.type !== DocEventType.Unwatched &&
                        event.type !== DocEventType.PresenceChanged) {
                        return;
                    }
                    callback(event);
                }, arg3, arg4);
            }
            if (arg1 === 'my-presence') {
                const callback = arg2;
                return this.eventStream.subscribe((event) => {
                    if (event.type !== DocEventType.Initialized &&
                        event.type !== DocEventType.Watched &&
                        event.type !== DocEventType.Unwatched &&
                        event.type !== DocEventType.PresenceChanged) {
                        return;
                    }
                    if (event.type !== DocEventType.Initialized &&
                        event.value.clientID !== this.changeID.getActorID()) {
                        return;
                    }
                    callback(event);
                }, arg3, arg4);
            }
            if (arg1 === 'others') {
                const callback = arg2;
                return this.eventStream.subscribe((event) => {
                    if (event.type !== DocEventType.Watched &&
                        event.type !== DocEventType.Unwatched &&
                        event.type !== DocEventType.PresenceChanged) {
                        return;
                    }
                    if (event.value.clientID !== this.changeID.getActorID()) {
                        callback(event);
                    }
                }, arg3, arg4);
            }
            const target = arg1;
            const callback = arg2;
            return this.eventStream.subscribe((event) => {
                if (event.type === DocEventType.Initialized ||
                    event.type === DocEventType.Watched ||
                    event.type === DocEventType.Unwatched ||
                    event.type === DocEventType.PresenceChanged) {
                    return;
                }
                if (event.type === DocEventType.Snapshot) {
                    target === '$' && callback(event);
                    return;
                }
                const { message, operations, actor } = event.value;
                const targetOps = [];
                for (const op of operations) {
                    if (this.isSameElementOrChildOf(op.path, target)) {
                        targetOps.push(op);
                    }
                }
                targetOps.length &&
                    callback({
                        type: event.type,
                        value: {
                            message,
                            operations: targetOps,
                            actor,
                        },
                    });
            }, arg3, arg4);
        }
        if (typeof arg1 === 'function') {
            const callback = arg1;
            const error = arg2;
            const complete = arg3;
            return this.eventStream.subscribe((event) => {
                if (event.type === DocEventType.Initialized ||
                    event.type === DocEventType.Watched ||
                    event.type === DocEventType.Unwatched ||
                    event.type === DocEventType.PresenceChanged) {
                    return;
                }
                callback(event);
            }, error, complete);
        }
        throw new Error(`"${arg1}" is not a valid`);
    }
    /**
     * `publish` triggers an event in this document, which can be received by
     * callback functions from document.subscribe().
     */
    publish(event) {
        if (this.eventStreamObserver) {
            this.eventStreamObserver.next(event);
        }
    }
    isSameElementOrChildOf(elem, parent) {
        if (parent === elem) {
            return true;
        }
        const nodePath = elem.split('.');
        const targetPath = parent.split('.');
        return targetPath.every((path, index) => path === nodePath[index]);
    }
    /**
     * `applyChangePack` applies the given change pack into this document.
     * 1. Remove local changes applied to server.
     * 2. Update the checkpoint.
     * 3. Do Garbage collection.
     *
     * @param pack - change pack
     * @internal
     */
    applyChangePack(pack) {
        if (pack.hasSnapshot()) {
            this.applySnapshot(pack.getCheckpoint().getServerSeq(), pack.getSnapshot());
        }
        else if (pack.hasChanges()) {
            this.applyChanges(pack.getChanges());
        }
        // 02. Remove local changes applied to server.
        while (this.localChanges.length) {
            const change = this.localChanges[0];
            if (change.getID().getClientSeq() > pack.getCheckpoint().getClientSeq()) {
                break;
            }
            this.localChanges.shift();
        }
        // 03. Update the checkpoint.
        this.checkpoint = this.checkpoint.forward(pack.getCheckpoint());
        // 04. Do Garbage collection.
        this.garbageCollect(pack.getMinSyncedTicket());
        // 05. Update the status.
        if (pack.getIsRemoved()) {
            this.setStatus(DocumentStatus.Removed);
        }
        if (logger.isEnabled(LogLevel.Trivial)) {
            logger.trivial(`${this.root.toJSON()}`);
        }
    }
    /**
     * `getCheckpoint` returns the checkpoint of this document.
     *
     * @internal
     */
    getCheckpoint() {
        return this.checkpoint;
    }
    /**
     * `getChangeID` returns the change id of this document.
     *
     * @internal
     */
    getChangeID() {
        return this.changeID;
    }
    /**
     * `hasLocalChanges` returns whether this document has local changes or not.
     *
     * @internal
     */
    hasLocalChanges() {
        return this.localChanges.length > 0;
    }
    /**
     * `ensureClone` make a clone of root.
     *
     * @internal
     */
    ensureClone() {
        if (this.clone) {
            return;
        }
        this.clone = {
            root: this.root.deepcopy(),
            presences: deepcopy(this.presences),
        };
    }
    /**
     * `createChangePack` create change pack of the local changes to send to the
     * remote server.
     *
     * @internal
     */
    createChangePack() {
        const changes = Array.from(this.localChanges);
        const checkpoint = this.checkpoint.increaseClientSeq(changes.length);
        return ChangePack.create(this.key, checkpoint, false, changes);
    }
    /**
     * `setActor` sets actor into this document. This is also applied in the local
     * changes the document has.
     *
     * @internal
     */
    setActor(actorID) {
        for (const change of this.localChanges) {
            change.setActor(actorID);
        }
        this.changeID = this.changeID.setActor(actorID);
        // TODO also apply into root.
    }
    /**
     * `getKey` returns the key of this document.
     *
     * @internal
     */
    getKey() {
        return this.key;
    }
    /**
     * `setStatus` updates the status of this document.
     *
     * @internal
     */
    setStatus(status) {
        this.status = status;
    }
    /**
     * `getStatus` returns the status of this document.
     *
     * @internal
     */
    getStatus() {
        return this.status;
    }
    /**
     * `getClone` return clone object.
     *
     * @internal
     */
    getCloneRoot() {
        if (!this.clone) {
            return;
        }
        return this.clone.root.getObject();
    }
    /**
     * `getRoot` returns a new proxy of cloned root.
     */
    getRoot() {
        this.ensureClone();
        const context = ChangeContext.create(this.changeID.next(), this.clone.root, this.clone.presences.get(this.changeID.getActorID()) || {});
        return createJSON(context, this.clone.root.getObject());
    }
    /**
     * `getOpsForTest` returns the operations of this document for testing.
     */
    getOpsForTest() {
        return this.root.opsForTest;
    }
    /**
     * `garbageCollect` purges elements that were removed before the given time.
     *
     * @internal
     */
    garbageCollect(ticket) {
        if (this.opts.disableGC) {
            return 0;
        }
        if (this.clone) {
            this.clone.root.garbageCollect(ticket);
        }
        return this.root.garbageCollect(ticket);
    }
    /**
     * `getRootObject` returns root object.
     *
     * @internal
     */
    getRootObject() {
        return this.root.getObject();
    }
    /**
     * `getGarbageLen` returns the length of elements should be purged.
     *
     * @internal
     */
    getGarbageLen() {
        return this.root.getGarbageLen();
    }
    /**
     * `getGarbageLenFromClone` returns the length of elements should be purged from clone.
     */
    getGarbageLenFromClone() {
        return this.clone.root.getGarbageLen();
    }
    /**
     * `toJSON` returns the JSON encoding of this document.
     */
    toJSON() {
        return this.root.toJSON();
    }
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this document.
     */
    toSortedJSON() {
        return this.root.toSortedJSON();
    }
    /**
     * `applySnapshot` applies the given snapshot into this document.
     */
    applySnapshot(serverSeq, snapshot) {
        const { root, presences } = converter.bytesToSnapshot(snapshot);
        this.root = new CRDTRoot(root);
        this.presences = presences;
        this.changeID = this.changeID.syncLamport(serverSeq);
        // drop clone because it is contaminated.
        this.clone = undefined;
        this.publish({
            type: DocEventType.Snapshot,
            value: snapshot,
        });
    }
    /**
     * `applyChanges` applies the given changes into this document.
     */
    applyChanges(changes) {
        if (logger.isEnabled(LogLevel.Debug)) {
            logger.debug(`trying to apply ${changes.length} remote changes.` +
                `elements:${this.root.getElementMapSize()}, ` +
                `removeds:${this.root.getRemovedElementSetSize()}`);
        }
        if (logger.isEnabled(LogLevel.Trivial)) {
            logger.trivial(changes
                .map((change) => `${change.getID().toTestString()}\t${change.toTestString()}`)
                .join('\n'));
        }
        this.ensureClone();
        for (const change of changes) {
            change.execute(this.clone.root, this.clone.presences, OpSource.Remote);
            let presenceEvent;
            const actorID = change.getID().getActorID();
            if (change.hasPresenceChange() && this.onlineClients.has(actorID)) {
                const presenceChange = change.getPresenceChange();
                switch (presenceChange.type) {
                    case PresenceChangeType.Put:
                        // NOTE(chacha912): When the user exists in onlineClients, but
                        // their presence was initially absent, we can consider that we have
                        // received their initial presence, so trigger the 'watched' event.
                        presenceEvent = {
                            type: this.presences.has(actorID)
                                ? DocEventType.PresenceChanged
                                : DocEventType.Watched,
                            value: {
                                clientID: actorID,
                                presence: presenceChange.presence,
                            },
                        };
                        break;
                    case PresenceChangeType.Clear:
                        // NOTE(chacha912): When the user exists in onlineClients, but
                        // PresenceChange(clear) is received, we can consider it as detachment
                        // occurring before unwatching.
                        // Detached user is no longer participating in the document, we remove
                        // them from the online clients and trigger the 'unwatched' event.
                        presenceEvent = {
                            type: DocEventType.Unwatched,
                            value: {
                                clientID: actorID,
                                presence: this.getPresence(actorID),
                            },
                        };
                        this.removeOnlineClient(actorID);
                        break;
                    default:
                        break;
                }
            }
            const { opInfos } = change.execute(this.root, this.presences, OpSource.Remote);
            // DocEvent should be emitted synchronously with applying changes.
            // This is because 3rd party model should be synced with the Document
            // after RemoteChange event is emitted. If the event is emitted
            // asynchronously, the model can be changed and breaking consistency.
            if (opInfos.length > 0) {
                this.publish({
                    type: DocEventType.RemoteChange,
                    value: {
                        actor: actorID,
                        message: change.getMessage() || '',
                        operations: opInfos,
                    },
                });
            }
            if (presenceEvent) {
                this.publish(presenceEvent);
            }
            this.changeID = this.changeID.syncLamport(change.getID().getLamport());
        }
        if (logger.isEnabled(LogLevel.Debug)) {
            logger.debug(`after appling ${changes.length} remote changes.` +
                `elements:${this.root.getElementMapSize()}, ` +
                ` removeds:${this.root.getRemovedElementSetSize()}`);
        }
    }
    /**
     * `getValueByPath` returns the JSONElement corresponding to the given path.
     */
    getValueByPath(path) {
        if (!path.startsWith('$')) {
            throw new YorkieError(Code.InvalidArgument, `path must start with "$"`);
        }
        const pathArr = path.split('.');
        pathArr.shift();
        let value = this.getRoot();
        for (const key of pathArr) {
            value = value[key];
            if (value === undefined)
                return undefined;
        }
        return value;
    }
    /**
     * `setOnlineClients` sets the given online client set.
     *
     * @internal
     */
    setOnlineClients(onlineClients) {
        this.onlineClients = onlineClients;
    }
    /**
     * `addOnlineClient` adds the given clientID into the online client set.
     *
     * @internal
     */
    addOnlineClient(clientID) {
        this.onlineClients.add(clientID);
    }
    /**
     * `removeOnlineClient` removes the clientID from the online client set.
     *
     * @internal
     */
    removeOnlineClient(clientID) {
        this.onlineClients.delete(clientID);
    }
    /**
     * `hasPresence` returns whether the given clientID has a presence or not.
     *
     * @internal
     */
    hasPresence(clientID) {
        return this.presences.has(clientID);
    }
    /**
     * `getMyPresence` returns the presence of the current client.
     */
    getMyPresence() {
        if (this.status !== DocumentStatus.Attached) {
            return {};
        }
        const p = this.presences.get(this.changeID.getActorID());
        return deepcopy(p);
    }
    /**
     * `getPresence` returns the presence of the given clientID.
     */
    getPresence(clientID) {
        if (!this.onlineClients.has(clientID))
            return;
        const p = this.presences.get(clientID);
        return p ? deepcopy(p) : undefined;
    }
    /**
     * `getPresenceForTest` returns the presence of the given clientID
     * regardless of whether the client is online or not.
     *
     * @internal
     */
    getPresenceForTest(clientID) {
        const p = this.presences.get(clientID);
        return p ? deepcopy(p) : undefined;
    }
    /**
     * `getPresences` returns the presences of online clients.
     */
    getPresences() {
        const presences = [];
        for (const clientID of this.onlineClients) {
            if (this.presences.has(clientID)) {
                presences.push({
                    clientID,
                    presence: deepcopy(this.presences.get(clientID)),
                });
            }
        }
        return presences;
    }
    /**
     * `canUndo` returns whether there are any operations to undo.
     */
    canUndo() {
        return this.internalHistory.hasUndo() && !this.isUpdating;
    }
    /**
     * `canRedo` returns whether there are any operations to redo.
     */
    canRedo() {
        return this.internalHistory.hasRedo() && !this.isUpdating;
    }
    /**
     * `undo` undoes the last operation executed by the current client.
     * It does not impact operations made by other clients.
     */
    undo() {
        if (this.isUpdating) {
            throw new Error('Undo is not allowed during an update');
        }
        const undoOps = this.internalHistory.popUndo();
        if (undoOps === undefined) {
            throw new Error('There is no operation to be undone');
        }
        this.ensureClone();
        // TODO(chacha912): After resolving the presence initialization issue,
        // remove default presence.(#608)
        const context = ChangeContext.create(this.changeID.next(), this.clone.root, this.clone.presences.get(this.changeID.getActorID()) || {});
        // apply undo operation in the context to generate a change
        for (const undoOp of undoOps) {
            if (!(undoOp instanceof Operation)) {
                // apply presence change to the context
                const presence = new Presence(context, deepcopy(this.clone.presences.get(this.changeID.getActorID())));
                presence.set(undoOp.value, { addToHistory: true });
                continue;
            }
            const ticket = context.issueTimeTicket();
            undoOp.setExecutedAt(ticket);
            context.push(undoOp);
        }
        const change = context.getChange();
        change.execute(this.clone.root, this.clone.presences, OpSource.UndoRedo);
        const { opInfos, reverseOps } = change.execute(this.root, this.presences, OpSource.UndoRedo);
        const reversePresence = context.getReversePresence();
        if (reversePresence) {
            reverseOps.push({
                type: 'presence',
                value: reversePresence,
            });
        }
        if (reverseOps.length > 0) {
            this.internalHistory.pushRedo(reverseOps);
        }
        // NOTE(chacha912): When there is no applied operation or presence
        // during undo/redo, skip propagating change remotely.
        if (!change.hasPresenceChange() && opInfos.length === 0) {
            return;
        }
        this.localChanges.push(change);
        this.changeID = change.getID();
        const actorID = this.changeID.getActorID();
        if (opInfos.length > 0) {
            this.publish({
                type: DocEventType.LocalChange,
                value: {
                    message: change.getMessage() || '',
                    operations: opInfos,
                    actor: actorID,
                },
            });
        }
        if (change.hasPresenceChange()) {
            this.publish({
                type: DocEventType.PresenceChanged,
                value: {
                    clientID: actorID,
                    presence: this.getPresence(actorID),
                },
            });
        }
    }
    /**
     * `redo` redoes the last operation executed by the current client.
     * It does not impact operations made by other clients.
     */
    redo() {
        if (this.isUpdating) {
            throw new Error('Redo is not allowed during an update');
        }
        const redoOps = this.internalHistory.popRedo();
        if (redoOps === undefined) {
            throw new Error('There is no operation to be redone');
        }
        this.ensureClone();
        const context = ChangeContext.create(this.changeID.next(), this.clone.root, this.clone.presences.get(this.changeID.getActorID()) || {});
        // apply redo operation in the context to generate a change
        for (const redoOp of redoOps) {
            if (!(redoOp instanceof Operation)) {
                // apply presence change to the context
                const presence = new Presence(context, deepcopy(this.clone.presences.get(this.changeID.getActorID())));
                presence.set(redoOp.value, { addToHistory: true });
                continue;
            }
            const ticket = context.issueTimeTicket();
            redoOp.setExecutedAt(ticket);
            context.push(redoOp);
        }
        const change = context.getChange();
        change.execute(this.clone.root, this.clone.presences, OpSource.UndoRedo);
        const { opInfos, reverseOps } = change.execute(this.root, this.presences, OpSource.UndoRedo);
        const reversePresence = context.getReversePresence();
        if (reversePresence) {
            reverseOps.push({
                type: 'presence',
                value: reversePresence,
            });
        }
        if (reverseOps.length > 0) {
            this.internalHistory.pushUndo(reverseOps);
        }
        // NOTE(chacha912): When there is no applied operation or presence
        // during undo/redo, skip propagating change remotely.
        if (!change.hasPresenceChange() && opInfos.length === 0) {
            return;
        }
        this.localChanges.push(change);
        this.changeID = change.getID();
        const actorID = this.changeID.getActorID();
        if (opInfos.length > 0) {
            this.publish({
                type: DocEventType.LocalChange,
                value: {
                    message: change.getMessage() || '',
                    operations: opInfos,
                    actor: actorID,
                },
            });
        }
        if (change.hasPresenceChange()) {
            this.publish({
                type: DocEventType.PresenceChanged,
                value: {
                    clientID: actorID,
                    presence: this.getPresence(actorID),
                },
            });
        }
    }
    /**
     * `getUndoStackForTest` returns the undo stack for test.
     */
    getUndoStackForTest() {
        return this.internalHistory.getUndoStackForTest();
    }
    /**
     * `getRedoStackForTest` returns the redo stack for test.
     */
    getRedoStackForTest() {
        return this.internalHistory.getRedoStackForTest();
    }
}

;// CONCATENATED MODULE: ./src/client/auth_interceptor.ts
/*
 * Copyright 2021 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * `AuthUnaryInterceptor` is a unary interceptor to add the Authorization header for each
 * request.
 */
class AuthUnaryInterceptor {
    constructor(apiKey, token) {
        this.apiKey = apiKey;
        this.token = token;
    }
    /**
     * `intercept` intercepts the request and adds the token to the metadata.
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    intercept(request, invoker) {
        const metadata = request.getMetadata();
        if (this.apiKey) {
            metadata['x-api-key'] = this.apiKey;
        }
        if (this.token) {
            metadata['authorization'] = this.token;
        }
        return invoker(request);
    }
}
/**
 * `AuthStreamInterceptor` is a stream interceptor to add the Authorization header for each
 * request.
 */
class AuthStreamInterceptor {
    constructor(apiKey, token) {
        this.apiKey = apiKey;
        this.token = token;
    }
    /**
     * `intercept` intercepts the request and adds the token to the metadata.
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    intercept(request, invoker) {
        const metadata = request.getMetadata();
        if (this.apiKey) {
            metadata['x-api-key'] = this.apiKey;
        }
        if (this.token) {
            metadata['authorization'] = this.token;
        }
        return invoker(request);
    }
}

;// CONCATENATED MODULE: ./package.json
const package_namespaceObject = JSON.parse('{"u2":"yorkie-js-sdk","i8":"0.4.9"}');
;// CONCATENATED MODULE: ./src/client/metric_interceptor.ts
/*
 * Copyright 2021 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * `MetricUnaryInterceptor` is a unary interceptor to add the yorkie user agent header
 * for each request.
 */
class MetricUnaryInterceptor {
    /**
     * `intercept` intercepts the request and adds the token to the metadata.
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    intercept(request, invoker) {
        const metadata = request.getMetadata();
        metadata['x-yorkie-user-agent'] = package_namespaceObject.u2 + '/' + package_namespaceObject.i8;
        return invoker(request);
    }
}
/**
 * `MetricStreamInterceptor` is a stream interceptor to add the yorkie user agent header
 * for each request.
 */
class MetricStreamInterceptor {
    /**
     * `intercept` intercepts the request and adds the token to the metadata.
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    intercept(request, invoker) {
        const metadata = request.getMetadata();
        metadata['x-yorkie-user-agent'] = package_namespaceObject.u2 + '/' + package_namespaceObject.i8;
        return invoker(request);
    }
}

;// CONCATENATED MODULE: ./src/client/client.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */













/**
 * `SyncMode` is the mode of synchronization. It is used to determine
 * whether to push and pull changes in PushPullChanges API.
 * @public
 */
var SyncMode;
(function (SyncMode) {
    /**
     * `PushPull` is the mode that pushes and pulls changes.
     */
    SyncMode["PushPull"] = "pushpull";
    /**
     * `PushOnly` is the mode that pushes changes only.
     */
    SyncMode["PushOnly"] = "pushonly";
})(SyncMode || (SyncMode = {}));
/**
 * `ClientStatus` represents the status of the client.
 * @public
 */
var ClientStatus;
(function (ClientStatus) {
    /**
     * `Deactivated` means that the client is not activated. It is the initial
     * status of the client. If the client is deactivated, all `Document`s of the
     * client are also not used.
     */
    ClientStatus["Deactivated"] = "deactivated";
    /**
     * `Activated` means that the client is activated. If the client is activated,
     * all `Document`s of the client are also ready to be used.
     */
    ClientStatus["Activated"] = "activated";
})(ClientStatus || (ClientStatus = {}));
/**
 * `StreamConnectionStatus` represents whether the stream connection between the
 * client and the server is connected or not.
 * @public
 */
var StreamConnectionStatus;
(function (StreamConnectionStatus) {
    /**
     * `Connected` means that the stream connection is connected.
     */
    StreamConnectionStatus["Connected"] = "connected";
    /**
     * `Disconnected` means that the stream connection is disconnected.
     */
    StreamConnectionStatus["Disconnected"] = "disconnected";
})(StreamConnectionStatus || (StreamConnectionStatus = {}));
/**
 * `DocumentSyncResultType` represents the result of synchronizing the document
 *  with the server.
 * @public
 */
var DocumentSyncResultType;
(function (DocumentSyncResultType) {
    /**
     * type when Document synced successfully.
     */
    DocumentSyncResultType["Synced"] = "synced";
    /**
     * type when Document sync failed.
     */
    DocumentSyncResultType["SyncFailed"] = "sync-failed";
})(DocumentSyncResultType || (DocumentSyncResultType = {}));
/**
 * `ClientEventType` represents the type of the event that the client can emit.
 * @public
 */
var ClientEventType;
(function (ClientEventType) {
    /**
     * `StatusChanged` means that the status of the client has changed.
     */
    ClientEventType["StatusChanged"] = "status-changed";
    /**
     * `DocumentChanged` means that the document has changed.
     */
    ClientEventType["DocumentChanged"] = "document-changed";
    /**
     * `StreamConnectionStatusChanged` means that the stream connection status of
     * the client has changed.
     */
    ClientEventType["StreamConnectionStatusChanged"] = "stream-connection-status-changed";
    /**
     * `DocumentSynced` means that the document has been synced with the server.
     */
    ClientEventType["DocumentSynced"] = "document-synced";
})(ClientEventType || (ClientEventType = {}));
/**
 * `DefaultClientOptions` is the default options for Client.
 */
const DefaultClientOptions = {
    syncLoopDuration: 50,
    retrySyncLoopDelay: 1000,
    reconnectStreamDelay: 1000,
};
/**
 * `Client` is a normal client that can communicate with the server.
 * It has documents and sends changes of the documents in local
 * to the server to synchronize with other replicas in remote.
 *
 * @public
 */
class Client {
    /**
     * @param rpcAddr - the address of the RPC server.
     * @param opts - the options of the client.
     */
    constructor(rpcAddr, opts) {
        opts = opts || DefaultClientOptions;
        this.key = opts.key ? opts.key : uuid();
        this.status = ClientStatus.Deactivated;
        this.attachmentMap = new Map();
        // TODO(hackerwins): Consider to group the options as a single object.
        this.apiKey = opts.apiKey || '';
        this.syncLoopDuration =
            opts.syncLoopDuration || DefaultClientOptions.syncLoopDuration;
        this.reconnectStreamDelay =
            opts.reconnectStreamDelay || DefaultClientOptions.reconnectStreamDelay;
        this.retrySyncLoopDelay =
            opts.retrySyncLoopDelay || DefaultClientOptions.retrySyncLoopDelay;
        const rpcOpts = {
            unaryInterceptors: [new MetricUnaryInterceptor()],
            streamInterceptors: [new MetricStreamInterceptor()],
        };
        if (opts.apiKey || opts.token) {
            rpcOpts.unaryInterceptors.push(new AuthUnaryInterceptor(opts.apiKey, opts.token));
            rpcOpts.streamInterceptors.push(new AuthStreamInterceptor(opts.apiKey, opts.token));
        }
        this.rpcClient = new yorkie_grpc_web_pb.YorkieServiceClient(rpcAddr, null, rpcOpts);
        this.eventStream = createObservable((observer) => {
            this.eventStreamObserver = observer;
        });
    }
    /**
     * `activate` activates this client. That is, it registers itself to the server
     * and receives a unique ID from the server. The given ID is used to
     * distinguish different clients.
     */
    activate() {
        if (this.isActive()) {
            return Promise.resolve();
        }
        return new Promise((resolve, reject) => {
            const req = new yorkie_pb.ActivateClientRequest();
            req.setClientKey(this.key);
            this.rpcClient.activateClient(req, { 'x-shard-key': this.apiKey }, async (err, res) => {
                if (err) {
                    logger.error(`[AC] c:"${this.getKey()}" err :`, err);
                    reject(err);
                    return;
                }
                this.id = res.getClientId();
                this.status = ClientStatus.Activated;
                this.runSyncLoop();
                this.eventStreamObserver.next({
                    type: ClientEventType.StatusChanged,
                    value: this.status,
                });
                logger.info(`[AC] c:"${this.getKey()}" activated, id:"${this.id}"`);
                resolve();
            });
        });
    }
    /**
     * `deactivate` deactivates this client.
     */
    deactivate() {
        if (this.status === ClientStatus.Deactivated) {
            return Promise.resolve();
        }
        for (const [key] of this.attachmentMap) {
            this.detachInternal(key);
        }
        return new Promise((resolve, reject) => {
            const req = new yorkie_pb.DeactivateClientRequest();
            req.setClientId(this.id);
            this.rpcClient.deactivateClient(req, { 'x-shard-key': this.apiKey }, (err) => {
                if (err) {
                    logger.error(`[DC] c:"${this.getKey()}" err :`, err);
                    reject(err);
                    return;
                }
                this.status = ClientStatus.Deactivated;
                this.eventStreamObserver.next({
                    type: ClientEventType.StatusChanged,
                    value: this.status,
                });
                logger.info(`[DC] c"${this.getKey()}" deactivated`);
                resolve();
            });
        });
    }
    /**
     * `attach` attaches the given document to this client. It tells the server that
     * this client will synchronize the given document.
     */
    attach(doc, options = {}) {
        var _a;
        if (!this.isActive()) {
            throw new YorkieError(Code.ClientNotActive, `${this.key} is not active`);
        }
        if (doc.getStatus() !== DocumentStatus.Detached) {
            throw new YorkieError(Code.DocumentNotDetached, `${doc.getKey()} is not detached`);
        }
        doc.setActor(this.id);
        doc.update((_, p) => p.set(options.initialPresence || {}));
        const isRealtimeSync = (_a = options.isRealtimeSync) !== null && _a !== void 0 ? _a : true;
        return new Promise((resolve, reject) => {
            const req = new yorkie_pb.AttachDocumentRequest();
            req.setClientId(this.id);
            req.setChangePack(converter.toChangePack(doc.createChangePack()));
            this.rpcClient.attachDocument(req, { 'x-shard-key': `${this.apiKey}/${doc.getKey()}` }, async (err, res) => {
                if (err) {
                    logger.error(`[AD] c:"${this.getKey()}" err :`, err);
                    reject(err);
                    return;
                }
                const pack = converter.fromChangePack(res.getChangePack());
                doc.applyChangePack(pack);
                if (doc.getStatus() !== DocumentStatus.Removed) {
                    doc.setStatus(DocumentStatus.Attached);
                    this.attachmentMap.set(doc.getKey(), new Attachment(this.reconnectStreamDelay, doc, res.getDocumentId(), isRealtimeSync));
                    if (isRealtimeSync) {
                        await this.runWatchLoop(doc.getKey());
                    }
                }
                logger.info(`[AD] c:"${this.getKey()}" attaches d:"${doc.getKey()}"`);
                resolve(doc);
            });
        });
    }
    /**
     * `detach` detaches the given document from this client. It tells the
     * server that this client will no longer synchronize the given document.
     *
     * To collect garbage things like CRDT tombstones left on the document, all
     * the changes should be applied to other replicas before GC time. For this,
     * if the document is no longer used by this client, it should be detached.
     */
    detach(doc) {
        if (!this.isActive()) {
            throw new YorkieError(Code.ClientNotActive, `${this.key} is not active`);
        }
        const attachment = this.attachmentMap.get(doc.getKey());
        if (!attachment) {
            throw new YorkieError(Code.DocumentNotAttached, `${doc.getKey()} is not attached`);
        }
        doc.update((_, p) => p.clear());
        return new Promise((resolve, reject) => {
            const req = new yorkie_pb.DetachDocumentRequest();
            req.setClientId(this.id);
            req.setDocumentId(attachment.docID);
            req.setChangePack(converter.toChangePack(doc.createChangePack()));
            this.rpcClient.detachDocument(req, { 'x-shard-key': `${this.apiKey}/${doc.getKey()}` }, async (err, res) => {
                if (err) {
                    logger.error(`[DD] c:"${this.getKey()}" err :`, err);
                    reject(err);
                    return;
                }
                const pack = converter.fromChangePack(res.getChangePack());
                doc.applyChangePack(pack);
                if (doc.getStatus() !== DocumentStatus.Removed) {
                    doc.setStatus(DocumentStatus.Detached);
                }
                this.detachInternal(doc.getKey());
                logger.info(`[DD] c:"${this.getKey()}" detaches d:"${doc.getKey()}"`);
                resolve(doc);
            });
        });
    }
    /**
     * `pause` changes the synchronization mode of the given document to manual.
     */
    pause(doc) {
        if (!this.isActive()) {
            throw new YorkieError(Code.ClientNotActive, `${this.key} is not active`);
        }
        return this.changeRealtimeSync(doc, false);
    }
    /**
     * `resume` changes the synchronization mode of the given document to realtime.
     */
    resume(doc) {
        if (!this.isActive()) {
            throw new YorkieError(Code.ClientNotActive, `${this.key} is not active`);
        }
        return this.changeRealtimeSync(doc, true);
    }
    /**
     * `pauseRemoteChanges` pauses the synchronization of remote changes,
     * allowing only local changes to be applied.
     */
    pauseRemoteChanges(doc) {
        if (!this.isActive()) {
            throw new YorkieError(Code.ClientNotActive, `${this.key} is not active`);
        }
        const attachment = this.attachmentMap.get(doc.getKey());
        if (!attachment) {
            throw new YorkieError(Code.DocumentNotAttached, `${doc.getKey()} is not attached`);
        }
        attachment.changeSyncMode(SyncMode.PushOnly);
    }
    /**
     * `resumeRemoteChanges` resumes the synchronization of remote changes,
     * allowing both local and remote changes to be applied.
     */
    resumeRemoteChanges(doc) {
        if (!this.isActive()) {
            throw new YorkieError(Code.ClientNotActive, `${this.key} is not active`);
        }
        const attachment = this.attachmentMap.get(doc.getKey());
        if (!attachment) {
            throw new YorkieError(Code.DocumentNotAttached, `${doc.getKey()} is not attached`);
        }
        attachment.changeSyncMode(SyncMode.PushPull);
        attachment.remoteChangeEventReceived = true;
    }
    /**
     * `changeRealtimeSync` changes the synchronization mode of the given document.
     */
    async changeRealtimeSync(doc, isRealtimeSync) {
        // TODO(hackerwins): We need to consider extracting this method to `attachment`
        // with other methods like runWatchLoop, disconnectWatchStream.
        const attachment = this.attachmentMap.get(doc.getKey());
        if (!attachment) {
            throw new YorkieError(Code.DocumentNotAttached, `${doc.getKey()} is not attached`);
        }
        if (!attachment.changeRealtimeSync(isRealtimeSync)) {
            return doc;
        }
        if (isRealtimeSync) {
            await this.runWatchLoop(doc.getKey());
            return doc;
        }
        this.eventStreamObserver.next({
            type: ClientEventType.StreamConnectionStatusChanged,
            value: StreamConnectionStatus.Disconnected,
        });
        logger.debug(`[WD] c:"${this.getKey()}" unwatches`);
        return doc;
    }
    /**
     * `sync` pushes local changes of the attached documents to the server and
     * receives changes of the remote replica from the server then apply them to
     * local documents.
     */
    sync(doc, syncMode = SyncMode.PushPull) {
        if (!this.isActive()) {
            throw new YorkieError(Code.ClientNotActive, `${this.key} is not active`);
        }
        const promises = [];
        if (doc) {
            // prettier-ignore
            const attachment = this.attachmentMap.get(doc.getKey());
            if (!attachment) {
                throw new YorkieError(Code.DocumentNotAttached, `${doc.getKey()} is not attached`);
            }
            promises.push(this.syncInternal(attachment, syncMode));
        }
        else {
            this.attachmentMap.forEach((attachment) => {
                promises.push(this.syncInternal(attachment, attachment.syncMode));
            });
        }
        return Promise.all(promises).catch((err) => {
            this.eventStreamObserver.next({
                type: ClientEventType.DocumentSynced,
                value: DocumentSyncResultType.SyncFailed,
            });
            throw err;
        });
    }
    /**
     * `remove` removes the given document.
     */
    remove(doc) {
        if (!this.isActive()) {
            throw new YorkieError(Code.ClientNotActive, `${this.key} is not active`);
        }
        const attachment = this.attachmentMap.get(doc.getKey());
        if (!attachment) {
            throw new YorkieError(Code.DocumentNotAttached, `${doc.getKey()} is not attached`);
        }
        doc.setActor(this.id);
        return new Promise((resolve, reject) => {
            const req = new yorkie_pb.RemoveDocumentRequest();
            req.setClientId(this.id);
            req.setDocumentId(attachment.docID);
            const pbChangePack = converter.toChangePack(doc.createChangePack());
            pbChangePack.setIsRemoved(true);
            req.setChangePack(pbChangePack);
            this.rpcClient.removeDocument(req, { 'x-shard-key': `${this.apiKey}/${doc.getKey()}` }, async (err, res) => {
                if (err) {
                    logger.error(`[RD] c:"${this.getKey()}" d:"${doc.getKey()}" err :`, err);
                    reject(err);
                    return;
                }
                const pack = converter.fromChangePack(res.getChangePack());
                doc.applyChangePack(pack);
                this.detachInternal(doc.getKey());
                logger.info(`[RD] c:"${this.getKey()}" removes d:"${doc.getKey()}"`);
                resolve();
            });
        });
    }
    /**
     * `subscribe` subscribes to the given topics.
     */
    subscribe(nextOrObserver, error, complete) {
        return this.eventStream.subscribe(nextOrObserver, error, complete);
    }
    /**
     * `getID` returns a ActorID of client.
     */
    getID() {
        return this.id;
    }
    /**
     * `getKey` returns a key of client.
     */
    getKey() {
        return this.key;
    }
    /**
     * `isActive` checks if the client is active.
     */
    isActive() {
        return this.status === ClientStatus.Activated;
    }
    /**
     * `getStatus` returns the status of this client.
     */
    getStatus() {
        return this.status;
    }
    runSyncLoop() {
        const doLoop = () => {
            if (!this.isActive()) {
                logger.debug(`[SL] c:"${this.getKey()}" exit sync loop`);
                return;
            }
            const syncJobs = [];
            for (const [, attachment] of this.attachmentMap) {
                if (attachment.needRealtimeSync()) {
                    attachment.remoteChangeEventReceived = false;
                    syncJobs.push(this.syncInternal(attachment, attachment.syncMode));
                }
            }
            Promise.all(syncJobs)
                .then(() => setTimeout(doLoop, this.syncLoopDuration))
                .catch((err) => {
                logger.error(`[SL] c:"${this.getKey()}" sync failed:`, err);
                this.eventStreamObserver.next({
                    type: ClientEventType.DocumentSynced,
                    value: DocumentSyncResultType.SyncFailed,
                });
                setTimeout(doLoop, this.retrySyncLoopDelay);
            });
        };
        logger.debug(`[SL] c:"${this.getKey()}" run sync loop`);
        doLoop();
    }
    async runWatchLoop(docKey) {
        const attachment = this.attachmentMap.get(docKey);
        if (!attachment) {
            throw new YorkieError(Code.DocumentNotAttached, `${docKey} is not attached`);
        }
        return attachment.runWatchLoop((onDisconnect) => {
            if (!this.isActive()) {
                throw new YorkieError(Code.ClientNotActive, `${this.key} is not active`);
            }
            const req = new yorkie_pb.WatchDocumentRequest();
            req.setClientId(this.id);
            req.setDocumentId(attachment.docID);
            const stream = this.rpcClient.watchDocument(req, {
                'x-shard-key': `${this.apiKey}/${docKey}`,
            });
            this.eventStreamObserver.next({
                type: ClientEventType.StreamConnectionStatusChanged,
                value: StreamConnectionStatus.Connected,
            });
            logger.info(`[WD] c:"${this.getKey()}" watches d:"${docKey}"`);
            return new Promise((resolve) => {
                const onStreamDisconnect = () => {
                    this.eventStreamObserver.next({
                        type: ClientEventType.StreamConnectionStatusChanged,
                        value: StreamConnectionStatus.Disconnected,
                    });
                    logger.debug(`[WD] c:"${this.getKey()}" unwatches`);
                    onDisconnect();
                };
                stream.on('data', (resp) => {
                    this.handleWatchDocumentsResponse(attachment, resp);
                    resolve(stream);
                });
                stream.on('end', onStreamDisconnect);
                stream.on('error', onStreamDisconnect);
            });
        });
    }
    handleWatchDocumentsResponse(attachment, resp) {
        const docKey = attachment.doc.getKey();
        if (resp.hasInitialization()) {
            const clientIDs = resp.getInitialization().getClientIdsList();
            const onlineClients = new Set();
            for (const clientID of clientIDs) {
                onlineClients.add(clientID);
            }
            attachment.doc.setOnlineClients(onlineClients);
            attachment.doc.publish({
                type: DocEventType.Initialized,
                value: attachment.doc.getPresences(),
            });
            return;
        }
        const pbWatchEvent = resp.getEvent();
        const eventType = pbWatchEvent.getType();
        const publisher = pbWatchEvent.getPublisher();
        switch (eventType) {
            case resources_pb.DocEventType.DOC_EVENT_TYPE_DOCUMENT_CHANGED:
                attachment.remoteChangeEventReceived = true;
                this.eventStreamObserver.next({
                    type: ClientEventType.DocumentChanged,
                    value: [docKey],
                });
                break;
            case resources_pb.DocEventType.DOC_EVENT_TYPE_DOCUMENT_WATCHED:
                attachment.doc.addOnlineClient(publisher);
                // NOTE(chacha912): We added to onlineClients, but we won't trigger watched event
                // unless we also know their initial presence data at this point.
                if (attachment.doc.hasPresence(publisher)) {
                    attachment.doc.publish({
                        type: DocEventType.Watched,
                        value: {
                            clientID: publisher,
                            presence: attachment.doc.getPresence(publisher),
                        },
                    });
                }
                break;
            case resources_pb.DocEventType.DOC_EVENT_TYPE_DOCUMENT_UNWATCHED: {
                const presence = attachment.doc.getPresence(publisher);
                attachment.doc.removeOnlineClient(publisher);
                // NOTE(chacha912): There is no presence, when PresenceChange(clear) is applied before unwatching.
                // In that case, the 'unwatched' event is triggered while handling the PresenceChange.
                if (presence) {
                    attachment.doc.publish({
                        type: DocEventType.Unwatched,
                        value: { clientID: publisher, presence },
                    });
                }
                break;
            }
        }
    }
    detachInternal(docKey) {
        // NOTE(hackerwins): If attachment is not found, it means that the document
        // has been already detached by another routine.
        // This can happen when detach or remove is called while the watch loop is
        // running.
        const attachment = this.attachmentMap.get(docKey);
        if (!attachment) {
            return;
        }
        attachment.cancelWatchStream();
        logger.debug(`[WD] c:"${this.getKey()}" unwatches`);
        this.eventStreamObserver.next({
            type: ClientEventType.StreamConnectionStatusChanged,
            value: StreamConnectionStatus.Disconnected,
        });
        this.attachmentMap.delete(docKey);
    }
    syncInternal(attachment, syncMode) {
        const { doc, docID } = attachment;
        return new Promise((resolve, reject) => {
            const req = new yorkie_pb.PushPullChangesRequest();
            req.setClientId(this.id);
            req.setDocumentId(docID);
            const reqPack = doc.createChangePack();
            const localSize = reqPack.getChangeSize();
            req.setChangePack(converter.toChangePack(reqPack));
            req.setPushOnly(syncMode === SyncMode.PushOnly);
            let isRejected = false;
            this.rpcClient
                .pushPullChanges(req, { 'x-shard-key': `${this.apiKey}/${doc.getKey()}` }, (err, res) => {
                if (err) {
                    logger.error(`[PP] c:"${this.getKey()}" err :`, err);
                    isRejected = true;
                    reject(err);
                    return;
                }
                const respPack = converter.fromChangePack(res.getChangePack());
                // NOTE(chacha912, hackerwins): If syncLoop already executed with
                // PushPull, ignore the response when the syncMode is PushOnly.
                if (respPack.hasChanges() && syncMode === SyncMode.PushOnly) {
                    return;
                }
                doc.applyChangePack(respPack);
                this.eventStreamObserver.next({
                    type: ClientEventType.DocumentSynced,
                    value: DocumentSyncResultType.Synced,
                });
                // NOTE(chacha912): If a document has been removed, watchStream should
                // be disconnected to not receive an event for that document.
                if (doc.getStatus() === DocumentStatus.Removed) {
                    this.detachInternal(doc.getKey());
                }
                const docKey = doc.getKey();
                const remoteSize = respPack.getChangeSize();
                logger.info(`[PP] c:"${this.getKey()}" sync d:"${docKey}", push:${localSize} pull:${remoteSize} cp:${respPack
                    .getCheckpoint()
                    .toTestString()}`);
            })
                .on('end', () => {
                if (isRejected) {
                    return;
                }
                resolve(doc);
            });
        });
    }
}

;// CONCATENATED MODULE: ./src/yorkie.ts
/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















/**
 * The top-level yorkie namespace with additional properties.
 *
 * In production, this will be called exactly once and the result
 * assigned to the `yorkie` global.
 *
 * e.g) `new yorkie.Client(...);`
 *
 * @public
 */
const yorkie = {
    Client: Client,
    Document: Document,
    Primitive: Primitive,
    Text: Text,
    Counter: Counter,
    Tree: Tree,
    IntType: CounterType.IntegerCnt,
    LongType: CounterType.LongCnt,
};
/* harmony default export */ const src_yorkie = (yorkie);

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=yorkie-js-sdk.js.map